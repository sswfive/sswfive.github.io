<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时笺煮雨 ☕️</title>
  
  <subtitle>BluesSen Blog</subtitle>
  <link href="http://sswfive.xyz/atom.xml" rel="self"/>
  
  <link href="http://sswfive.xyz/"/>
  <updated>2025-10-26T16:28:53.000Z</updated>
  <id>http://sswfive.xyz/</id>
  
  <author>
    <name>BluesSen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阅后记：刘润2025年度演讲《进化的力量》</title>
    <link href="http://sswfive.xyz/2025/10/26/thinking/251026-liurun-speech-2025/"/>
    <id>http://sswfive.xyz/2025/10/26/thinking/251026-liurun-speech-2025/</id>
    <published>2025-10-26T08:20:01.000Z</published>
    <updated>2025-10-26T16:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个周六的晚上，朋友在群里分享了一篇微信公众号文章<a href="https://mp.weixin.qq.com/s/QOef7-YF_-XHKYm1Y729tA">《刘润年度演讲2025：进化的力量》</a>，文章很长，我花了整整75分钟才读完——印象中这是第一次为一篇文章投入了这么长时间，而且是一口气读完。内容非常打动我，于是趁着今天周日，特意找了这场演讲的视频（全长4小时55分钟）下载下来并上传到网盘（附<a href="https://pan.baidu.com/s/1hawbWZexPvFeRuU5D-h0MQ?pwd=fmn8">视频链接</a>），又花了一整个下午认真看完。下面是我个人觉得演讲中一些值得记录的精彩观点。</p><p>整场演讲围绕“大迁徙”这一核心主题，系统阐述了当前商业环境下企业生存与增长的六大进化路径。核心命题是：在“生态位干旱化”（如餐饮客流减少、母婴市场萎缩等）的背景下，企业如何活下去并实现持续增长？刘润老师指出，问题的根源在于需求端发生结构性变化，而解决方案是：开启“大迁徙”，主动离开内卷红海，寻找新的需求草原。</p><p>演讲共分为六个主题，具体内容如下：</p><h2 id="开篇：大迁徙"><a href="#开篇：大迁徙" class="headerlink" title="开篇：大迁徙"></a>开篇：大迁徙</h2><p>用角马迁徙的三个关建选择来比喻企业的出路：</p><ul><li>停止内卷：角马面临的选择：留在干旱的塞伦盖蒂与同类争夺有限资源（内卷），或冒险向北迁徙寻找新草原。对应企业：在红海市场中继续价格战，还是寻找新需求。</li><li>穿越生死线：角马必须渡过充满鳄鱼的马拉河，对应企业转型过程中的阵痛与风险。</li><li>抵达新草原：成功迁徙的角马获得新生，对应企业找到新增长点的美好前景。</li></ul><blockquote><p>大迁徙的本质是：告别内卷、穿越生死、奔向新生。</p></blockquote><h2 id="主题一：品类大迁徙，打破品类僵化"><a href="#主题一：品类大迁徙，打破品类僵化" class="headerlink" title="主题一：品类大迁徙，打破品类僵化"></a>主题一：品类大迁徙，打破品类僵化</h2><blockquote><p>对旧需求，用力过猛；对新需求，反应迟钝。</p></blockquote><p>问题：企业过度成迷优化旧产品（如床仅用于睡觉，餐桌忽略电器需求），忽视新需求。<br>案例：</p><ul><li>烤匠麻辣烤鱼：从“好吃”迁移到“情绪价值”（黑金风格、花椒冰淇淋、生日惊喜）。</li><li>AirBuggy: 从婴儿车转型到宠物车，核心能力是“为无法言说的爱设计产品”。<br>方法：</li><li><blockquote><p><strong>停下笔</strong>（反思旧需求是否仍然重要）-&gt;<strong>换卷子</strong>（识别用户新抱怨）-&gt; <strong>答新题</strong>（用能力满足新需求）。</p></blockquote><ul><li>第一，关于“停下笔”：我们产品的本质，到底是为了解决哪个“旧问题”？这个旧问题，今天还重要吗？</li><li>第二，关于“换卷子”：今天，用户正在抱怨的“新问题”是什么？哪些正在涌现？哪些正在变强？</li><li>第三，关于“答新题”：如果我们放下对现有产品的执念，从零开始创造一个新“物种”，它会是什么样子？</li></ul></li></ul><h2 id="主题二：价值大迁徙，消费心理重构"><a href="#主题二：价值大迁徙，消费心理重构" class="headerlink" title="主题二：价值大迁徙，消费心理重构"></a>主题二：价值大迁徙，消费心理重构</h2><blockquote><p>价值重排，指的是同一个人。同一个人，在心中对一类商品，越来越谨慎，但对另一类商品，花钱不眨眼。价值重排，讲的是“你”和“另一个你”的斗争。是同一个你的内心挣扎。以及挣扎之后的，“该省省，该花花，骑着自行车去酒吧”。</p></blockquote><p>现象：消费者“该省省该花花”（如省打车费，却愿为Labubu花99元），本质是“<strong>价值重排</strong>”</p><ul><li>该省省账户（生存型支出）：追求性价比，如5.9元咖啡。</li><li>该花花账户（意义型支出）：追求“心价比”，为热爱情感买单。</li></ul><p>方法：提供三种情绪解药：</p><ul><li>多回掌控感（如保健品零食化：东阿阿胶软糖）</li><li>共鸣软反抗（如哪咤，Labubu的叛逆审美）</li><li>创造小满足（如地铁卡做成玉玺造型）</li></ul><h2 id="主题三：模式大迁徙，回归能力原点"><a href="#主题三：模式大迁徙，回归能力原点" class="headerlink" title="主题三：模式大迁徙，回归能力原点"></a>主题三：模式大迁徙，回归能力原点</h2><blockquote><p>产品被淘汰，可能只是表象；只要能力不被淘汰，你就还有机会。</p></blockquote><p>关键：区分“产品”（可能被淘汰）和“能力”（可迁移）<br>案例：</p><ul><li>京都纹付（百年染坊）：从和服染黑转型二手服装染黑，核心是“深黑染色技术”。</li><li>味之素（味精厂）：利用氨基酸技术生产芯片绝缘体（市占率99%）。</li><li>微软埋粪案：废物公司Vaulted Deep用深井技术封存碳，卖“碳抵消指标”给微软。<br>方法：</li><li><blockquote><p>能力盘点（行业消失后还剩什么？）-&gt; 市场扫描（谁需要这能力？）-&gt; 模式验证（新业务如何赚钱？）</p></blockquote></li></ul><h2 id="主题四：出海大迁徙，规避盲区"><a href="#主题四：出海大迁徙，规避盲区" class="headerlink" title="主题四：出海大迁徙，规避盲区"></a>主题四：出海大迁徙，规避盲区</h2><blockquote><p>成功的路径，往往千差万别；但失败的陷进，却总是惊人地相似。</p></blockquote><p>心态盲区：</p><ul><li>勿用”故乡的地图“导航全球（如印尼用煤气罐而非管道煤气）</li><li>勿用”一把尺管理“全球员工（如肯尼亚重族群认可）</li></ul><p>战术盲区：</p><ul><li>忌“刻舟执念”（强卖中国产品）</li><li>忌“焦土竞争”（价格战毁市场）</li><li>忌“淘金客心态”（不贡献本地就业&#x2F;税收）</li></ul><p>格局盲区：</p><ul><li>克服”荒野恐惧”（肯尼亚电商需自建提货点、支付系统）</li><li>补“合规短板”（ESG规则）</li></ul><p>终极忠告：</p><ul><li>反对“遥控式出海”，必须肉身实地调研。</li></ul><h2 id="主题五：智能大迁徙，与AI智能体共生"><a href="#主题五：智能大迁徙，与AI智能体共生" class="headerlink" title="主题五：智能大迁徙，与AI智能体共生"></a>主题五：智能大迁徙，与AI智能体共生</h2><blockquote><p>我们以为数字分身的上限是“以假乱真”，但其实它的起点是“解放真人”。<br>AI不会让新手凭空起飞，但它能给高手插上翅膀。</p></blockquote><p>智能体分五级（L1-L5),核心是让AI从“聊天工具”变成“行动主体”：</p><ul><li>L1数字分身（模仿）：如罗永浩数字人直播带货5500万。</li><li>L2创作伙伴（思考）：如AI生成视频（角马过河），人做导演。</li><li>L3执行助手（执行）：如Base 44 用AI 3分钟开发销售培训APP。</li><li>L4协作团队（组队）：如AI写作团（主编、写手、资料员协作改稿）。</li><li>L5具身智能（物理改造）：如人形机器人（宇树科技）兼容人类环境。</li></ul><h2 id="主题六：人口大迁徙，服务银发经济"><a href="#主题六：人口大迁徙，服务银发经济" class="headerlink" title="主题六：人口大迁徙，服务银发经济"></a>主题六：人口大迁徙，服务银发经济</h2><blockquote><p>年轻时，我们想尽办法省时间；等到老了，我们又得想尽办法花时间。<br>用看见，去回应“奋斗者”的渴望。应该是，用陪伴，去驱散“自由者”的孤独。应该是，用科技，去接住“托付者”的尊严。</p></blockquote><p>中国3亿“婴儿潮”（1962-1975生）进入50+岁，分为三类：</p><ul><li>奋斗者（50-65岁）：忙累需被看见（如中老年短剧《闪婚老伴是豪门》充值3000万）。</li><li>自由者（65-75岁）：孤独需陪伴（如健身教练上门陪老人并记录“口述史”）。</li><li>托付者（75+岁）：失能需尊严（如助浴仓用雾化技术免水洗）。</li></ul><h2 id="结尾：第四百万零一种活法"><a href="#结尾：第四百万零一种活法" class="headerlink" title="结尾：第四百万零一种活法"></a>结尾：第四百万零一种活法</h2><blockquote><p>所以，进化，是人类最好的战略顾问。</p></blockquote><p>刘润老师表达了在充满不确定性的时代，企业不应只模仿“狮子”或“角马”这两种显而易见的生存策略，而应该从自然界400万种物种的进化智慧中，找到属于自己的第400万零一种活法。</p><p>向进化求战略</p><p>哨刺金合欢的“空房子”策略：共生​</p><ul><li><blockquote><p>曾聪明的增长不是竞争，而是共生</p></blockquote></li></ul><p>织布鸟的“样板间”策略：终局体验​</p><ul><li><blockquote><p>最精彩的开局，是让客户直接看到终局。</p></blockquote></li></ul><p>其他生物的生存智慧​</p><ul><li><blockquote><p><strong>汤姆逊瞪羚​</strong>​：通过夸张的跳跃（炫耀体力）来告诉猎豹“我很强，别追我”，从而​<strong>​避免战斗​</strong>​。</p></blockquote></li><li><blockquote><p><strong>​斑马​</strong>​：依靠黑白条纹在群体奔跑时让狮子眼花缭乱，从而​<strong>​模糊目标​</strong>​。</p></blockquote></li><li><blockquote><p><strong>​疣猪​</strong>​：因腿长脖子短，采用“跪姿”吃草，以​<strong>​妥协​</strong>​解决自身身体结构的短板。</p></blockquote></li></ul><h2 id="一些精彩的观点"><a href="#一些精彩的观点" class="headerlink" title="一些精彩的观点"></a>一些精彩的观点</h2><ul><li><blockquote><p>当水草不在丰美，停在原地不是坚守，而是一种错付。</p></blockquote></li><li><blockquote><p>大迁徙的终点，有时，不是让你去到一个新地方，而是让你成为一个新自己。</p></blockquote></li><li><blockquote><p>所有产品的价值，都在于满足用户的需求。“产品”本身没有价值，能满足“需求”的产品，才有价值。但是，消费者的需求从来不止一个。他们彼此交织，错综复杂，就组成了“需求空间”。</p></blockquote></li><li><blockquote><p>完美适应“昨天”的代价，是失去拥抱“明天”的能力。一旦需求变化，最先陷入变动的，就是曾经的王者。</p></blockquote></li><li><blockquote><p>停下笔，换卷子，答新题。</p></blockquote></li><li><blockquote><p>该省省，该花花，骑着自行车去酒吧。（骑着自行车去酒吧，省下的是路费，花掉的是对苟且生活的反抗）</p></blockquote></li><li><blockquote><p>为什么？因为黑色，是所有颜色的终点，也是所有故事的起点。我们常说，一白遮百丑；但在这里，是一黑获新生。</p></blockquote></li><li><blockquote><p>我们经常犯的一个致命错误，就是把“产品”当成了“能力”。，然而，能力是“根”，产品是“花”。</p></blockquote></li><li><blockquote><p>你眼里的“副产品”，可能是别人眼里的“救命稻草”。</p></blockquote></li><li><blockquote><p>不要拿着“故乡的地图”，去导航全世界。放下想当然，学会看当地的地图。</p></blockquote></li><li><blockquote><p>什么是荒野的恐惧？就是只敢走别人走过的路，不敢踏入没人开垦过的荒野。</p></blockquote></li><li><blockquote><p>所谓“契约优先”，就是：关系是“易碎品”，规则才是“承重墙”。</p></blockquote></li><li><blockquote><p>AI不会让新手凭空起飞，但它能给高手插上翅膀。</p></blockquote></li><li><blockquote><p>过去，人的价值在于“解决问题”；未来，人的价值在于“定义问题”。</p></blockquote></li><li><blockquote><p>年轻时，我们想尽办法省时间；等到老了，我们又得想尽办法花时间。</p></blockquote></li><li><blockquote><p>当想象的成本降为零，决策的质量，就无限接近100%。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个周六的晚上，朋友在群里分享了一篇微信公众号文章&lt;a href=&quot;https://mp.weixin.qq.com/s/QOef7-YF_-XHKYm1Y729tA&quot;&gt;《刘润年度演讲2025：进化的力量》&lt;/a&gt;，文章很长，我花了整整75分钟才读完——印象中这是第一次为一</summary>
      
    
    
    
    <category term="时笺" scheme="http://sswfive.xyz/categories/%E6%97%B6%E7%AC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法之【排序】</title>
    <link href="http://sswfive.xyz/2025/09/23/dsa/algo_sort/"/>
    <id>http://sswfive.xyz/2025/09/23/dsa/algo_sort/</id>
    <published>2025-09-23T15:46:27.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的概述"><a href="#排序的概述" class="headerlink" title="排序的概述"></a>排序的概述</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul><li><p>常用的：</p><ul><li><p>冒泡排序</p></li><li><p>插入排序</p></li><li><p>选择排序</p></li><li><p>归并排序</p></li><li><p>快速排序</p></li><li><p>计数排序</p></li><li><p>基数排序</p></li><li><p>桶排序</p></li></ul></li><li><p>不常用的：</p><ul><li>猴子排序</li><li>睡眠排序</li><li>面条排序</li></ul></li></ul><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><blockquote><p>按照时间复杂度进行分类</p></blockquote><ul><li>冒泡、插入、选择 ： O(n^2)</li><li>快排、归并： O(nlogn)</li><li>桶、计数、基数：O(n)</li></ul><h2 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h2><blockquote><p>学习排序算法，除了学习算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法</p></blockquote><h3 id="分析执行效率"><a href="#分析执行效率" class="headerlink" title="分析执行效率"></a>分析执行效率</h3><ol><li>最好情况、最坏情况、平均情况时间复杂度<ul><li>对于要排序的数据，有的接近排序，有的完全无序，有序度不同的数据，对于排序的执行时间效率会差别很大</li></ul></li><li>时间复杂度的系数、常数、低阶<ul><li>在数据规模很大的时候，通常会忽略系数、常数、低阶，但实际开发中，通常需要排序的数据量级是相对较小的，所以此时需要考虑系数、常数、低阶对排序的执行时间效率的影响。</li></ul></li><li>比较次数和交换（或移动）次数<ul><li>基于比较的排序算法，通常会涉及两种操作，元素大小比较和元素交换移动，</li></ul></li></ol><h3 id="分析内存消耗"><a href="#分析内存消耗" class="headerlink" title="分析内存消耗"></a>分析内存消耗</h3><ol><li>算法的内存消耗可以通过空间复杂度来衡量，在排序算法的空间复杂度中，引入了原地排序概念，对于原地排序算法，就是特指空间复杂度是O(1)的排序算法。<ul><li>冒泡、插入、选择都是原地排序算法。</li></ul></li></ol><h3 id="分析稳定性"><a href="#分析稳定性" class="headerlink" title="分析稳定性"></a>分析稳定性</h3><ol><li>稳定性是衡量排序算法好坏的重要指标。<ul><li>稳定的排序算法：经过排序后，相等元素之间的原有的先后顺序不变</li><li>不稳定的排序算法：经过排序后，相等元素之间的位置发生改变</li></ul></li></ol><h2 id="冒泡排序（Bubble-Sort）分析"><a href="#冒泡排序（Bubble-Sort）分析" class="headerlink" title="冒泡排序（Bubble Sort）分析"></a>冒泡排序（Bubble Sort）分析</h2><ul><li><p>概念：</p><ul><li><p>冒泡排序只会操作相邻的两个数据。</p></li><li><p>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满就让他俩互换。</p></li><li><p>一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序。</p></li></ul></li><li><p>特点：</p><ul><li>冒泡排序是原地排序算法.<ul><li>冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度是O(1)</li></ul></li><li>最好情况时间复杂度：O(n)</li><li>最坏情况时间复杂度：O(n^2)</li><li>平均时间复杂度：O(n^2)<ul><li>结合概率论知识进行分析</li><li>引入有序度和逆序度进行分析</li></ul></li></ul></li><li><p>有序度：</p><ul><li><p>有序度是数组中具有有序关系的元素对的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure></li><li><p>满有序度：完全有序的数组的有序度叫做满有序度</p></li></ul></li><li><p>逆序度：</p><ul><li><p>和有序度相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>公式分析：</p><ul><li>逆序度 &#x3D; 满有序度 - 有序度</li><li>排序的过程其实就是一种增加有序度，减少逆序度的过程，最后达到 满有序度，就说明排序完成。</li><li>冒泡排序包含两个操作原子，比较和交换，每交换一次，有序度加1，不管算法怎么改变，交换次数总是确定的，即为逆序度，也就是：n*(n-1)&#x2F;2–初始有序度。</li></ul></li></ul><h2 id="插入排序（Insertion-Sort）分析"><a href="#插入排序（Insertion-Sort）分析" class="headerlink" title="插入排序（Insertion Sort）分析"></a>插入排序（Insertion Sort）分析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序的概述&quot;&gt;&lt;a href=&quot;#排序的概述&quot; class=&quot;headerlink&quot; title=&quot;排序的概述&quot;&gt;&lt;/a&gt;排序的概述&lt;/h2&gt;&lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python开发必备：解锁魔法方法的实用技巧大全</title>
    <link href="http://sswfive.xyz/2025/09/23/tech/python/250923-py-magic-methods/"/>
    <id>http://sswfive.xyz/2025/09/23/tech/python/250923-py-magic-methods/</id>
    <published>2025-09-23T14:34:51.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python的魔法方法是Python面向对象编程的精髓，理解魔法方法不仅能让开发者写出更优雅的代码，更重要的是能让你深入理解Python对象模型的工作原理。那么今天我们就来系统性的梳理一下Python魔法方法的基础知识、常用魔法方法与分类，以及应用场景实践。</p><ul><li>官方文档：点击前往 -&gt;<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">魔法方法介绍</a></li></ul><h2 id="什么是魔法方法？"><a href="#什么是魔法方法？" class="headerlink" title="什么是魔法方法？"></a>什么是魔法方法？</h2><p>想象一下这样的场景：当你写下 <code>len([1, 2, 3])</code> 时，Python是如何知道要返回3的？当你使用 <code>+</code> 连接两个字符串时，背后发生了什么？答案就藏在魔法方法中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些看似普通的操作，背后都有魔法方法在工作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))        <span class="comment"># 调用了 list.__len__()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>)     <span class="comment"># 调用了 str.__add__()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">42</span>))               <span class="comment"># 调用了 int.__str__()</span></span><br></pre></td></tr></table></figure><p>魔法方法是Python中以双下划线开头和结尾的特殊方法，也称为双下划线方法（如<code>__init__</code>、<code>__str__</code>、<code>__new__</code>等）。它们是Python中的一种协议机制，也是面向对象编程的核心机制之一，赋予了开发者自定义类行为的能力，让自定义类能像内置类型一样与Python语法无缝集成。</p><h2 id="了解并理解魔法方法"><a href="#了解并理解魔法方法" class="headerlink" title="了解并理解魔法方法"></a>了解并理解魔法方法</h2><p>对于我们Pythoner来说，不要把它们看作简单的”特殊方法”，而应该理解为：</p><ul><li><strong>是协议的实现</strong>：魔法方法是Python鸭子类型的核心体现</li><li><strong>是语言的扩展点</strong>：通过它们可以扩展Python语言本身的能力</li><li><strong>是语法的委托机制</strong>：Python的语法很大程度上委托给对象本身来定义<br>正如Python之禅所说：”Python应该提供一种方法，但最好是只有一种明显的方法来做这件事。”魔法方法正是这种哲学的完美体现。</li></ul><h2 id="魔法方法的特点与分类"><a href="#魔法方法的特点与分类" class="headerlink" title="魔法方法的特点与分类"></a>魔法方法的特点与分类</h2><p>魔法方法是由Python解释器在特定场景下自动调用，无需显示调用，例如当你使用<code>len(obj)</code> 时，Python会调用对象的<code>__len__</code>方法。<br>由于魔法方法种类繁多，根据功能可以分为以下几类：</p><ul><li>对象生命周期管理</li><li>对象表示与格式化</li><li>运算符重载</li><li>属性访问控制</li><li>容器与迭代器</li><li>同（异）步上下文管理</li><li>可调用对象与描述符</li><li>一些不常见但很有用的用法</li></ul><p>下面将针对常用的场景进行展开分析</p><h2 id="魔法方法在不同场景中的分析与实践"><a href="#魔法方法在不同场景中的分析与实践" class="headerlink" title="魔法方法在不同场景中的分析与实践"></a>魔法方法在不同场景中的分析与实践</h2><h3 id="场景1：对象生命周期管理"><a href="#场景1：对象生命周期管理" class="headerlink" title="场景1：对象生命周期管理"></a>场景1：对象生命周期管理</h3><p>下列这些魔法方法控制对象的创建，初始化和销毁。</p><ul><li><code>__new__(cls, *args, **kwargs)</code>：控制对象的创建，是真正的<strong>构造器</strong>，是对象创建过程中的第一个方法（静态方法），它在<code>__init__</code>之前调用。通常情况下，是不需要直接使用<code>__new__</code>，但如果你需要控制对象的创建过程（如：实现单例模式或自定义元类），可以重写它。</li><li><code>__init__(self, *args, **kwargs)</code>：是<strong>初始化器</strong>，初始化对象的，对象在内存已经分配，即self已经存在，接收参数并设置初始状态，它在每次创建对象时被自动调用，几乎每个类都会实现它。</li><li><code>__del__(self)</code>：定义对象被垃圾回收时的行为。需要注意的是，最好谨慎使用，如果使用不当，可能引发资源管理问题。因为该方法不保证一定被调用，其主要依赖垃圾回收机制的策略。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在__init__之前调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__: 创建对象实例&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置对象初始状态&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__init__: 初始化资源 &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>._resource = <span class="variable language_">self</span>._acquire_resource()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对象被垃圾回收时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__del__: 清理资源 &#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._release_resource()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_acquire_resource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取系统资源...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;模拟的资源句柄&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_release_resource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;释放系统资源...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">resource = Resource(<span class="string">&quot;数据库连接&quot;</span>)</span><br><span class="line"><span class="comment"># 当对象被垃圾回收时，__del__会自动调用</span></span><br></pre></td></tr></table></figure><h3 id="场景2：对象表示与格式化"><a href="#场景2：对象表示与格式化" class="headerlink" title="场景2：对象表示与格式化"></a>场景2：对象表示与格式化</h3><p>下列这些魔法方法控制对象的字符串表示，用于调试或展示。</p><ul><li><code>__str__(self)</code>：为最终用户设计，要求可读性好，定义<code>str(obj)</code>或<code>print(obj)</code>时的行为，也就是常被用于输出或打印，这个方法应该返回一个易于理解的字符串，用于展示对象的“外观”。</li><li><code>__repr__(self)</code>：为开发者设计，要求明确无误，定义<code>repr(obj)</code>或交互环境中对象的表示，通常用于开发者调试，返回详细信息，它的目标是生成一个可以通过<code>eval()</code>恢复的字符串（即反向构造对象）。</li><li><code>__format__(self, format_spec)</code>：定义<code>format(obj, spec)</code>或<code>f-string</code> 中的格式化的行为，支持自定义格式化。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是对象的官方字符串表示，主要给开发者看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, age=<span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是对象的非正式字符串表示，主要给用户看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>，<span class="subst">&#123;self.age&#125;</span>岁&quot;</span></span><br><span class="line"></span><br><span class="line">ssw = Student(<span class="string">&quot;BluesSen&quot;</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(tom))  <span class="comment"># Student(name=&#x27;BluesSen&#x27;, age=32)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(tom))   <span class="comment"># ssw，32岁</span></span><br><span class="line"><span class="built_in">print</span>(tom)        <span class="comment"># ssw，32岁</span></span><br></pre></td></tr></table></figure><h3 id="场景3：属性访问控制"><a href="#场景3：属性访问控制" class="headerlink" title="场景3：属性访问控制"></a>场景3：属性访问控制</h3><p>下列这些魔法方法控制对象的访问、设置和删除行为，适合实现动态属性或代理模式。</p><ul><li><code>__getattr__(self, name)</code>：当访问不存在的属性时调用，适合实现灵活的属性延迟加载或代理模式,比如实现一个ORM模型。</li><li><code>__setattr__(self, name, value)</code>：设置属性时调用，但需要注意避免无限递归的问题，实际开发中建议使用 <code>super().__setattr__</code> 来避免递归。</li><li><code>__delattr__(self, name)</code>：删除属性时调用。</li><li><code>__getattribute__(self, name)</code>：无条件访问任何属性时都会调用。极其强大，也极其危险，容易引发无限递归（必须通过<code>super().__getattribute__</code>来访问属性）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.exists = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;只有在找不到已存在的属性时才会调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__getattr__被调用，尝试获取不存在的属性: &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        value = <span class="string">f&quot;这是动态生成的属性 &#x27;<span class="subst">&#123;name&#125;</span>&#x27; 的值&quot;</span></span><br><span class="line">        <span class="built_in">setattr</span>(<span class="variable language_">self</span>, name, value)  <span class="comment"># 将其设置为实例属性，下次就不用走__getattr__了</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 谨慎使用 __getattribute__，容易导致无限递归！</span></span><br><span class="line">    <span class="comment"># def __getattribute__(self, name):</span></span><br><span class="line">    <span class="comment">#    print(f&quot;__getattribute__被调用，获取属性: &#x27;&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    <span class="comment">#    # 必须通过super()来避免递归</span></span><br><span class="line">    <span class="comment">#    return super().__getattribute__(name)</span></span><br><span class="line"></span><br><span class="line">obj = LazyObject()</span><br><span class="line"><span class="built_in">print</span>(obj.exists)    <span class="comment"># 输出：5 (正常访问，不会触发__getattr__)</span></span><br><span class="line"><span class="built_in">print</span>(obj.foo)       <span class="comment"># 输出：__getattr__被调用... -&gt; 这是动态生成的属性 &#x27;foo&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span>(obj.foo)       <span class="comment"># 输出：这是动态生成的属性 &#x27;foo&#x27; 的值 (第二次访问，foo已存在，不再触发__getattr__)</span></span><br></pre></td></tr></table></figure><h3 id="场景4：容器与迭代器"><a href="#场景4：容器与迭代器" class="headerlink" title="场景4：容器与迭代器"></a>场景4：容器与迭代器</h3><p>首先需要明确的什么是容器、可迭代对象、迭代器对象：</p><ul><li><strong>容器</strong>：详见<a href="https://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/">Python中的数据类型用法剖析：从底层实现到高效应用</a></li><li><strong>可迭代对象</strong>：实现 <code>__iter__</code>，返回迭代器对象（通常 <code>return self</code>）</li><li><strong>迭代器对象</strong>：实现 <code>__iter__</code> 和 <code>__next__</code>，返回下一个值，结束时抛出 <code>StopIteration</code>。<br>下列这些魔法方法让类支持容器操作（如<code>in</code>、索引)和迭代。</li><li><code>__len__(self)</code>：定义<code>len(obj)</code>的行为。</li><li><code>__getitem__(self, key)</code>：可以实现自定义对象的下标访问行为，但需要注意的是在实现切片支持时，<code>__getitem__</code>需要处理slice对象。</li><li><code>__setitem__(self, key, value)</code>：可以实现自定义对象的下标赋值行为。</li><li><code>__delitem__(self, key)</code> ：用于实现删除通过键或索引访问的元素的操作。</li><li><code>__iter__(self)</code>、<code>__next__(self)</code> ：使对象可迭代（即支持<code>for</code>循环），这二者可与生成器结合优化内存。</li><li><code>__contains__(self, item)</code> ：定义 <code>in</code> 操作符的行为。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = <span class="built_in">list</span>(items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.items[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>.items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> <span class="variable language_">self</span>.items</span><br><span class="line"></span><br><span class="line">ml = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ml))      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(ml[<span class="number">1</span>])        <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> ml)      <span class="comment"># True</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ml:</span><br><span class="line">    <span class="built_in">print</span>(x)        <span class="comment"># 1, 2, 3</span></span><br></pre></td></tr></table></figure><h3 id="场景5：同步-上下文管理"><a href="#场景5：同步-上下文管理" class="headerlink" title="场景5：同步-上下文管理"></a>场景5：同步-上下文管理</h3><p>下列这些魔法方法让类支持<code>with</code>语句，用于资源管理。</p><ul><li><code>__enter__(self)</code>：进入<code>with</code>时调用，返回上下文对象。</li><li><code>__exit__(self, exc_type, exc_value, traceback)</code>：退出<code>with</code>时调用，处理异常，需要提醒的是，该方法返回<code>True</code>时可抑制异常，也就是说异常会被“吞掉”，上下文管理器外的代码不会收到异常。这是一个强大但危险的特性。很适合事务处理，如果结合<code>contextlib</code>模块可简化上下文管理器的实现。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个计时器上下文管理器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        <span class="variable language_">self</span>.start = time.time()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># as 后面的变量得到的是这个返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        <span class="variable language_">self</span>.elapsed = time.time() - <span class="variable language_">self</span>.start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;代码块运行耗时: <span class="subst">&#123;self.elapsed:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">        <span class="comment"># 返回 False 表示不压制异常；返回 True 则异常会被吞掉，外部不会收到异常。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> Timer() <span class="keyword">as</span> t:</span><br><span class="line">    <span class="comment"># 模拟一些耗时操作</span></span><br><span class="line">    <span class="built_in">sum</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 with 块后会自动打印时间</span></span><br><span class="line"><span class="comment"># 并且我们还可以访问 t.elapsed 这个属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;外部访问耗时: <span class="subst">&#123;t.elapsed&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景6：异步-上下文管理"><a href="#场景6：异步-上下文管理" class="headerlink" title="场景6：异步-上下文管理"></a>场景6：异步-上下文管理</h3><p>下列这些魔法方法必须定义在支持异步的类中。</p><ul><li><code>__await__(self)</code>(可等待对象)：必须返回一个迭代器（通常通过 <code>iter()</code> 包装一个生成器）,可用于实现自定义可等待对象（如 <code>asyncio.Future</code>）。</li><li><code>__alter__(self)</code>(异步迭代器)：返回异步迭代器对象，通常<code>return self</code>。</li><li><code>__anext__</code>：必须返回一个<code>awaitable</code> 对象，（通常是 <code>coroutine</code> 或 <code>Task</code>）。</li><li><code>__aenter__(self)</code>(异步上下文管理器)：返回进入时的资源，常为<code>await self.connect()</code>.</li><li><code>__aexit__(self, exc_type, exc_value, traceback)</code>：用于异步清理（如关闭连接），可处理异常</li><li><code>StopAsyncIteration</code> 是异步迭代结束的信号（不要手动抛出，除非你控制迭代逻辑）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义异步上下文管理器</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncDatabase</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在连接数据库...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库连接成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在断开数据库...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库已断开&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步上下文管理器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.connect()  <span class="comment"># 返回一个协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.disconnect()  <span class="comment"># 返回一个协程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncDatabase() <span class="keyword">as</span> db:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库操作中...&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义异步迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncCounter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, limit</span>):</span><br><span class="line">        <span class="variable language_">self</span>.limit = limit</span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.current</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> num <span class="keyword">in</span> AsyncCounter(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="场景7：可调用对象"><a href="#场景7：可调用对象" class="headerlink" title="场景7：可调用对象"></a>场景7：可调用对象</h3><p>下列魔法方法让普通对象变为可调用对象，可用于实现函数式接口、装饰器类、回调等。</p><ul><li><code>__call__(self, *args, **kwargs)</code> ：让类的实例像函数一样被调用，适合实现装饰器或函数式接口。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个计数器，每次调用都会递增&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使得实例可以像函数一样被调用：obj()&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前计数: <span class="subst">&#123;self.count&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个计数器实例</span></span><br><span class="line">counter = Counter(<span class="number">10</span>)</span><br><span class="line">counter()  <span class="comment"># 输出：当前计数: 11</span></span><br><span class="line">counter()  <span class="comment"># 输出：当前计数: 12</span></span><br><span class="line"><span class="comment"># 它是有状态的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallLogger</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;记录函数调用信息的装饰器类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line">        <span class="variable language_">self</span>.call_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.call_count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始执行第 <span class="subst">&#123;self.call_count&#125;</span> 次调用: <span class="subst">&#123;self.func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        result = <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;self.func.__name__&#125;</span> 执行完毕&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallLogger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 开始执行第 1 次调用: say_hello</span></span><br><span class="line"><span class="comment"># Hello, Alice!</span></span><br><span class="line"><span class="comment"># 函数 say_hello 执行完毕</span></span><br></pre></td></tr></table></figure><h3 id="场景8：描述符协议"><a href="#场景8：描述符协议" class="headerlink" title="场景8：描述符协议"></a>场景8：描述符协议</h3><p>下列这些魔法方法，用于创建描述符类，控制属性的访问，本质是属性代理。简单地说，它允许一个对象在作为另一个对象的属性时，自定义其获取、设置、删除行为。常被用于<strong>属性验证</strong>、<strong>懒加载</strong>、<strong>ORM 字段</strong>等场景。</p><ul><li><code>__get__(self, instance, owner)</code>：获取属性值。</li><li><code>__set__(self, instance, value)</code>：设置属性值。</li><li><code>__delete__(self, instance)</code> ：输出属性。</li><li><code>__set_name__(self, owner, name)</code>：在类创建时设置描述符名称（Python3.6+）<br><strong>值得一提</strong>：它们是 <code>@property</code>、<code>@classmethod</code>等装饰器的底层实现。在Django中被广泛使用。<br><strong>需要注意</strong>：描述符是实现了<code>__get__</code>、<code>__set__</code>或<code>__delete__</code>中至少一个方法的类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveNumber</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个描述符，确保数值是正数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="comment"># instance 是使用描述符的类的实例（如Rectangle的实例）</span></span><br><span class="line">        <span class="comment"># owner 是使用描述符的类本身（如Rectangle类）</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__.get(<span class="variable language_">self</span>.name, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;值必须是正数&quot;</span>)</span><br><span class="line">        <span class="comment"># 将值存储在实例的 __dict__ 中，而不是描述符实例自身</span></span><br><span class="line">        instance.__dict__[<span class="variable language_">self</span>.name] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    width = PositiveNumber(<span class="string">&#x27;width&#x27;</span>)  <span class="comment"># 描述符实例</span></span><br><span class="line">    height = PositiveNumber(<span class="string">&#x27;height&#x27;</span>) <span class="comment"># 描述符实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w  <span class="comment"># 触发 PositiveNumber.__set__</span></span><br><span class="line">        <span class="variable language_">self</span>.height = h <span class="comment"># 触发 PositiveNumber.__set__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height <span class="comment"># 触发 PositiveNumber.__get__</span></span><br><span class="line"></span><br><span class="line">r = Rectangle(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(r.area) <span class="comment"># 输出：15</span></span><br><span class="line">r.width = <span class="number">10</span>  <span class="comment"># 正常设置</span></span><br><span class="line"><span class="built_in">print</span>(r.area) <span class="comment"># 输出：30</span></span><br><span class="line"><span class="comment"># r.width = -5 # 会抛出 ValueError: 值必须是正数</span></span><br></pre></td></tr></table></figure><p><strong>上述代码分析</strong>：</p><ul><li>描述符<code>PositiveNumber</code>的实例作为类属性（<code>width</code>, <code>height</code>）被赋值给<code>Rectangle</code>类。</li><li>当对实例<code>r</code>的属性（如<code>r.width</code>）进行访问或赋值时，实际上被拦截，转而调用描述符的<code>__get__</code>或<code>__set__</code>方法。</li><li><code>@property</code>本质上就是一个实现了<code>__get__</code>和<code>__set__</code>的描述符。<br>总结：描述符是实现精细属性管理、ORM框架映射关系等高级功能的利器。</li></ul><h3 id="场景9：运算符重载"><a href="#场景9：运算符重载" class="headerlink" title="场景9：运算符重载"></a>场景9：运算符重载</h3><p>下列这些魔法方法允许自定义类支持Python的运算符（如：<code>+</code>、<code>-</code>、<code>&lt;</code>等）。<br>(一) 实现算术运算符：</p><ul><li><code>__add__(self, other)</code>：实现加法运算符 <code>+</code>。</li><li><code>__sub__(self, other)</code>：实现减法运算符 <code>-</code>。</li><li><code>__mul__(self, other)</code>：实现乘法运算符 <code>*</code>。</li><li><code>__truediv__(self, other)</code>：实现真除法运算符 <code>/</code>。</li><li><code>__floordiv__(self, other)</code>：实现整数除法运算符 <code>//</code>。</li><li><code>__mod__(self, other)</code>：实现取模运算符 <code>%</code>。</li><li><code>__pow__(self, other[, modulo])</code>：实现幂运算符 <code>**</code>。</li><li><code>__iadd__(self, other)</code>：实现复合运算符 <code>+=</code></li><li><code>__isub__(self, other)</code>：实现复合运算符 <code>-=</code></li><li><code>__imul__(self, other)</code> ：实现复合运算符 <code>*=</code><br>（二）实现位运算符（不常用）</li><li><code>__lshift__(self, other)</code>：实现左移位运算符 <code>&lt;&lt;</code>。</li><li><code>__rshift__(self, other)</code>：实现右移位运算符 <code>&gt;&gt;</code>。</li><li><code>__and__(self, other)</code>：实现按位与运算符 <code>&amp;</code>。</li><li><code>__xor__(self, other)</code>：实现按位异或运算符 <code>^</code>。</li><li><code>__or__(self, other)</code>：实现按位或运算符 <code>|</code>。<br>（三）实现比较运算符：</li><li><code>__lt__(self, other)</code>：实现小于运算符 <code>&lt;</code>。</li><li><code>__le__(self, other)</code>：实现小于等于运算符 <code>&lt;=</code>。</li><li><code>__eq__(self, other)</code>：实现等于运算符 <code>==</code>。</li><li><code>__ne__(self, other)</code>：实现不等于运算符 <code>!=</code>。</li><li><code>__gt__(self, other)</code>：实现大于运算符 <code>&gt;</code>。 </li><li><code>__ge__(self, other)</code>：实现大于等于运算符 <code>&gt;=</code>。<br>**友情提醒：**实现比较运算符时，建议使用 <code>functools.total_ordering</code> 装饰器，只需定义 <code>__eq__</code> 和 <code>__lt__</code> 即可自动生成其他比较方法。</li></ul><p>（四）实现容器类型类似方法（如序列、映射等）：</p><blockquote><p>这些方法允许对象像列表或字典一样被操作。</p></blockquote><ul><li><code>__getitem__(self, key)</code>：实现通过键或索引获取元素，如 <code>self[key]</code>。</li><li><code>__setitem__(self, key, value)</code>：实现通过键或索引设置元素，如 <code>self[key] = value</code>。</li><li><code>__delitem__(self, key)</code>：实现通过键或索引删除元素，如 <code>del self[key]</code>。</li><li><code>__contains__(self, item)</code>：实现成员测试运算符 <code>in</code>。</li><li><code>__len__(self)</code>：实现内置函数 <code>len()</code>，返回容器的长度。<br>由于方法太多，这里就简单的实现一个计算器功能吧</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让对象参与数学运算，支持向量的加减法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 v1 + v2 或 v1 + number&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Vector):</span><br><span class="line">            <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">            <span class="comment"># 标量加法，x和y都加</span></span><br><span class="line">            <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other, <span class="variable language_">self</span>.y + other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span>  <span class="comment"># 告诉Python此操作不支持，让Python尝试 other.__radd__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 number + v1（当数字在左边时调用）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 向量加法满足交换律，所以直接调用 __add__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__add__(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 v1 += v2 或 v1 += number（就地修改）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Vector):</span><br><span class="line">            <span class="variable language_">self</span>.x += other.x</span><br><span class="line">            <span class="variable language_">self</span>.y += other.y</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">            <span class="variable language_">self</span>.x += other</span><br><span class="line">            <span class="variable language_">self</span>.y += other</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># 就地运算必须返回self</span></span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v2 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(v1 + v2)      <span class="comment"># 输出：Vector(4, 6) (调用 __add__)</span></span><br><span class="line"><span class="built_in">print</span>(v1 + <span class="number">5</span>)       <span class="comment"># 输出：Vector(6, 7) (调用 __add__)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> + v1)       <span class="comment"># 输出：Vector(6, 7) (先尝试 int.__add__(5, v1) 失败，然后调用 v1.__radd__(5))</span></span><br><span class="line">v1 += v2</span><br><span class="line"><span class="built_in">print</span>(v1)           <span class="comment"># 输出：Vector(4, 6) (调用 __iadd__，就地修改)</span></span><br></pre></td></tr></table></figure><h3 id="场景10：一些不常见但很有用的方法"><a href="#场景10：一些不常见但很有用的方法" class="headerlink" title="场景10：一些不常见但很有用的方法"></a>场景10：一些不常见但很有用的方法</h3><ul><li><code>__slots__</code> ：限制类可添加的属性，优化内存和性能。</li><li><code>__class__</code>  ：获取或修改对象的类，动态性极强。</li><li><code>__copy__(self)</code>：<code>copy.copy(obj)</code>，浅拷贝</li><li><code>__deepcopy__(self, memo)</code>：<code>copy.deepcopy(obj)</code>，深拷贝</li><li><code>__getstate__(self)</code>：<code>pickle</code> 序列化时获取对象状态</li><li><code>_setstate__(self, state)</code>：<code>pickle</code> 反序列化时恢复状态</li><li><code>__dir__(self)</code>：<code>dir(obj)</code>，自定义属性列表</li><li><code>__sizeof__(self)</code>：<code>sys.getsizeof(obj)</code>，返回对象内存大小，</li><li><code>__hash__(self)</code>：<code>hash(obj)</code>，用于哈希表（如字典键），</li><li><code>__instancecheck__(self, instance)</code>、<code>__subclasscheck__(self, subclass)</code> ：自定义 <code>isinstance</code> 和 <code>issubclass</code> 行为，通常在元类中使用。</li></ul><h2 id="一些开箱即用的实践案例"><a href="#一些开箱即用的实践案例" class="headerlink" title="一些开箱即用的实践案例"></a>一些开箱即用的实践案例</h2><h3 id="案例1：实现一个像列表和字典一样的类"><a href="#案例1：实现一个像列表和字典一样的类" class="headerlink" title="案例1：实现一个像列表和字典一样的类"></a>案例1：实现一个像列表和字典一样的类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Playlist</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的播放列表类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *songs</span>):</span><br><span class="line">        <span class="variable language_">self</span>._songs = <span class="built_in">list</span>(songs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 len(obj)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._songs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 obj[index]，还支持切片！&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 直接返回内部列表的对应项，巧妙利用列表的切片功能</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._songs[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, song</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 item in obj&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> song <span class="keyword">in</span> <span class="variable language_">self</span>._songs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现迭代，支持 for 循环&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>._songs)</span><br><span class="line"></span><br><span class="line">my_playlist = Playlist(<span class="string">&quot;Song A&quot;</span>, <span class="string">&quot;Song B&quot;</span>, <span class="string">&quot;Song C&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_playlist))        <span class="comment"># 输出：3 (调用 __len__)</span></span><br><span class="line"><span class="built_in">print</span>(my_playlist[<span class="number">1</span>])          <span class="comment"># 输出：Song B (调用 __getitem__)</span></span><br><span class="line"><span class="built_in">print</span>(my_playlist[<span class="number">0</span>:<span class="number">2</span>])        <span class="comment"># 输出：[&#x27;Song A&#x27;, &#x27;Song B&#x27;] (切片也有效！)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Song B&quot;</span> <span class="keyword">in</span> my_playlist) <span class="comment"># 输出：True (调用 __contains__)</span></span><br><span class="line"><span class="keyword">for</span> song <span class="keyword">in</span> my_playlist:       <span class="comment"># 调用 __iter__</span></span><br><span class="line">    <span class="built_in">print</span>(song)                <span class="comment"># 依次输出 Song A, Song B, Song C</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例2：实现一个支持对象支持比较类"><a href="#案例2：实现一个支持对象支持比较类" class="headerlink" title="案例2：实现一个支持对象支持比较类"></a>案例2：实现一个支持对象支持比较类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, age=<span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义相等性：姓名和年龄都相同就认为是同一个学生&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name == other.name <span class="keyword">and</span> <span class="variable language_">self</span>.age == other.age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果两个对象相等，它们的hash值必须相同&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age))</span><br><span class="line"></span><br><span class="line">tom1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line">tom2 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(tom1 == tom2)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以把学生对象放进set或用作dict的key了</span></span><br><span class="line">students = &#123;tom1, tom2&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(students))  <span class="comment"># 1，因为两个Tom被认为是同一个</span></span><br></pre></td></tr></table></figure><h3 id="案-3：实现一个缓存器"><a href="#案-3：实现一个缓存器" class="headerlink" title="案:3：实现一个缓存器"></a>案:3：实现一个缓存器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;LRU缓存实现&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, maxsize=<span class="number">128</span>, ttl=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.maxsize = maxsize</span><br><span class="line">        <span class="variable language_">self</span>.ttl = ttl</span><br><span class="line">        <span class="variable language_">self</span>.cache = OrderedDict()</span><br><span class="line">        <span class="variable language_">self</span>.times = &#123;&#125; <span class="keyword">if</span> ttl <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            key = <span class="variable language_">self</span>._make_key(args, kwargs)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查缓存</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.cache:</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_valid(key):</span><br><span class="line">                    <span class="comment"># 移到末尾（最近使用）</span></span><br><span class="line">                    <span class="variable language_">self</span>.cache.move_to_end(key)</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">self</span>.cache[key]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 过期，删除</span></span><br><span class="line">                    <span class="variable language_">self</span>._delete_key(key)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算结果</span></span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 存储结果</span></span><br><span class="line">            <span class="variable language_">self</span>._store_result(key, result)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        wrapper.cache_info = <span class="variable language_">self</span>.cache_info</span><br><span class="line">        wrapper.cache_clear = <span class="variable language_">self</span>.cache_clear</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_key</span>(<span class="params">self, args, kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建缓存键&quot;&quot;&quot;</span></span><br><span class="line">        key = args</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            key += <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(kwargs.items()))</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_valid</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查缓存是否有效&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.ttl <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> time.time() - <span class="variable language_">self</span>.times[key] &lt; <span class="variable language_">self</span>.ttl</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_delete_key</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除缓存项&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.cache[key]</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.times[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_store_result</span>(<span class="params">self, key, result</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储缓存结果&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 检查容量</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cache) &gt;= <span class="variable language_">self</span>.maxsize:</span><br><span class="line">            <span class="comment"># 删除最老的项</span></span><br><span class="line">            oldest_key = <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.cache))</span><br><span class="line">            <span class="variable language_">self</span>._delete_key(oldest_key)</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.cache[key] = result</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="variable language_">self</span>.times[key] = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cache_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;缓存信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Cache size: <span class="subst">&#123;<span class="built_in">len</span>(self.cache)&#125;</span>/<span class="subst">&#123;self.maxsize&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cache_clear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;清空缓存&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.cache.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="variable language_">self</span>.times.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="meta">@LRUCache(<span class="params">maxsize=<span class="number">100</span>, ttl=<span class="number">300</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expensive_function</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x * y + x ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="案例4：实现一个配置管理器"><a href="#案例4：实现一个配置管理器" class="headerlink" title="案例4：实现一个配置管理器"></a>案例4：实现一个配置管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;支持点号访问和字典访问的配置管理器&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="variable language_">self</span>[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;字典式访问：config[&#x27;database_url&#x27;]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;字典式赋值：config[&#x27;database_url&#x27;] = &#x27;sqlite:///app.db&#x27;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除配置项：del config[&#x27;database_url&#x27;]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>._data[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查是否存在：&#x27;database_url&#x27; in config&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> <span class="variable language_">self</span>._data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;配置项数量：len(config)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代配置项：for key in config&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>._data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;点号访问：config.database_url&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._data[name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">f&quot;配置项 &#x27;<span class="subst">&#123;name&#125;</span>&#x27; 不存在&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;点号赋值：config.database_url = &#x27;sqlite:///app.db&#x27;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">            <span class="comment"># 私有属性正常处理</span></span><br><span class="line">            <span class="built_in">super</span>().__setattr__(name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 公共属性存储到配置中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(<span class="variable language_">self</span>, <span class="string">&#x27;_data&#x27;</span>):</span><br><span class="line">                <span class="built_in">super</span>().__setattr__(<span class="string">&#x27;_data&#x27;</span>, &#123;&#125;)</span><br><span class="line">            <span class="variable language_">self</span>._data[name] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        items = [<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;v!r&#125;</span>&quot;</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="variable language_">self</span>._data.items()]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Config(<span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(items)&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.keys()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">values</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.values()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">items</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.items()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.get(key, default)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="variable language_">self</span>[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">config = Config(</span><br><span class="line">    database_url=<span class="string">&quot;sqlite:///app.db&quot;</span>,</span><br><span class="line">    debug=<span class="literal">True</span>,</span><br><span class="line">    max_connections=<span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多种访问方式</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;database_url&#x27;</span>])    <span class="comment"># sqlite:///app.db</span></span><br><span class="line"><span class="built_in">print</span>(config.database_url)       <span class="comment"># sqlite:///app.db</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;debug&#x27;</span> <span class="keyword">in</span> config)         <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态添加配置</span></span><br><span class="line">config.secret_key = <span class="string">&quot;my-secret-key&quot;</span></span><br><span class="line">config[<span class="string">&#x27;cache_timeout&#x27;</span>] = <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代配置</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;config[key]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;共有 <span class="subst">&#123;<span class="built_in">len</span>(config)&#125;</span> 个配置项&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="案例5：实现一个单例类"><a href="#案例5：实现一个单例类" class="headerlink" title="案例5：实现一个单例类"></a>案例5：实现一个单例类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单例模式元类&quot;&quot;&quot;</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    _lock = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建新类时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;创建类 <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">        cls = <span class="built_in">super</span>().__new__(mcs, name, bases, namespace)</span><br><span class="line">        <span class="comment"># 为每个类创建一个锁</span></span><br><span class="line">        mcs._lock[cls] = <span class="built_in">__import__</span>(<span class="string">&#x27;threading&#x27;</span>).Lock()</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建实例时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            <span class="keyword">with</span> cls._lock[cls]:</span><br><span class="line">                <span class="comment"># 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;创建 <span class="subst">&#123;cls.__name__&#125;</span> 的第一个实例&quot;</span>)</span><br><span class="line">                    instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">                    cls._instances[cls] = instance</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;返回 <span class="subst">&#123;cls.__name__&#125;</span> 的现有实例&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;返回 <span class="subst">&#123;cls.__name__&#125;</span> 的现有实例&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数据库连接类（单例）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">5432</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(<span class="variable language_">self</span>, <span class="string">&#x27;_initialized&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.host = host</span><br><span class="line">        <span class="variable language_">self</span>.port = port</span><br><span class="line">        <span class="variable language_">self</span>.connected = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>._initialized = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;初始化数据库连接: <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.connected:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;连接到数据库 <span class="subst">&#123;self.host&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.connected = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已经连接到数据库&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, sql</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.connected:</span><br><span class="line">            <span class="variable language_">self</span>.connect()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;执行查询: <span class="subst">&#123;sql&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;查询结果 for &#x27;<span class="subst">&#123;sql&#125;</span>&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试单例</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=== 创建数据库连接实例 ===&quot;</span>)</span><br><span class="line">db1 = DatabaseConnection(<span class="string">&quot;192.168.1.100&quot;</span>)</span><br><span class="line">db2 = DatabaseConnection(<span class="string">&quot;localhost&quot;</span>)  <span class="comment"># 参数被忽略</span></span><br><span class="line">db3 = DatabaseConnection()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;db1 is db2: <span class="subst">&#123;db1 <span class="keyword">is</span> db2&#125;</span>&quot;</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;db1.host: <span class="subst">&#123;db1.host&#125;</span>&quot;</span>)      <span class="comment"># 192.168.1.100</span></span><br><span class="line"></span><br><span class="line">db1.connect()</span><br><span class="line">db2.query(<span class="string">&quot;SELECT * FROM users&quot;</span>)    <span class="comment"># 使用同一个连接</span></span><br></pre></td></tr></table></figure><h2 id="一些好的实践与建议"><a href="#一些好的实践与建议" class="headerlink" title="一些好的实践与建议"></a>一些好的实践与建议</h2><ul><li><strong>开发调试阶段</strong>：<ul><li><code>__repr__</code> 比 <code>__str__</code> 更重要，调试时非常有用。</li></ul></li><li><strong>建议使用</strong>：<ul><li>实现 <code>__eq__</code> 时，通常也要实现 <code>__hash__</code>（除非对象是可变的）。</li><li>使用 <code>@total_ordering</code> 装饰器可以减少比较方法的编写量（只需实现 <code>__eq__</code> 和一个如 <code>__lt__</code>）。</li><li>在设计类时最好做到总是检查参数类型，使用<code>NotImplemented</code>而不是抛出异常。</li><li>在设计类时考虑使用<code>@dataclass</code>或<code>@attrs</code>来减少样板代码</li><li>魔法方法调用有开销,在性能敏感的循环中，直接调用方法可能比操作符更快。</li></ul></li><li>谨慎使用：<ul><li>在<code>__getattribute__</code>、<code>__setattr__</code>中直接使用<code>self.attr</code>会导致无限递归。必须使用<code>super()</code>或直接操作<code>__dict__</code>。</li></ul></li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><table><thead><tr><th>类别</th><th>主要方法</th><th>应用场景</th></tr></thead><tbody><tr><td>对象生命周期</td><td><code>__new__</code>, <code>__init__</code>, <code>__del__</code></td><td>对象创建、初始化、销毁</td></tr><tr><td>对象表示与格式化</td><td><code>__str__</code>, <code>__repr__</code>, <code>__format__</code></td><td>字符串表示、调试输出</td></tr><tr><td>运算符重载</td><td><code>__add__</code>, <code>__eq__</code>, <code>__lt__</code>等</td><td>数学运算、比较操作</td></tr><tr><td>属性访问控制</td><td><code>__getattr__</code>, <code>__setattr__</code>, <code>__getattribute__</code></td><td>动态属性、代理模式</td></tr><tr><td>容器与迭代器</td><td><code>__len__</code>, <code>__getitem__</code>, <code>__iter__</code></td><td>序列、映射、迭代</td></tr><tr><td>上下文管理</td><td><code>__enter__</code>, <code>__exit__</code></td><td>资源管理、with语句</td></tr><tr><td>可调用对象</td><td><code>__call__</code></td><td>函数式接口、装饰器类</td></tr><tr><td>描述符协议</td><td><code>__get__</code>, <code>__set__</code>, <code>__delete__</code></td><td>属性验证、ORM字段</td></tr><tr><td>异步编程</td><td><code>__aenter__</code>, <code>__aexit__</code>, <code>__anext__</code></td><td>异步上下文、迭代</td></tr></tbody></table><p>Python的魔法方法不是“黑魔法”，而是一套精心设计的、用于扩展语言能力的协议系统。作为Python开发者，深入理解并恰当地运用它们，能够让我们设计出API更清晰、更符合Python风格、更强大的代码库。</p><p>然而，常言道：能力越大，责任越大……</p><p>魔法方法虽然功能强大，但滥用魔法方法会让代码变得难以理解和调试。我们应该始终遵循“明确胜于隐晦”的Python之禅，只在真正需要让对象模拟内置行为或实现特定协议时才使用它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python的魔法方法是Python面向对象编程的精髓，理解魔法方法不仅能让开发者写出更优雅的代码，更重要的是能让你深入理解Python对象模型的工作原理。那么今天我们就来系统性的梳理一下Python魔法方法的基础知识、常用魔法方法与分类，以及应用场景实践。&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="Python核心知识" scheme="http://sswfive.xyz/tags/Python%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>遇见Stellar：我的博客站点的又一次翻新之旅</title>
    <link href="http://sswfive.xyz/2025/09/22/tools/250922-blog-theme-migrate/"/>
    <id>http://sswfive.xyz/2025/09/22/tools/250922-blog-theme-migrate/</id>
    <published>2025-09-22T15:08:33.000Z</published>
    <updated>2025-10-17T03:27:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，无意中看到一个博客主题：<a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a> ，第一眼就被它优雅的设计所吸引。随后我仔细阅读了它的使用文档和一些实际案例，越发觉得它强大而富有美感，尤其触动我的是文档中的一句话：</p><blockquote><p>真正的简约远不止删繁就简，而是在纷繁中建立秩序</p></blockquote><p>这句话彻底动摇了我之前一直追求的极简主义理念，之前我使用的是<a href="https://github.com/HiNinoJay/hexo-theme-A4">hexo-theme-A4</a>，它确实非常简洁，但在功能和内容组织上略显单一。而 Stellar 不仅外观现代，还内置了丰富的模块和组件，支持博客、知识库、专栏、笔记等多种内容形式，真正做到了“简约而不简单”。<br>于是我决定动手试一试。按照官方文档，我把感兴趣的配置都体验了一遍后，经过几个小时冷静思考，决定当晚就把博客迁移到Stellar，并借此机会好好梳理一下自己的建站历程——毕竟之前尝试过不少博客平台和主题，却一直没有系统的记录，有些细节已经模糊甚至遗忘了。</p><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><ul><li>内容排版：<a href="https://markdown.com.cn/">Markdown语法介绍</a>，<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></li><li>站点框架：<a href="https://hexo.io/zh-cn/docs/">Hexo</a></li><li>站点主题：<a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a></li><li>主题配置文档：<a href="https://xaoxuu.com/wiki/stellar/#start">Stellar开启您全新的博客之旅</a></li></ul><h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><p>Stellar 是一个极为强大的综合型 Hexo 主题，包含博客系统、知识库系统、专栏系统、笔记系统，内置海量的标签和动态数据组件。</p><h2 id="迁移流程"><a href="#迁移流程" class="headerlink" title="迁移流程"></a>迁移流程</h2><p>由于迁移前后站点的框架都是hexo,这个我的迁移工作降低了不少难度和时间。</p><p>主要迁移流程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化新站点</span></span><br><span class="line">hexo init blogsite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装Stellar主题</span></span><br><span class="line">npm i hexo-theme-stellar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在_config.yml中，修改配置</span></span><br><span class="line">theme: stellar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.创建主题配置文件（在根目录新建 `_config.stellar.yml`，所有主题相关配置在此编辑。）</span></span><br><span class="line"><span class="built_in">touch</span> _config.stellar.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，将原博客<code>source</code>目录下的所有内容全部拷贝到新站点对应目录中，基本实现无缝切换（主要还是因为我使文档中使用的语法都是通用语法，基本没有使用主题定制语法）。</p><h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><p>我采用Github + CI 的自动化发布方式：</p><ul><li>私有仓库 blogsite：存放 Hexo 源码，并设置 GitHub Actions 工作流</li><li>公开仓库 sswfive.github.io：存放生成的静态页面，用于 GitHub Pages 展示<br>撰写新文章后，推送至私有仓库触发 CI 流程（如 GitHub Actions），自动构建并发布到公开仓库，即可通过 <a href="https://sswfive.github.io/">https://sswfive.github.io</a> 访问。</li></ul><h3 id="核心配置步骤"><a href="#核心配置步骤" class="headerlink" title="核心配置步骤"></a>核心配置步骤</h3><ol><li>生成部署密钥对</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span> -f github-actions-deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将生成的 <code>github-actions-deploy.pub</code> 内容添加到公开仓库的 <strong>Deploy Keys</strong>（勾选允许写入）</li><li>将 <code>github-actions-deploy</code> 私钥内容添加到私有仓库的 <strong>Secrets</strong>，命名为 <code>DEPLOY_PRIVATE_KEY</code></li></ul><ol start="2"><li>创建 GitHub Actions 工作流文件</li></ol><ul><li>在私有仓库创建 <code>.github/workflows/deploy.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">1</span><span class="string">.</span> <span class="string">checkout</span> <span class="string">分支</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">2</span><span class="string">.</span> <span class="string">Node</span> <span class="string">环境安装</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;20&#x27;</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">3</span><span class="string">.</span> <span class="string">安装依赖和主题</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm ci --no-audit --no-fund</span></span><br><span class="line"><span class="string">        npm i hexo-theme-stellar</span></span><br><span class="line"><span class="string">        echo &quot;✅ 依赖安装完成&quot;</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="number">4</span><span class="string">.</span> <span class="string">恢复文章修改时间</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">git</span> <span class="string">ls-files</span> <span class="string">&#x27;source/_posts/**/*.md&#x27;</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">IFS=</span> <span class="string">read</span> <span class="string">-r</span> <span class="string">-d</span> <span class="string">&#x27;&#x27;</span> <span class="string">file;</span> <span class="string">do</span> <span class="string">ts=$(git</span> <span class="string">log</span> <span class="number">-1</span> <span class="string">--format=%ct</span> <span class="string">--</span> <span class="string">&quot;$file&quot;</span> <span class="string">||</span> <span class="literal">true</span><span class="string">)</span> <span class="string">if</span> [ <span class="string">-n</span> <span class="string">&quot;$ts&quot;</span> ]<span class="string">;</span> <span class="string">then</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">&quot;@$ts&quot;</span> <span class="string">&quot;$file&quot;</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line">    <span class="string">done</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span>  <span class="comment"># 或 hexo generate</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">external_repository:</span> <span class="string">sswfive/sswfive.github.io</span>  <span class="comment"># 你的公开仓库</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">main</span>  <span class="comment"># 公开仓库的分支</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span>  <span class="comment"># Hexo 生成目录</span></span><br><span class="line">        <span class="attr">commit_message:</span> <span class="string">&#x27;🚀 Deploy from private blogsite repo&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="主要插件与配置"><a href="#主要插件与配置" class="headerlink" title="主要插件与配置"></a>主要插件与配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近，无意中看到一个博客主题：&lt;a href=&quot;https://github.com/xaoxuu/hexo-theme-stellar&quot;&gt;hexo-theme-stellar&lt;/a&gt; ，第一眼就被它优雅的设计所吸引。随后我仔细阅读了它的使用文档和一些实际案例，越发觉得它强</summary>
      
    
    
    
    <category term="博客建站" scheme="http://sswfive.xyz/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="博客建站" scheme="http://sswfive.xyz/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>我在Mac上使用的字体搭配方案</title>
    <link href="http://sswfive.xyz/2025/09/22/tools/250922-mac-font-install/"/>
    <id>http://sswfive.xyz/2025/09/22/tools/250922-mac-font-install/</id>
    <published>2025-09-22T14:38:30.000Z</published>
    <updated>2025-10-09T16:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字体选择"><a href="#一、字体选择" class="headerlink" title="一、字体选择"></a>一、字体选择</h2><h3 id="JetBrains-Mono"><a href="#JetBrains-Mono" class="headerlink" title="JetBrains Mono"></a>JetBrains Mono</h3><ul><li>来源：JetBrains官方出品，专为开发者设计</li><li>优点：对编程连字符支持好，字符形态清晰，能有效减少视觉疲劳。</li></ul><h3 id="霞鹜文楷屏幕阅读版"><a href="#霞鹜文楷屏幕阅读版" class="headerlink" title="霞鹜文楷屏幕阅读版"></a>霞鹜文楷屏幕阅读版</h3><ul><li>来源：基于开源字体「文楷」优化，专为屏幕显示打造。</li><li>优点：中文显示清晰锐利，字形现代，阅读体验舒适，并提供等宽版本，完美适配代码编辑器。</li></ul><p>在 GitHub releases页面上，可以根据下面字体特点和需求进行选择：</p><table><thead><tr><th>文件名</th><th>特点</th><th>推荐给</th></tr></thead><tbody><tr><td><strong><code>LXGWWenKaiGBScreen.ttf</code></strong></td><td><strong>大陆标准</strong>，非等宽</td><td>主要进行文档阅读的大陆用户</td></tr><tr><td><strong><code>LXGWWenKaiMonoGBScreen.ttf</code></strong></td><td><strong>大陆标准</strong> + <strong>等宽</strong></td><td><strong>中国大陆的程序员（强烈推荐）</strong></td></tr><tr><td><code>LXGWWenKaiScreen.ttf</code></td><td>通用版，非等宽</td><td>普通用户</td></tr><tr><td><code>LXGWWenKaiMonoScreen.ttf</code></td><td>通用版 + 等宽</td><td>需要等宽字体的用户</td></tr></tbody></table><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><h3 id="方法1：手动安装"><a href="#方法1：手动安装" class="headerlink" title="方法1：手动安装"></a>方法1：手动安装</h3><ul><li>下载字体：<ul><li>JetBrains Mono：访问 <a href="https://www.jetbrains.com/lp/mono/">官网</a> 下载</li><li>霞鹜文楷屏幕阅读版：访问<a href="https://github.com/lxgw/LxgwWenKai-Screen/releases"> GitHub Releases 页面</a>，从 Assets 区选择所需文件</li></ul></li><li>安装：<ul><li>双击下载的 .ttf 文件，用「字体册」应用打开并点击“安装字体”。</li></ul></li></ul><h3 id="方法-2：使用-Homebrew"><a href="#方法-2：使用-Homebrew" class="headerlink" title="方法 2：使用 Homebrew"></a>方法 2：使用 Homebrew</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JetBrains Mono</span></span><br><span class="line">brew install --cask font-jetbrains-mono</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霞鹜文楷目前还是建议使用手动安装</span></span><br></pre></td></tr></table></figure><h2 id="三、在-VS-Code-中启用字体"><a href="#三、在-VS-Code-中启用字体" class="headerlink" title="三、在 VS Code 中启用字体"></a>三、在 VS Code 中启用字体</h2><p>安装后，需在编辑器中设置才能生效。以 VS Code 为例：</p><ol><li>打开设置 (Cmd + ,)。</li><li>搜索 font family。</li><li>在设置中添加你的字体，确保将中文字体放在首位：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;LXGW WenKai Mono GB Screen&#x27;, &#x27;JetBrains Mono&#x27;, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span></span><br></pre></td></tr></table></figure><p>配置逻辑：系统会优先使用「霞鹜文楷」渲染所有字符（包括英文），fallback 到「JetBrains Mono」确保特殊符号正常显示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、字体选择&quot;&gt;&lt;a href=&quot;#一、字体选择&quot; class=&quot;headerlink&quot; title=&quot;一、字体选择&quot;&gt;&lt;/a&gt;一、字体选择&lt;/h2&gt;&lt;h3 id=&quot;JetBrains-Mono&quot;&gt;&lt;a href=&quot;#JetBrains-Mono&quot; class=&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://sswfive.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Mac" scheme="http://sswfive.xyz/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>算法之【递归】</title>
    <link href="http://sswfive.xyz/2025/09/20/dsa/algo_recursion/"/>
    <id>http://sswfive.xyz/2025/09/20/dsa/algo_recursion/</id>
    <published>2025-09-20T15:29:16.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归（Recursion）概述"><a href="#递归（Recursion）概述" class="headerlink" title="递归（Recursion）概述"></a>递归（Recursion）概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>递归是一种算法，也是一种编程技巧，应用非常广泛。</li><li>递归求解问题的分解过程：去的过程叫“递”，回来的过程叫“归”</li><li>应用：DFS深度优先搜索、前中后序二叉树遍历</li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：<ul><li>递归代码表达能力强，写起来简洁</li></ul></li><li>缺点：<ul><li>空间复杂度高</li><li>有堆栈溢出的风险</li><li>存在重复计算</li><li>过多的函数调用会耗时较多</li></ul></li></ul><h3 id="递归公式Demo"><a href="#递归公式Demo" class="headerlink" title="递归公式Demo"></a>递归公式Demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n)=f(n-1)+1 其中，f(1)=1</span><br><span class="line"></span><br><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 2;</span><br><span class="line">f(n) = f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><h2 id="什么场景的问题适合用递归解决"><a href="#什么场景的问题适合用递归解决" class="headerlink" title="什么场景的问题适合用递归解决"></a>什么场景的问题适合用递归解决</h2><blockquote><p>需要满足以下三个条件</p></blockquote><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件<ul><li>不能出现无限循环</li></ul></li></ul><h2 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h2><ul><li>核心思想：写出递推公式，找到终止条件，然后将递推公式转化为代码</li><li>方法：<ul><li>找到如何将大问题分解为小问题的规律，并且写出递推公式</li><li>推敲终止条件</li><li>将递归公式和终止条件翻译成代码</li></ul></li><li>注意：<ul><li>只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要视图用人脑去分解递归的每个步骤（重复的步骤交给计算机完成）</li></ul></li></ul><h2 id="递归常见问题"><a href="#递归常见问题" class="headerlink" title="递归常见问题"></a>递归常见问题</h2><ul><li>递归代码要警惕堆栈溢出<ul><li>可以声明一个全局变量来控制递归深度，可以一定程度避免堆栈溢出</li></ul></li><li>递归代码要警惕重复计算<ul><li>通过某种数据结构来保存已经求解过的值，从而避免重复计算</li></ul></li><li>过多的函数调用会耗时较多，空间复杂度高</li></ul><h2 id="递归代码改非递归代码"><a href="#递归代码改非递归代码" class="headerlink" title="递归代码改非递归代码"></a>递归代码改非递归代码</h2><ul><li>递归代码都可以改为迭代循环的非递归写法</li><li>本质上是：将自动递归改为手动递归，本质问题没有解决</li><li>实现：<ol><li>抽象递推公式</li><li>初始值和边界条件</li><li>用迭代循环实现</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归（Recursion）概述&quot;&gt;&lt;a href=&quot;#递归（Recursion）概述&quot; class=&quot;headerlink&quot; title=&quot;递归（Recursion）概述&quot;&gt;&lt;/a&gt;递归（Recursion）概述&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>工具应用：终端的选择从iTerm2到Alacritty</title>
    <link href="http://sswfive.xyz/2025/09/19/tools/250919-terminal-alacritty/"/>
    <id>http://sswfive.xyz/2025/09/19/tools/250919-terminal-alacritty/</id>
    <published>2025-09-19T08:14:20.000Z</published>
    <updated>2025-10-17T03:27:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把用了五年的 <a href="https://github.com/gnachman/iTerm2">iTerm2</a> 换成了 <a href="https://github.com/alacritty/alacritty">Alacritty</a>——一个基于 Rust 编写、使用 OpenGL 加速的跨平台终端，大小仅 6M，号称“全球最快的终端仿真器”。实际体验下来，响应速度确实非常流畅。</p><h2 id="安装-Alacritty"><a href="#安装-Alacritty" class="headerlink" title="安装 Alacritty"></a>安装 Alacritty</h2><p>你可以从 <a href="https://github.com/alacritty/alacritty/releases">GitHub Releases</a> 下载对应平台的安装包，也可以通过 Homebrew 快速安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask alacritty</span><br></pre></td></tr></table></figure><h2 id="替换应用图标"><a href="#替换应用图标" class="headerlink" title="替换应用图标"></a>替换应用图标</h2><p>默认的 Alacritty 图标比较朴素，我选择从 <a href="https://www.freepik.com/search?format=search&iconType=standard&last_filter=query&last_value=terminal&query=terminal&type=icon">Freepik</a> 下载了一个更符合审美的 <code>.icns</code> 图标。替换方法也很简单：</p><ol><li>在「应用程序」中找到 <code>Alacritty.app</code></li><li>按下 <code>Command + i</code> 打开简介窗口</li><li>将下载的 <code>.icns</code> 文件拖到左上角的图标上</li><li>重启 Alacritty，新图标就会生效</li></ol><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><p>我个人偏好沉浸式头部和 JetBrains Mono 字体，以下是配置方法：</p><h3 id="安装-JetBrains-Mono-字体"><a href="#安装-JetBrains-Mono-字体" class="headerlink" title="安装 JetBrains Mono 字体"></a>安装 JetBrains Mono 字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-jetbrains-mono</span><br></pre></td></tr></table></figure><p>也可手动安装：</p><ol><li>访问 <a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono 官网</a>下载字体文件</li><li>解压后双击 <code>.ttf</code> 或 <code>.otf</code> 文件安装</li></ol><p>验证是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-list | grep <span class="string">&quot;JetBrains Mono&quot;</span></span><br></pre></td></tr></table></figure><h3 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h3><blockquote><p>参考一个大佬的配置：<a href="https://gw.alipayobjects.com/os/k/s0/alacritty.yml">点击下载</a></p></blockquote><p>我将常用配置整合在 <code>alacritty.yml</code> 中，执行以下命令一键导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.config/alacritty &amp;&amp; \</span><br><span class="line">curl -fLo ~/.config/alacritty/alacritty.yml \</span><br><span class="line">     https://gw.alipayobjects.com/os/k/j2/alacritty.yml</span><br></pre></td></tr></table></figure><blockquote><p>如果配置与当前版本不兼容，可运行 <code>alacritty migrate</code> 进行迁移。</p></blockquote><h3 id="创建命令行快捷方式"><a href="#创建命令行快捷方式" class="headerlink" title="创建命令行快捷方式"></a>创建命令行快捷方式</h3><p>建议将 Alacritty 链接到 PATH，方便随时调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -sf /Applications/Alacritty.app/Contents/MacOS/alacritty /usr/local/bin/alacritty</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alacritty --version</span><br></pre></td></tr></table></figure><h2 id="常用快捷键配置"><a href="#常用快捷键配置" class="headerlink" title="常用快捷键配置"></a>常用快捷键配置</h2><p>在配置中定制了几个高频快捷键：</p><ul><li><code>Command + r</code>：清屏</li><li><code>Command + w</code>：隐藏窗口（原为退出）</li><li><code>Command + t</code>：新建窗口</li><li><code>Command + Shift + w</code>：关闭当前窗口</li><li><code>Command + Delete</code>：删除整行</li><li><code>Command + f</code>：搜索关键字</li><li><code>Command + ←/→</code>：跳至行首&#x2F;行尾</li></ul><h2 id="搭配-Tmux-使用"><a href="#搭配-Tmux-使用" class="headerlink" title="搭配 Tmux 使用"></a>搭配 Tmux 使用</h2><p>还整合了 Tmux 配置，实现更强大的终端管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Tmux</span></span><br><span class="line">brew install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Tmux 配置</span></span><br><span class="line">curl -fLo ~/.tmux.conf https://gw.alipayobjects.com/os/k/8b/.tmux.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 Alacritty 配置以适配 Tmux</span></span><br><span class="line">curl -fLo ~/.config/alacritty/alacritty.yml https://gw.alipayobjects.com/os/k/l9/alacritty.yml</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tw93.fun/2023-02-06/alacritty.html">https://tw93.fun/2023-02-06/alacritty.html</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近把用了五年的 &lt;a href=&quot;https://github.com/gnachman/iTerm2&quot;&gt;iTerm2&lt;/a&gt; 换成了 &lt;a href=&quot;https://github.com/alacritty/alacritty&quot;&gt;Alacritty&lt;/a&gt;——一个基于</summary>
      
    
    
    
    <category term="ToolBox" scheme="http://sswfive.xyz/categories/ToolBox/"/>
    
    
    <category term="终端" scheme="http://sswfive.xyz/tags/%E7%BB%88%E7%AB%AF/"/>
    
    <category term="Alacritty" scheme="http://sswfive.xyz/tags/Alacritty/"/>
    
  </entry>
  
  <entry>
    <title>算法之【哈希】</title>
    <link href="http://sswfive.xyz/2025/09/18/dsa/algo_hash/"/>
    <id>http://sswfive.xyz/2025/09/18/dsa/algo_hash/</id>
    <published>2025-09-18T13:36:01.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念分析"><a href="#概念分析" class="headerlink" title="概念分析:"></a>概念分析:</h2><p><strong>Hash</strong>：通常翻译为“散列”，或“哈希”；就是把任意长度的二进制数据，通过散列算法，变换成固定长度的输出，即该输出就是散列值。</p><p><strong>哈希冲突（碰撞</strong>）: 指不同的数据，得到了同样的散列值，即为发生冲突（碰撞）。</p><h2 id="Hash中的算法"><a href="#Hash中的算法" class="headerlink" title="Hash中的算法"></a>Hash中的算法</h2><blockquote><p>也称消息摘要算法<br>消息摘要（Message Digest）又称数字摘要（Digital Digest）,该摘要是一个唯一对应一个消息或文本的固定长度的值，，它由一个单向Hash加密函数对消息进行作用而生成，本质就是：散列表或者哈希值。</p></blockquote><h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>SHA（Secure Hash Algorithm）算法称为安全散列算法,能计算出一个数字消息对应到的长度固定的字符串（又称消息摘要）的算法。<br>该算法又细分为：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512这五种算法，其中后四种并称为SHA-2算法。</p><blockquote><p>SHA-1在许多安全协定中广为使用，包括TLS和SSL、PGP、SSH、S&#x2F;MIME和IPsec，曾被视为是MD5的后继者<br>但SHA-1的安全性如今被密码学家严重质疑；虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似</p></blockquote><ul><li>特点：<ul><li>由讯息摘要反推原输入讯息，从计算理论上来说是很困难的。 不可逆</li><li>想要找到两组不同的讯息对应到相同的讯息摘要，从计算理论上来说也是很困难的。</li><li>任何对输入讯息的变动，都有很高的机率导致其产生的讯息摘要迥异。无冲突</li></ul></li></ul><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。</p><ul><li>特点：<ul><li>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>2、容易计算：从原数据计算出MD5值很容易。</li><li>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念分析&quot;&gt;&lt;a href=&quot;#概念分析&quot; class=&quot;headerlink&quot; title=&quot;概念分析:&quot;&gt;&lt;/a&gt;概念分析:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Hash&lt;/strong&gt;：通常翻译为“散列”，或“哈希”；就是把任意长度的二进制数据，通过散列算法，变</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DS&amp;A" scheme="http://sswfive.xyz/tags/DS-A/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【栈】</title>
    <link href="http://sswfive.xyz/2025/09/17/dsa/250917-stack/"/>
    <id>http://sswfive.xyz/2025/09/17/dsa/250917-stack/</id>
    <published>2025-09-17T13:36:01.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导"><a href="#问题向导" class="headerlink" title="问题向导"></a>问题向导</h2><ul><li>问题1：如何实现浏览器的前进和后退功能？<ul><li>问题描述：浏览器的前进、后退功能，我想你肯定很熟悉吧？当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</li></ul></li><li>思路：<ul><li>使用两个栈来实现</li></ul></li><li>实现：<ul><li>使用两个栈，X和Y,把首次浏览的页面依次压入栈X, 当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当点击前进按钮时，依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</li></ul></li></ul><h2 id="栈的概述："><a href="#栈的概述：" class="headerlink" title="栈的概述："></a>栈的概述：</h2><ul><li>定义：<ul><li>后进者先出，先进者后出的数据结构称为“栈”</li></ul></li><li>理解：<ul><li>一摞叠在一起的盘子，放盘子的时候都是从下往上一个一个放，取的时候都是从上往下一个一个的取，不能从中间任意取</li></ul></li><li>操作特性：<ul><li>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据</li></ul></li><li>类别：<ul><li>从功能上，数据或链表都能替代栈，但特定的数据结构是对特定场景的抽象，另一方面，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控，就会容易出错</li></ul></li><li>使用场景：<ul><li>当某个数据集合只涉及到在一端插入和删除数据，并且满足后进先出，先进后出的特性，就可以使用栈</li></ul></li><li>栈的复杂度：<ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(1)</li></ul></li><li>实现：<ul><li>数组实现-&gt;顺序栈</li><li>链表实现-&gt;链式栈</li></ul></li></ul><h3 id="动态扩容的顺序栈实现："><a href="#动态扩容的顺序栈实现：" class="headerlink" title="动态扩容的顺序栈实现："></a>动态扩容的顺序栈实现：</h3><ul><li>实现：<ul><li>只需要底层依赖一个支持动态扩容的数组就可以 了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</li></ul></li><li>复杂度<ul><li>出栈：O(1)<ul><li>不会涉及到内存的重新分配和数据的搬迁</li></ul></li><li>入栈：最坏：O(n), 最好：O(1)</li><li>分析方法：摊还分析法，</li></ul></li></ul><blockquote><p>摊还分析法细节：<br>为了分析的方便，我们需要事先做一些假设和定义：</p><ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li><li>为了简化分析，假设只有入栈操作没有出栈操作；</li><li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。为了让你更加直观地理解这个过程，我画了一张图。<br>你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。<br>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p></blockquote><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><p>入栈push()</p></li><li><p>出栈pop()</p></li></ul><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="一、在函数中的应用"><a href="#一、在函数中的应用" class="headerlink" title="一、在函数中的应用"></a>一、在函数中的应用</h3><blockquote><p>函数调用栈</p></blockquote><ul><li><p>操作系统给每个线程分配了一个独立的内存空间，这块内存被组织成为“栈”这种结构，用来存储函数调用时的临时变量，每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p></li><li><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相 加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作。</p></li></ul><h3 id="二、在表达式求值中的应用"><a href="#二、在表达式求值中的应用" class="headerlink" title="二、在表达式求值中的应用"></a>二、在表达式求值中的应用</h3><ul><li>eg: 34+13*9+44-12&#x2F;3</li><li>实现思路：<ul><li>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</li><li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li></ul></li></ul><h3 id="三、在括号匹配中的应用"><a href="#三、在括号匹配中的应用" class="headerlink" title="三、在括号匹配中的应用"></a>三、在括号匹配中的应用</h3><blockquote><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，<code>&#123;[] ()[&#123;&#125;]&#125;或[&#123;()&#125;([])]</code>等都为合法格式，而<code>&#123;[&#125;()]</code>或<code>[(&#123;)]</code>为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p></blockquote><ul><li>使用栈来检查表达式中的括号是否匹配：<code>&#123;[] ()[&#123;&#125;]&#125;或[&#123;()&#125;([])]</code></li><li>实现思路<ul><li>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如<code>“(”跟“)”</code>匹配，<code>“[”跟“]”匹配，“&#123;”跟“&#125;”</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，</li><li>如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导&quot;&gt;&lt;a href=&quot;#问题向导&quot; class=&quot;headerlink&quot; title=&quot;问题向导&quot;&gt;&lt;/a&gt;问题向导&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：如何实现浏览器的前进和后退功能？&lt;ul&gt;
&lt;li&gt;问题描述：浏览器的前进、后退功能，我想你肯定很熟悉吧？</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【队列】</title>
    <link href="http://sswfive.xyz/2025/09/15/dsa/250915-equeue/"/>
    <id>http://sswfive.xyz/2025/09/15/dsa/250915-equeue/</id>
    <published>2025-09-15T15:36:01.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导"><a href="#问题向导" class="headerlink" title="问题向导"></a>问题向导</h2><ul><li>问题1：线程池没有空闲线程时，新的任务请求 线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</li><li>思路：<ul><li>处理策略一：非阻塞的处理方式，直接拒绝任务请求</li><li>处理策略二：阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</li></ul></li><li>实现：<ul><li>对于处理策略二,引入队列来解决存储排队请求。</li><li>对于此队列的实现，有两种方式，基于链表实现和基于数组实现，这两种方式实现思路如下：<ul><li>链式队列（基于链表实现）：实现一个支持无限排队的无界队列，但随着请求数的增加，请求排队和处理的响应时间也会随之增加，这对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li><li>有界队列（基于数组实现）：队列的大小有限，故线程池中排队的请求超过队列大小时，后续请求将会被拒绝，此种方式对相应时间比较敏感的系统来说，就比较合适，但存在另外一个问题，如何设置队列的大小，就很考验开发者的经验和能力（队列太大导致请求太多，队列太小会导致无法充分利用系统资源，发挥最大性能）。</li></ul></li></ul></li></ul><h2 id="队列概述"><a href="#队列概述" class="headerlink" title="队列概述"></a>队列概述</h2><ul><li><p>概念：</p><ul><li>先进者先出的数据结构，就是队列<ul><li>类比排队买东西</li></ul></li><li>是一种抽象的数据结构</li><li>是一种操作受限的线性表数据结构（栈也是如此）</li></ul></li><li><p>特点：</p><ul><li>先进先出</li><li>支持在队尾插入元素，在队头删除元素</li></ul></li><li><p>实现</p><ul><li><p>数组实现-&gt;顺序队列</p></li><li><p>链表实现-&gt;链式队列</p></li></ul></li></ul><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><ul><li>入队enqueue()<ul><li>放一个数据到队列的尾部</li></ul></li><li>出队dequeue()<ul><li>从队列的头部取一个元素</li></ul></li></ul><h2 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h2><ul><li>顺序队列</li><li>链式队列</li><li>循环队列</li><li>阻塞队列</li><li>并发队列</li></ul><h3 id="队列—顺序队列"><a href="#队列—顺序队列" class="headerlink" title="队列—顺序队列"></a>队列—顺序队列</h3><ul><li>使用数组来实现</li><li>实现思路：<ul><li>引入两个指针：<ul><li>head指针：指向队头</li><li>tail指针：指向队尾</li></ul></li><li>入队操作时：head指针指向下标为0的位置，tail顺次往后移动，当tail移动到最后，表明数组不能继续添加数据了</li><li>出队操作时：tail指针指向队列的尾部，head指针顺次往后移动，当head移动tail的位置，表明数组已没有元素。</li></ul></li><li>注意：当tail指针移动到最后，即使数组里还有空闲空间，队列也无法插入数据，这是一个问题<ul><li>解决方法：对数据进行搬移，在每次进行出队操作时，将出队的元素标记为删除，当队列没有空间时，再集中出发数据搬移操作，</li></ul></li></ul><h3 id="队列—链式队列"><a href="#队列—链式队列" class="headerlink" title="队列—链式队列"></a>队列—链式队列</h3><ul><li>使用链表实现</li><li>实现思路：<ul><li>引入两个指针：<ul><li>head指针：指向链表的第一个结点</li><li>tail指针：指向链表的最后一个节点</li></ul></li><li>入队操作时：<ul><li>tail-&gt;next&#x3D; new_node, tail &#x3D; tail-&gt;next；</li></ul></li><li>出队操作时：<ul><li>head &#x3D; head-&gt;next</li></ul></li></ul></li></ul><h3 id="队列—循环队列"><a href="#队列—循环队列" class="headerlink" title="队列—循环队列"></a>队列—循环队列</h3><ul><li><p>主要是解决顺序队列数据搬移的问题，而是实现的一种队列</p></li><li><p>循环队列：把数组的收尾相连，折成一个环</p></li><li><p>实现思路：</p><ul><li>队列的大小为 8，当前 head&#x3D;4，tail&#x3D;7。当有一个新的元素 a 入队 时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1</li></ul></li><li><p>注意点：需要确定好队空和队满的判定条件。</p><ul><li>对空判定： head &#x3D;&#x3D; tail</li><li>队满判定：(tail+1)%n&#x3D;head。<ul><li>队满时，tail 指向的位置实际上是没有存储数据的。故循环队列 会浪费一个数组的存储空间。</li></ul></li></ul></li></ul><h3 id="队列—阻塞队列"><a href="#队列—阻塞队列" class="headerlink" title="队列—阻塞队列"></a>队列—阻塞队列</h3><ul><li><p>在队列的基础上增加了阻塞操作，</p></li><li><p>若在队列为空时，从队头取数据会被阻塞，若在队列已满时，从队尾插入数据会被阻塞，直到队列中有空闲位置在插入数据，然后再返回。</p></li><li><p>实际应用：</p><ul><li>生产者-消费者模型</li></ul></li></ul><h3 id="队列—并发队列"><a href="#队列—并发队列" class="headerlink" title="队列—并发队列"></a>队列—并发队列</h3><ul><li>线程安全的队列就是并发队列</li><li>基于数组的循环队列，利用CAS原子操作，可以实现高效的并发队列。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导&quot;&gt;&lt;a href=&quot;#问题向导&quot; class=&quot;headerlink&quot; title=&quot;问题向导&quot;&gt;&lt;/a&gt;问题向导&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：线程池没有空闲线程时，新的任务请求 线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？&lt;/li</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python中的数据类型用法剖析：从底层实现到高效应用</title>
    <link href="http://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/"/>
    <id>http://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/</id>
    <published>2025-09-14T14:13:01.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的世界里，我们每天都在和 <code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code> 打交道。但你有没有想过：</p><ul><li>为什么元组比列表快？</li><li>字典为什么查找那么高效？</li><li>列表扩容背后的策略是什么？</li><li><code>set</code> 真的是“无序”的吗？</li></ul><p>这些看似基础的问题，其实都源于Python对数据类型的底层设计。接下来，我们就来<strong>深入剖析Python中常见数据类型的本质</strong>，从“序列”、“容器”这些抽象概念讲起，到 <code>list</code> 与 <code>tuple</code>、<code>dict</code> 与 <code>set</code> 的对比实践，以及最后的相关的底层实现原理。</p><h2 id="理清概念：这些“类型名词”是什么"><a href="#理清概念：这些“类型名词”是什么" class="headerlink" title="理清概念：这些“类型名词”是什么"></a>理清概念：这些“类型名词”是什么</h2><p>刚开始学Python时，你可能听过这些术语：<code>list</code> 是可变序列”、“<code>str</code> 是扁平序列”、“<code>dict</code> 是容器类型……听起很玄乎，其实他们只是从不同视角对数据结构的分类，我们来一一拆解。</p><h3 id="1-序列类型-Sequence"><a href="#1-序列类型-Sequence" class="headerlink" title="1. 序列类型(Sequence)"></a>1. 序列类型(Sequence)</h3><p>提到 “序列”，你可以先联想日常生活中的 “排队”—— 每个人（数据）按顺序站好，有自己的位置（索引），这就是序列的核心特征。</p><p><strong>什么是序列？</strong><br>广义上，序列是一种<strong>连续存储的数据格式</strong>，就像把书按顺序摆放在书架的同一层，每个数据都有固定的 “位置编号”，通过编号能快速找到对应数据。简单说，序列就是一组按照顺序排列的数据集合。</p><p><strong>什么是Python中的序列类型？</strong></p><p>Python对序列做了一层抽象封装，形成了“序列类型”，只要某个数据类型支持一下操作，就可以归为序列类型：</p><ul><li>支持索引访问：<code>seq[0]</code></li><li>支持切片操作：<code>seq[1:3]</code></li><li>支持连接与重复：<code>seq1 + seq2</code>、<code>seq * 3</code></li><li>支持成员判断：<code>x in seq</code></li></ul><p>Python 中常见的序列类型有：<code>list</code>（列表）、<code>tuple</code>（元组）、<code>str</code>（字符串）、<code>bytes</code>（字节串）、<code>array</code>（数组）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列通用操作示例</span></span><br><span class="line">demo_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(demo_list[<span class="number">2</span>])      <span class="comment"># 索引: 3</span></span><br><span class="line"><span class="built_in">print</span>(demo_list[<span class="number">1</span>:<span class="number">4</span>])    <span class="comment"># 切片: [2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> demo_list)    <span class="comment"># 成员检测: True</span></span><br></pre></td></tr></table></figure><p><strong>序列类型的两种分类方式</strong></p><ul><li><strong>可变序列 vs 不可变序列</strong></li></ul><table><thead><tr><th>类型</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>可变序列(MutableSequence)</td><td>可以动态增删改</td><td><code>list</code>, <code>bytearray</code>, <code>array.array</code></td></tr><tr><td>不可变序列(Sequence)</td><td>一旦创建就不能修改，任何“修改”操作都会返回新对象</td><td><code>tuple</code>, <code>str</code>, <code>bytes</code></td></tr></tbody></table><blockquote><p>Tips：<code>tuple</code>虽然是不可变，但如果它内部包含<code>list</code>，你依然可以修改那个<code>list</code>,因为 <code>tuple</code>只保证“引用不变”，不保证“内容不变”。</p></blockquote><ul><li><strong>容器序列 vs 扁平序列</strong></li></ul><table><thead><tr><th>类型</th><th>存储内容</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>容器序列</td><td>存储对象的<strong>引用</strong></td><td>可以嵌套任意类型</td><td><code>list</code>, <code>tuple</code></td></tr><tr><td>扁平序列</td><td>存储对象的<strong>值本身</strong></td><td>更紧凑，效率更高</td><td><code>str</code>, <code>bytes</code>, <code>array</code></td></tr></tbody></table><blockquote><p>举个例子：<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> 中每个元素都是对字符串对象的引用；而 <code>&#39;abc&#39;</code> 是连续的字符值存储在内存中，更节省空间。</p></blockquote><h3 id="2-数值类型（Number）"><a href="#2-数值类型（Number）" class="headerlink" title="2. 数值类型（Number）"></a>2. 数值类型（Number）</h3><p>数值类型是Python中最基础的数据类型之一，专门用来表示数字，主要包括三类：</p><ul><li><strong>整数（int）</strong>：比如 <code>10</code>、<code>-5</code>、<code>0</code>，Python 的 int 没有大小限制，能存非常大的数（比如 <code>10**100</code> 这样的 “天文数字”）。</li><li><strong>布尔值（bool）</strong>：特殊的 int 子类，只有 <code>True</code>（等价于 1）和 <code>False</code>（等价于 0）两个值，常用于条件判断。</li><li><strong>浮点数（float）</strong>：带小数点的数字，比如 <code>3.14</code>、<code>-0.5</code>，注意浮点数有精度限制（比如 <code>0.1 + 0.2</code> 不等于 <code>0.3</code>）。</li><li><strong>复数（complex）</strong>：形如 <code>a + bj</code> 的数字（<code>j</code> 是虚数单位），比如 <code>2 + 3j</code>，主要用于科学计算场景。</li></ul><p>需要注意的是，它们不属于“容器”，因为不包含其他对象，是<strong>原子性</strong>的。</p><h3 id="3-容器类型-Container"><a href="#3-容器类型-Container" class="headerlink" title="3. 容器类型(Container)"></a>3. 容器类型(Container)</h3><p>这里的 “容器类型” 和前面提到的 “容器序列” 不一样 —— 它是从 “功能” 角度分类，指所有能 “容纳其他对象” 的数据结构。简单说，只要一个数据类型能把多个对象 “打包” 在一起，就是容器类型。</p><ul><li><p><strong>容器序列</strong>：特指 <code>list</code>、<code>tuple</code> 这类支持索引的序列。</p></li><li><p><strong>容器类型</strong>：泛指能容纳其他对象的数据结构，比如 <code>dict</code>、<code>set</code>、<code>list</code>。</p></li></ul><p>Python 中最常用的容器类型有 4 个：</p><ul><li><strong>list</strong>（列表）：可变、有序，能存任意类型数据</li><li><strong>tuple</strong>（元组）：不可变、有序，能存任意类型数据</li><li><strong>dict</strong>（字典）：可变、键值对结构，3.7 + 后有序</li><li><strong>set</strong>（集合）：可变、无序，元素唯一</li></ul><p>接下来我们就聚焦这 4 个核心容器类型，从语法、原理、性能到场景，做一次全方位对比。</p><h2 id="list-vs-tuple：动态与静态的选择"><a href="#list-vs-tuple：动态与静态的选择" class="headerlink" title="list vs tuple：动态与静态的选择"></a>list vs tuple：动态与静态的选择</h2><h3 id="基本用法对比"><a href="#基本用法对比" class="headerlink" title="基本用法对比"></a>基本用法对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list: 可变，灵活</span></span><br><span class="line">demo_list = [<span class="string">&#x27;AA&#x27;</span>, <span class="string">&#x27;BB&#x27;</span>, <span class="number">3</span>, <span class="literal">True</span>]</span><br><span class="line">demo_list = []          <span class="comment"># 创建、初始化</span></span><br><span class="line">demo_list = <span class="built_in">list</span>()      <span class="comment"># 创建、初始化</span></span><br><span class="line">demo_list.append(<span class="number">3.14</span>)  <span class="comment"># 添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple: 不可变，稳定 </span></span><br><span class="line">demo_tuple = <span class="built_in">tuple</span>()             <span class="comment"># 空元组</span></span><br><span class="line">demo_tuple = (<span class="number">1</span>,)                <span class="comment"># 单元素元组必须有逗号</span></span><br><span class="line">demo_tuple = (<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 多元素元组</span></span><br><span class="line">demo_tuple[<span class="number">0</span>] = <span class="number">2</span>                <span class="comment"># 报错！不支持修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple&quot;新增&quot;实际是创建新元组</span></span><br><span class="line">demo_tuple_raw= (<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">demo_tuple_new = demo_tuple_raw + (<span class="literal">True</span>,)  <span class="comment"># 创建新元组 (1, 2.0, &#x27;a&#x27;, True)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>list</th><th>tuple</th></tr></thead><tbody><tr><td>是否可变</td><td>是</td><td>否</td></tr><tr><td>是否支持增删改</td><td>是</td><td>否</td></tr><tr><td>是否支持索引&#x2F;负数索引&#x2F;切片</td><td>是</td><td>是</td></tr><tr><td>内存占用</td><td>较大</td><td>较小</td></tr><tr><td>创建速度</td><td>慢</td><td>快</td></tr><tr><td>是否相互转换</td><td>tuple()</td><td>list()</td></tr></tbody></table><h3 id="list的实现机制"><a href="#list的实现机制" class="headerlink" title="list的实现机制"></a>list的实现机制</h3><p>Python的<code>list</code>实际上是一个<strong>动态扩容顺序表</strong>，采用“<strong>分离式结构</strong>”：</p><ul><li>表头（对象元信息）和数据区分开存储。</li><li>初始分配8个元素空间，不够时自动扩容。</li></ul><p>扩容策略：</p><ul><li>小列表（&lt;50000）：扩容为原来的 <strong>4倍</strong></li><li>大列表（≥50000）：扩容为原来的 <strong>2倍</strong></li></ul><p>这种“过度分配”（over-allocation）策略保证了 <code>append()</code> 操作的<strong>均摊时间复杂度为 O(1)</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">demo_list = []</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 40 字节（空列表）</span></span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 72 → 分配了4个元素的空间 (72-40)/8 = 4</span></span><br><span class="line"></span><br><span class="line">demo_list.extend(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 加满4个</span></span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 72</span></span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 104 → 扩容！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_memory_usage</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查看列表动态扩容过程&quot;&quot;&quot;</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;空列表大小: <span class="subst">&#123;lst.__sizeof__()&#125;</span> bytes&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        lst.append(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;添加<span class="subst">&#123;i&#125;</span>后: <span class="subst">&#123;lst.__sizeof__()&#125;</span> bytes, 元素数: <span class="subst">&#123;<span class="built_in">len</span>(lst)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">check_memory_usage()</span><br></pre></td></tr></table></figure><h3 id="tuple的实现机制"><a href="#tuple的实现机制" class="headerlink" title="tuple的实现机制"></a>tuple的实现机制</h3><p><code>tuple</code> 使用“<strong>一体式结构</strong>”的顺序表，创建后大小固定，不能扩容。</p><p>正因为不可变，Python 可以对<strong>小元组进行缓存</strong>。比如 <code>(1,2,3)</code> 第一次创建后会被缓存，下次再创建相同的元组，直接复用内存，<strong>极大提升性能</strong>。</p><h3 id="list-与-tuple-性能对比"><a href="#list-与-tuple-性能对比" class="headerlink" title="list 与 tuple 性能对比"></a>list 与 tuple 性能对比</h3><p>使用<code>timeit</code>模块进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 速度对比</span></span><br><span class="line">python3 -m timeit <span class="string">&#x27;x=(1,2,3,4,5,6)&#x27;</span></span><br><span class="line"><span class="comment"># 20000000 loops, best of 5: 9.97 nsec per loop</span></span><br><span class="line"></span><br><span class="line">python3 -m timeit <span class="string">&#x27;x=[1,2,3,4,5,6]&#x27;</span></span><br><span class="line"><span class="comment"># 5000000 loops, best of 5: 50.1 nsec per loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 速度对比</span></span><br><span class="line">python3 -m timeit -s <span class="string">&#x27;x=[1,2,3,4,5,6]&#x27;</span> <span class="string">&#x27;y=x[3]&#x27;</span></span><br><span class="line"><span class="comment"># 10000000 loops, best of 5: 22.2 nsec per loop</span></span><br><span class="line"></span><br><span class="line">python3 -m timeit -s <span class="string">&#x27;x=(1,2,3,4,5,6)&#x27;</span> <span class="string">&#x27;y=x[3]&#x27;</span></span><br><span class="line"><span class="comment"># 10000000 loops, best of 5: 21.9 nsec per loop</span></span><br></pre></td></tr></table></figure><p>结论：tuple的创建速度更优，访问速度略快。其原因在于：</p><ul><li>静态结构，无需维护扩容信息</li><li>Python缓存常用tuple，减少内存的分配开销</li><li>更少的功能意味着更小的开销</li></ul><h3 id="应用场景选择"><a href="#应用场景选择" class="headerlink" title="应用场景选择"></a>应用场景选择</h3><table><thead><tr><th>场景</th><th>推荐类型</th></tr></thead><tbody><tr><td>存储固定数据（如坐标、配置）</td><td><code>tuple</code></td></tr><tr><td>函数返回多个值</td><td><code>tuple</code>（<code>return x, y</code>）</td></tr><tr><td>需要频繁增删改的数据</td><td><code>list</code></td></tr><tr><td>用作字典的键</td><td><code>tuple</code>（不可变）</td></tr><tr><td>作为集合元素</td><td><code>tuple</code></td></tr></tbody></table><ul><li>使用元组的场景</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 返回经纬度坐标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_location</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (longitude, latitude)  <span class="comment"># 使用元组保证数据不可变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 函数返回多个值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_info</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="comment"># 返回用户姓名、年龄、邮箱</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;BluesSen&quot;</span>, <span class="number">32</span>, <span class="string">&quot;bluessen@email.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 配置信息存储</span></span><br><span class="line">DATABASE_CONFIG = (<span class="string">&quot;localhost&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;my_db&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>使用列表的场景</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 记录用户一周内看过的帖子ID</span></span><br><span class="line">viewer_owner_id_list = []</span><br><span class="line">records = queryDB(viewer_id)  <span class="comment"># 查询数据库</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">    viewer_owner_id_list.append(record.<span class="built_in">id</span>)  <span class="comment"># 动态添加元素</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2. 动态数据收集</span></span><br><span class="line">user_actions = []  <span class="comment"># 收集用户操作日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_action</span>(<span class="params">action</span>):</span><br><span class="line">    user_actions.append(action)  <span class="comment"># 动态添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 需要修改的数据</span></span><br><span class="line">shopping_cart = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;milk&quot;</span>]</span><br><span class="line">shopping_cart.remove(<span class="string">&quot;banana&quot;</span>)  <span class="comment"># 修改购物车</span></span><br><span class="line">shopping_cart.sort()           <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><h3 id="常用操作汇总"><a href="#常用操作汇总" class="headerlink" title="常用操作汇总"></a>常用操作汇总</h3><p><strong>list操作：</strong></p><ul><li><code>index()</code>：返回指定元素下标</li><li><code>count()</code>：统计元素出现次数</li><li><code>len()</code>：获取列表长度</li><li><code>append()</code>：末尾追加元素</li><li><code>extend()</code>：扩展列表（添加序列中的所有元素）</li><li><code>insert()</code>：指定位置插入元素</li><li><code>pop()</code>：删除并返回指定位置元素（默认最后）</li><li><code>remove()</code>：移除第一个匹配项</li><li><code>clear()</code>：清空列表</li><li><code>reverse()</code>和<code>sort()</code>：原地反转和排序</li></ul><p><strong>tuple操作：</strong></p><ul><li><code>index()</code>：查找元素位置</li><li><code>count()</code>：统计元素出现次数</li><li><code>len()</code>：获取元组长度</li></ul><p><strong>通用函数：</strong></p><ul><li><code>reversed()</code>：返回反转后的迭代器</li><li><code>sorted()</code>：返回排序后的新列表</li></ul><p><strong>注意</strong>：如果想给元组排序 &#x2F; 反转，可以用全局函数 <code>sorted()</code> 和 <code>reversed()</code>，它们会返回新列表 &#x2F; 迭代器，不修改原元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sorted_t = <span class="built_in">sorted</span>(t)  <span class="comment"># 输出 [1,2,3]（列表）</span></span><br><span class="line">reversed_t = <span class="built_in">list</span>(<span class="built_in">reversed</span>(t))  <span class="comment"># 输出 [2,1,3]（转成列表）</span></span><br></pre></td></tr></table></figure><h2 id="dict-vs-set：键值对与去重利器"><a href="#dict-vs-set：键值对与去重利器" class="headerlink" title="dict vs set：键值对与去重利器"></a>dict vs set：键值对与去重利器</h2><h3 id="基本用法对比-1"><a href="#基本用法对比-1" class="headerlink" title="基本用法对比"></a>基本用法对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典：键值对</span></span><br><span class="line">demo_dict = &#123;&#125;  <span class="comment"># 空字典</span></span><br><span class="line">demo_dict = <span class="built_in">dict</span>()  <span class="comment"># 空字典</span></span><br><span class="line">user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合：唯一元素</span></span><br><span class="line">demo_set = <span class="built_in">set</span>()  <span class="comment"># 空集合只能用set()</span></span><br><span class="line">demo_set = &#123;<span class="number">10</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">20.0</span>, <span class="literal">False</span>, <span class="number">50</span>&#125;</span><br><span class="line">tags = &#123;<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;backend&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员检测效率对比</span></span><br><span class="line">large_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br><span class="line">large_set = <span class="built_in">set</span>(large_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表检测: O(n)时间复杂度</span></span><br><span class="line"><span class="comment"># 集合检测: O(1)时间复杂度</span></span><br></pre></td></tr></table></figure><ul><li><strong>关键区别</strong>：空字典用 <code>&#123;&#125;</code> 或 <code>dict()</code>，空集合只能用 <code>set()</code>—— 因为 <code>&#123;&#125;</code> 优先被解析为字典。</li></ul><h3 id="核心特性对比"><a href="#核心特性对比" class="headerlink" title="核心特性对比"></a>核心特性对比</h3><table><thead><tr><th>特性</th><th>Dict（字典）</th><th>Set（集合）</th></tr></thead><tbody><tr><td>存储结构</td><td>键值对（key: value）</td><td>单个元素（无键值）</td></tr><tr><td>元素唯一性</td><td>key 唯一，value 可重复</td><td>所有元素唯一（自动去重）</td></tr><tr><td>有序性</td><td>3.7+ 有序（插入顺序）</td><td>无序（无法通过索引访问）</td></tr><tr><td>索引访问</td><td>通过 key 访问，如 <code>d[&#39;key&#39;]</code></td><td>无序，无索引</td></tr><tr><td>核心用途</td><td>高效查询（通过 key 找 value）</td><td>去重、集合运</td></tr><tr><td>时间复杂度（查&#x2F;增&#x2F;删）</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="哈希表结构演变"><a href="#哈希表结构演变" class="headerlink" title="哈希表结构演变"></a>哈希表结构演变</h3><p><strong>老版本结构（紧凑但低效）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">| <span class="built_in">hash</span> | key  | value           |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 123  | <span class="string">&#x27;a&#x27;</span>  | 10              |</span><br><span class="line">| 456  | <span class="string">&#x27;b&#x27;</span>  | 20              |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><p><strong>新版本结构（稀疏索引 + 紧凑存储）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Indices: [None, 0, None, None, 1, ...]</span><br><span class="line"></span><br><span class="line">Entries:</span><br><span class="line">+------------------+</span><br><span class="line">| <span class="built_in">hash</span> | key | val |</span><br><span class="line">+------------------+</span><br><span class="line">| 123  | <span class="string">&#x27;a&#x27;</span> | 10  |</span><br><span class="line">| 456  | <span class="string">&#x27;b&#x27;</span> | 20  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>优势：节省内存、提升遍历速度、支持有序迭代。</p><h3 id="dict和set-的实现机制"><a href="#dict和set-的实现机制" class="headerlink" title="dict和set 的实现机制"></a>dict和set 的实现机制</h3><p><code>dict</code> 和 <code>set</code> 的核心都是<strong>哈希表（Hash Table）</strong>，通过哈希函数将键映射到数组索引，实现近乎常数时间的查找。Python采用优化后的哈希表结构，提高了内存利用率和访问效率。</p><ul><li><code>dict</code> 的哈希表结构：存储“哈希值（hash）、键（key）、值（value）”三个元素，支持快速键值查找</li></ul><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 索引区（记录元素在数据区的位置）</span><br><span class="line">Indices: [None, 0, None, 2, None, 1, ...]</span><br><span class="line"># 数据区（存储实际的键值对和哈希值）</span><br><span class="line">Entries:</span><br><span class="line">[hash0, key0, value0]  # 位置0</span><br><span class="line">[hash1, key1, value1]  # 位置1</span><br><span class="line">[hash2, key2, value2]  # 位置2</span><br></pre></td></tr></table></figure><ul><li><code>set</code> 只存储 “哈希值（hash）、元素（element）”，因为没有 value，结构更简单, 专注于快速成员检测</li></ul><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entries:</span><br><span class="line">[hash0, element0]  # 位置0</span><br><span class="line">[hash1, element1]  # 位置1</span><br><span class="line">[hash2, element2]  # 位置2</span><br></pre></td></tr></table></figure><p><strong>操作分析：</strong></p><ol><li><strong>插入操作</strong>：<ul><li>计算键的哈希值并与mask做与操作得到位置index</li><li>如果位置空，直接插入</li><li>如果位置被占用，比较哈希值和键</li><li>都相等：更新值（字典）或忽略（集合）</li><li>不相等（哈希冲突）：继续寻找空位</li></ul></li><li><strong>查找操作</strong>：<ul><li>类似插入过程，找到对应位置后比较哈希值和键</li></ul></li><li><strong>删除操作</strong>：<ul><li>标记删除位置，等待哈希表调整时真正删除</li></ul></li></ol><h3 id="哈希冲突与扩容机制"><a href="#哈希冲突与扩容机制" class="headerlink" title="哈希冲突与扩容机制"></a>哈希冲突与扩容机制</h3><p>什么是哈希冲突？</p><ul><li><p>两个不同的键，计算出相同的哈希值（或索引），就会发生冲突。</p></li><li><p>Python采用<strong>开放寻址法</strong>解决冲突：如果位置被占，就找下一个空位。这可能会降低操作效率。为了保证高效性，哈希表始终保持至少1&#x2F;3的剩余空间，当空间不足时自动扩容。</p></li></ul><p> 如何实现扩容机制</p><ul><li><p>当哈希表使用率 &gt; 2&#x2F;3 时，触发扩容。</p></li><li><p>扩容为原来的 2~4 倍，并重新哈希所有元素。</p></li></ul><blockquote><p> 这也是为什么 <code>dict</code> 插入操作虽然是 O(1)，但偶尔会“卡一下”——那是它在扩容。</p></blockquote><h3 id="应用实践与技巧"><a href="#应用实践与技巧" class="headerlink" title="应用实践与技巧"></a>应用实践与技巧</h3><ul><li>dict的用法实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 字典推导式</span></span><br><span class="line">squares = &#123;x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)&#125;</span><br><span class="line"><span class="comment"># &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合并字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">3</span>, <span class="string">&quot;c&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">merged = &#123;**dict1, **dict2&#125;  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置默认值</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">word_count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    word_count[word] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 4. 字典排序示例</span></span><br><span class="line">d = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 按key排序</span></span><br><span class="line">d_sorted_by_key = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 10)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 按value排序</span></span><br><span class="line">d_sorted_by_value = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># [(&#x27;b&#x27;, 1), (&#x27;a&#x27;, 2), (&#x27;c&#x27;, 10)]</span></span><br></pre></td></tr></table></figure><ul><li>dict的场景实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 配置管理</span></span><br><span class="line">app_config = &#123;</span><br><span class="line">    <span class="string">&quot;debug&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;database&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5432</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myapp&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;api_keys&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;google&quot;</span>: <span class="string">&quot;abc123&quot;</span>,</span><br><span class="line">        <span class="string">&quot;aws&quot;</span>: <span class="string">&quot;def456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据聚合</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_words</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计词频&quot;&quot;&quot;</span></span><br><span class="line">    word_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">        word_count[word] = word_count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_count</span><br></pre></td></tr></table></figure><ul><li>set的用法实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 集合运算</span></span><br><span class="line">A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A | B)  <span class="comment"># 并集: &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(A &amp; B)  <span class="comment"># 交集: &#123;3, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(A - B)  <span class="comment"># 差集: &#123;1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 快速去重</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">unique = <span class="built_in">list</span>(<span class="built_in">set</span>(numbers))  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li>set 的场景实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 权限管理</span></span><br><span class="line">user_roles = &#123;<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;editor&quot;</span>, <span class="string">&quot;viewer&quot;</span>&#125;</span><br><span class="line">current_user_roles = &#123;<span class="string">&quot;editor&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line"><span class="keyword">if</span> current_user_roles &amp; user_roles:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有访问权限&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据清洗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速去重并保持顺序&quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> <span class="keyword">not</span> (x <span class="keyword">in</span> seen <span class="keyword">or</span> seen.add(x))]</span><br></pre></td></tr></table></figure><h3 id="常用操作汇总-1"><a href="#常用操作汇总-1" class="headerlink" title="常用操作汇总"></a>常用操作汇总</h3><p><strong>dict 操作：</strong></p><ul><li><code>keys()</code>：返回所有键</li><li><code>values()</code>：返回所有值</li><li><code>items()</code>：返回所有键值对</li><li><code>del</code>：删除键值对</li><li><code>clear()</code>：清空字典</li><li>遍历：<code>for key in dict</code>或<code>for key, value in dict.items()</code></li></ul><p><strong>set 操作：</strong></p><ul><li><code>add()</code>：添加元素</li><li><code>update()</code>：添加多个元素（传入序列）</li><li><code>remove()</code>：删除指定元素（不存在则报错）</li><li><code>discard()</code>：删除指定元素（不存在不报错）</li><li><code>pop()</code>：随机删除并返回一个元素（因集合无序需谨慎使用）</li></ul><h2 id="如何选择合适的数据类型？"><a href="#如何选择合适的数据类型？" class="headerlink" title="如何选择合适的数据类型？"></a>如何选择合适的数据类型？</h2><h3 id="场景1：频繁查找"><a href="#场景1：频繁查找" class="headerlink" title="场景1：频繁查找"></a>场景1：频繁查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误做法：使用列表查找</span></span><br><span class="line">names_list = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>] * <span class="number">1000</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;David&quot;</span> <span class="keyword">in</span> names_list:  <span class="comment"># O(n)时间复杂度</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确做法：使用集合查找  </span></span><br><span class="line">names_set = <span class="built_in">set</span>(names_list)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;David&quot;</span> <span class="keyword">in</span> names_set:  <span class="comment"># O(1)时间复杂度</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="场景2：数据记录"><a href="#场景2：数据记录" class="headerlink" title="场景2：数据记录"></a>场景2：数据记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要修改数据：用列表</span></span><br><span class="line">student_scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>]  <span class="comment"># 可能变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要修改数据：用元组</span></span><br><span class="line">student_info = (<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;2021001&quot;</span>, <span class="string">&quot;计算机系&quot;</span>)  <span class="comment"># 固定信息</span></span><br></pre></td></tr></table></figure><h3 id="场景3：内存使用优化"><a href="#场景3：内存使用优化" class="headerlink" title="场景3：内存使用优化"></a>场景3：内存使用优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用__sizeof__()分析内存占用</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">data_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表占用: <span class="subst">&#123;sys.getsizeof(data_list)&#125;</span> bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组占用: <span class="subst">&#123;sys.getsizeof(data_tuple)&#125;</span> bytes&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><table><thead><tr><th align="left">场景</th><th align="left">推荐数据结构</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left">动态数据集合</td><td align="left">列表(list)</td><td align="left">支持频繁增删改</td></tr><tr><td align="left">固定数据集合</td><td align="left">元组(tuple)</td><td align="left">更快的创建和访问速度</td></tr><tr><td align="left">键值映射</td><td align="left">字典(dict)</td><td align="left">快速的键值查找</td></tr><tr><td align="left">唯一值集合</td><td align="left">集合(set)</td><td align="left">快速成员检测和去重</td></tr><tr><td align="left">配置信息</td><td align="left">元组&#x2F;字典</td><td align="left">根据是否需要修改选择</td></tr><tr><td align="left">数据缓存</td><td align="left">字典</td><td align="left">快速的键值访问</td></tr></tbody></table><p><strong>记住这几个原则：</strong></p><ol><li><strong>需要修改</strong> → 选择列表</li><li><strong>不需要修改</strong> → 选择元组</li><li><strong>需要快速查找</strong> → 选择字典或集合</li><li><strong>需要去重</strong> → 选择集合</li><li><strong>需要保持顺序</strong> → 选择列表或元组</li></ol><p>理解了这些数据结构的底层原理和特性，能够帮助我们在实际开发中做出更合理的选择，编写出更高效、更优雅的Python代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Python的世界里，我们每天都在和 &lt;code&gt;list&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt; 打交道。但你有没有想过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么元组比列表快？&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python工程实践" scheme="http://sswfive.xyz/tags/python%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="Python核心知识" scheme="http://sswfive.xyz/tags/Python%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【链表】</title>
    <link href="http://sswfive.xyz/2025/09/12/dsa/250912-linkedlist/"/>
    <id>http://sswfive.xyz/2025/09/12/dsa/250912-linkedlist/</id>
    <published>2025-09-12T12:50:01.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导："><a href="#问题向导：" class="headerlink" title="问题向导："></a>问题向导：</h2><ul><li>问题1：如何实现LRU缓存淘汰算法？</li><li>思路：<ul><li>维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表。</li></ul></li><li>实现：</li></ul><ol><li>如果在此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，可以分两种情况考虑：<ol><li>如果此时缓存未满，则将该结点直接插入到链表的头部。</li><li>如果此时缓存已满，则删除链表的尾结点，将新的数据结点插入到链表的头部。</li></ol></li></ol><ul><li>优化实现：<ul><li>引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1).</li></ul></li><li>其他实现：<ul><li>使用数组实现LRU缓存淘汰策略<blockquote><p>扩展1：</p><ul><li>缓存利用的是空间换时间的设计思想<ul><li>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化。</li><li>对于消耗过多内存的程序，可以通过消耗更多时间（时间换空间）来降低内存的消耗。<br>扩展2：</li></ul></li><li>常见缓存淘汰策略<ul><li>FIFO(First In, First Out):先进先出策略</li><li>LFU(Least Frequently Used): 最少使用策略</li><li>LRU(Least Recently Used): 最少使用策略</li></ul></li></ul></blockquote></li></ul></li></ul><hr><h2 id="链表概述："><a href="#链表概述：" class="headerlink" title="链表概述："></a>链表概述：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>链表是通过指针将一组零散的内存快串联在一起的一种数据结构。<ul><li>内存块通常被称为链表的结点，每个链表的结点除了存储数据之外，还需要记录下一个节点的地址的指针（通常称为后继指针next）</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比:"></a>对比:</h3><ul><li>数组：需要一块连续的内存空间来存储，对内存要求比较高</li><li>链表：不需要一块连续的内存空间，它通过指针将一组零散的内存块串联使用。</li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>支持数据的查找、插入、删除操作</li><li>相对与数组，链表更适合插入和删除操作、查找的效率则没有数组高。</li><li>插入删除<ul><li>数组O(n)</li><li>链表O(1)</li></ul></li><li>随机访问<ul><li>数组O(1)</li><li>链表O(n)</li></ul></li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><p><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.jgzcedshfdc.webp" alt="image"></p><ul><li>单链表</li><li>循环链表</li><li>双向链表</li><li>双向循环链表</li></ul><h2 id="链表详解："><a href="#链表详解：" class="headerlink" title="链表详解："></a>链表详解：</h2><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><ul><li>特点：<ul><li>只有一个方向</li><li>结点只有一个后继指针next指向后的结点</li><li>头结点记录链表的基地址</li><li>尾结点指针指向一个空地址NULL</li></ul></li><li>常用操作的时间复杂度：<ul><li>查找:  O(n)</li><li>插入 : O(1)</li><li>删除:  O(1)</li></ul></li></ul><h3 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h3><ul><li>特点：<ul><li>是一种特殊的单链表</li><li>和单链表唯一的区别在我尾结点，尾结点指针指向连链表的头结点</li><li>和单链表相比，优点是从链尾到链头比较方便，当要处理的数据具有环形结构特点时，就适合采用循环链表（单链表实现相对比较繁琐）。比如：约<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">瑟夫问题。</a></li></ul></li></ul><h3 id="双向链表："><a href="#双向链表：" class="headerlink" title="双向链表："></a>双向链表：</h3><ul><li>特点<ul><li>支持两个方向</li><li>每个结点不止有一个后继指针next指向后面的结点，还有前驱指针pre指向前面的结点</li><li>相较于单链表，会占用更多的内存。</li><li>支持双向遍历，这样也带来了 双向链表操作的灵活性。提高的数据插入和删除的效率。</li></ul></li><li>操作<ul><li>删除的情况分析：<ol><li>删除结点中“值等于某个给定值”的结点；<ul><li>需要从链表头部依次遍历，知道找到值等于给定值的结点，O(n)，然后执行删除操作O(1)，所以时间复杂度为O(n)</li></ul></li><li>删除给定指针指向的结点；<ul><li>此情况需要知道该结点的前驱结点，而单链表不支持获取前驱结点，故需要从头开始遍历O(n)，直到到 p-&gt;next&#x3D;q，说明 p 是 q 的前驱结点。与之对比，使用双向链表操作比较高效，时间复杂度为O(1)。</li></ul></li></ol></li></ul></li></ul><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><ul><li>整合了循环链表和双向链表的特点形成了一种链表</li><li>首节点的前驱指针指向尾结点，尾结点的后驱指针指向首节点。</li></ul><hr><h2 id="链表代码编写技巧指南"><a href="#链表代码编写技巧指南" class="headerlink" title="链表代码编写技巧指南"></a>链表代码编写技巧指南</h2><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><ul><li>指针的理解：<ul><li>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li></ul></li><li>eg:<ul><li>p-&gt;next&#x3D;q。这行代码是说，p结点中的next指针存储了q结点的内存地址。</li><li>p-&gt;next&#x3D;p-&gt;next-&gt;next。这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址。</li></ul></li></ul><h3 id="技巧二：警惕指针丢失和内存泄露"><a href="#技巧二：警惕指针丢失和内存泄露" class="headerlink" title="技巧二：警惕指针丢失和内存泄露"></a>技巧二：警惕指针丢失和内存泄露</h3><ul><li>eg: 单链表的插入操作</li><li><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.3j2r3fc4yfw0.webp" alt="image"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x; // 将 p 的 next 指针指向 x 结点；</span><br><span class="line">x-&gt;next = p-&gt;next; // 将 x 的结点的 next 指针指向 b 结点；</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而 是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就 断成了两半，从结点 b 往后的所有结点都无法访问到了</li></ul></li><li>正确做法：<ul><li>先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</li></ul></li><li>总结：<ul><li>插入结点时，一定要注意操作的顺序。</li><li>删除链表结点时，也一定要记得手动释放内存空间。</li></ul></li></ul><h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><blockquote><p>哨兵：解决的是国家之间的边界问题，同理，在数据结构所说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p></blockquote><p>eg1: 向空链表中插入第一个结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (head == null) &#123;</span><br><span class="line">head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg2:单链表结点删除操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 删除结点 p 的后继结点</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"># 删除链表中的最后一个结点</span><br><span class="line">if (head-&gt;next == null) &#123;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通实现的方法总结：<ul><li>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</li></ul></li></ul><p>哨兵方式实现：</p><p><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.e3p38wfw9ds.webp" alt="image"></p><ul><li>引入哨兵结点，在任何时候，不管链表是否为空，head指针都会一直指向这个哨兵结点，也称这个哨兵结点的链表交带头链表。</li><li>哨兵结点是不存储数据的</li><li>插入排序、归并排序、动态规划都使用了哨兵的方式实现。</li></ul><h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>检查链表代码是否正确的边界条件有如下几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码能否正常工作？</li><li>如果链表只包含两个结点时，代码能否正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>举例法和画图法：</p><ul><li>可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感 觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一 个例子，画出插入前和插入后的链表变化，如图所示：</li><li><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.4q4rtsz93d60.webp" alt="image"></li></ul><h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导：&quot;&gt;&lt;a href=&quot;#问题向导：&quot; class=&quot;headerlink&quot; title=&quot;问题向导：&quot;&gt;&lt;/a&gt;问题向导：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：如何实现LRU缓存淘汰算法？&lt;/li&gt;
&lt;li&gt;思路：&lt;ul&gt;
&lt;li&gt;维护一个有序的单链表，越</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>用了pathlib后，我再也不想碰os.path了！</title>
    <link href="http://sswfive.xyz/2025/09/11/tech/python/250308-pylib-pathlib/"/>
    <id>http://sswfive.xyz/2025/09/11/tech/python/250308-pylib-pathlib/</id>
    <published>2025-09-11T02:17:00.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常Python开发中，文件路径操作是绕不开的话题。你是否还在使用<code>os.path.join()</code>拼接路径？是否还在为Windows和Linux的路径分隔符头疼？是否期待一种更Pythonic的方式来处理路径？</p><p>先来看一个直观的对比，即使你现在还不熟悉pathlib，也能一眼看出来区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式：繁琐且易出错</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">base_path = os.path.dirname(os.path.dirname(os.getcwd()))</span><br><span class="line">file_path = os.path.join(base_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;profile.json&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pathlib方式：简洁优雅</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">file_path = Path.cwd().parent.parent / <span class="string">&#x27;data&#x27;</span> / <span class="string">&#x27;users&#x27;</span> / <span class="string">&#x27;profile.json&#x27;</span></span><br><span class="line"><span class="keyword">if</span> file_path.exists():</span><br><span class="line">    content = file_path.read_text()</span><br></pre></td></tr></table></figure><p>看出差异了吗？今天要介绍的，正是这个让文件路径操作变得优雅如诗的Python标准库——<strong>pathlib</strong>。</p><h2 id="pathlib是什么？"><a href="#pathlib是什么？" class="headerlink" title="pathlib是什么？"></a>pathlib是什么？</h2><p>pathlib是Python 3.4中新增的标准库模块，提供了面向对象的文件系统路径操作方式。官网地址：<a href="https://docs.python.org/3/library/pathlib.html">点击前往</a></p><p>它的核心优势包括：</p><ul><li><strong>面向对象API</strong>：路径不再是字符串，而是Path对象，方法可以链式调用 </li><li><strong>跨平台统一</strong>：无缝兼容Windows和Unix系统，自动处理不同操作系统的路径差异</li><li><strong>直观易懂</strong>：代码即文档，一看就懂 </li><li><strong>功能强大</strong>：覆盖了绝大部分文件路径操作需求，包括文件操作、路径查询、模式匹配等功能</li></ul><p>日常开发中，我们最常用的是<strong>Path</strong>类，它可以完全替代os.path的功能。</p><h2 id="为什么需要pathlib？"><a href="#为什么需要pathlib？" class="headerlink" title="为什么需要pathlib？"></a>为什么需要pathlib？</h2><blockquote><p><strong>传统os.path的三大痛点</strong></p></blockquote><p><strong>1. 函数式编程，缺乏连贯性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os.path: 需要不断传递路径字符串</span></span><br><span class="line">path = <span class="string">&#x27;/Users/astonwang/projects&#x27;</span></span><br><span class="line">parent = os.path.dirname(path)</span><br><span class="line">grandparent = os.path.dirname(parent)</span><br></pre></td></tr></table></figure><p><strong>2. 跨平台兼容性问题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows: C:\Users\Name\Documents</span></span><br><span class="line"><span class="comment"># Linux: /home/name/documents</span></span><br><span class="line"><span class="comment"># 需要手动处理路径分隔符差异</span></span><br></pre></td></tr></table></figure><p><strong>3. 代码可读性差</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这行代码在做什么？一眼看不出来</span></span><br><span class="line">full_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;config.json&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="pathlib的核心设计"><a href="#pathlib的核心设计" class="headerlink" title="pathlib的核心设计"></a>pathlib的核心设计</h2><p>pathlib提供了丰富的类来处理不同场景下的路径操作：</p><h3 id="两大分支：纯路径-vs-具体路径"><a href="#两大分支：纯路径-vs-具体路径" class="headerlink" title="两大分支：纯路径 vs 具体路径"></a>两大分支：纯路径 vs 具体路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 纯路径：只做路径运算，不访问文件系统</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> PurePath, PurePosixPath, PureWindowsPath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体路径：可以访问文件系统，进行I/O操作  </span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PosixPath, WindowsPath</span><br></pre></td></tr></table></figure><p><strong>纯路径家族</strong>（Pure Path）- 理论派</p><ul><li>只负责路径的逻辑运算</li><li>不会访问真实的文件系统</li><li>适合路径字符串的处理和转换</li></ul><p><strong>具体路径家族</strong>（Concrete Path）- 实践派</p><ul><li>可以创建、读取、写入文件</li><li>能够检查文件是否存在</li><li>支持所有文件系统操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 纯路径操作（无I/O）</span></span><br><span class="line">PurePath</span><br><span class="line">├── PurePosixPath  <span class="comment"># Unix风格</span></span><br><span class="line">└── PureWindowsPath <span class="comment"># Windows风格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体路径操作（带I/O）</span></span><br><span class="line">Path</span><br><span class="line">├── PosixPath      <span class="comment"># Unix系统</span></span><br><span class="line">└── WindowsPath    <span class="comment"># Windows系统</span></span><br></pre></td></tr></table></figure><h3 id="日常开发首选：Path类"><a href="#日常开发首选：Path类" class="headerlink" title="日常开发首选：Path类"></a>日常开发首选：Path类</h3><p>在99%的场景中，你只需要使用<strong>Path类</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path会自动选择合适的子类</span></span><br><span class="line"><span class="comment"># 在Linux/Mac上 -&gt; PosixPath  </span></span><br><span class="line"><span class="comment"># 在Windows上 -&gt; WindowsPath</span></span><br><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(current_dir))  <span class="comment"># 自动适配当前系统</span></span><br></pre></td></tr></table></figure><p><strong>记住这个原则</strong>：除非有特殊需求，否则直接用<code>Path</code>就够了！</p><h2 id="pathlib-VS-os-path-的API对比"><a href="#pathlib-VS-os-path-的API对比" class="headerlink" title="pathlib VS os.path 的API对比"></a>pathlib VS os.path 的API对比</h2><p>想知道pathlib到底比os.path强在哪里？来看看这个对比表：</p><table><thead><tr><th>功能</th><th>pathlib优雅写法</th><th>os.path传统写法</th></tr></thead><tbody><tr><td><strong>获取当前目录</strong></td><td><code>Path.cwd()</code></td><td><code>os.getcwd()</code></td></tr><tr><td><strong>获取主目录</strong></td><td><code>Path.home()</code></td><td><code>os.path.expanduser(&#39;~&#39;)</code></td></tr><tr><td><strong>路径拼接</strong></td><td><code>Path(&#39;a&#39;) / &#39;b&#39; / &#39;c&#39;</code></td><td><code>os.path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></td></tr><tr><td><strong>获取绝对路径</strong></td><td><code>path.absolute()</code></td><td><code>os.path.abspath(path)</code></td></tr><tr><td><strong>获取父目录</strong></td><td><code>path.parent</code></td><td><code>os.path.dirname(path)</code></td></tr><tr><td><strong>获取文件名</strong></td><td><code>path.name</code></td><td><code>os.path.basename(path)</code></td></tr><tr><td><strong>判断是否存在</strong></td><td><code>path.exists()</code></td><td><code>os.path.exists(path)</code></td></tr><tr><td><strong>判断是否文件</strong></td><td><code>path.is_file()</code></td><td><code>os.path.isfile(path)</code></td></tr><tr><td><strong>创建目录</strong></td><td><code>path.mkdir(parents=True)</code></td><td><code>os.makedirs(path)</code></td></tr><tr><td><strong>读取文件</strong></td><td><code>path.read_text()</code></td><td><code>open(path).read()</code></td></tr><tr><td><strong>写入文件</strong></td><td><code>path.write_text(data)</code></td><td><code>open(path, &#39;w&#39;).write(data)</code></td></tr></tbody></table><p><strong>一句话总结</strong>：pathlib让你的代码从”写给计算机看”变成”写给人类看”！</p><h2 id="Pathlib基础实践指南—Path类"><a href="#Pathlib基础实践指南—Path类" class="headerlink" title="Pathlib基础实践指南—Path类"></a>Pathlib基础实践指南—Path类</h2><p>pathlib的强大之处在于它丰富的方法库，让我们按使用场景来分类介绍：</p><h3 id="路径探索操作"><a href="#路径探索操作" class="headerlink" title="路径探索操作"></a>路径探索操作</h3><h4 id="获取特殊目录"><a href="#获取特殊目录" class="headerlink" title="获取特殊目录"></a>获取特殊目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前工作目录 - 相当于 os.getcwd()</span></span><br><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前目录: <span class="subst">&#123;current_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户主目录 - 相当于 os.path.expanduser(&#x27;~&#x27;)  </span></span><br><span class="line">home_dir = Path.home()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;主目录: <span class="subst">&#123;home_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路径是否存在 - 相当于 os.path.exists()</span></span><br><span class="line">config_file = Path(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> config_file.exists():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;配置文件存在&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>pathlib的<code>glob</code>功能堪比终端的find命令，让文件搜索变得简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录所有Python文件</span></span><br><span class="line">python_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).glob(<span class="string">&quot;*.py&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;找到 <span class="subst">&#123;<span class="built_in">len</span>(python_files)&#125;</span> 个Python文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索所有Python文件 - 相当于 find . -name &quot;*.py&quot;</span></span><br><span class="line">all_python_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;*.py&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找特定模式的文件</span></span><br><span class="line">test_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;test_*.py&quot;</span>))</span><br><span class="line">config_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;**/config/*.json&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录内容 - 相当于 os.listdir()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).iterdir():</span><br><span class="line">    <span class="keyword">if</span> item.is_file():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;文件: <span class="subst">&#123;item.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> item.is_dir():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;目录: <span class="subst">&#123;item.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历目录树 - 相当于 os.walk()</span></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).walk():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前目录: <span class="subst">&#123;dirpath&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;子目录: <span class="subst">&#123;dirnames&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件: <span class="subst">&#123;filenames[:<span class="number">3</span>]&#125;</span>...&quot;</span>)  <span class="comment"># 只显示前3个文件</span></span><br></pre></td></tr></table></figure><h4 id="路径转换"><a href="#路径转换" class="headerlink" title="路径转换"></a>路径转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取绝对路径 - 相当于 os.path.abspath()</span></span><br><span class="line">relative_path = Path(<span class="string">&quot;../data/file.txt&quot;</span>)</span><br><span class="line">absolute_path = relative_path.absolute()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析软链接 - 相当于 os.path.realpath()</span></span><br><span class="line">resolved_path = relative_path.resolve()</span><br></pre></td></tr></table></figure><h3 id="路径类型判断"><a href="#路径类型判断" class="headerlink" title="路径类型判断"></a>路径类型判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断路径类型 - 比 os.path.isfile/isdir 更直观</span></span><br><span class="line">data_path = Path(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">config_dir = Path(<span class="string">&quot;config/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础判断</span></span><br><span class="line"><span class="keyword">if</span> data_path.is_file():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个文件&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> config_dir.is_dir():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个目录&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个路径是否指向同一个文件 - 相当于 os.path.samefile()</span></span><br><span class="line"><span class="keyword">if</span> Path(<span class="string">&quot;file1.txt&quot;</span>).samefile(Path(<span class="string">&quot;file2.txt&quot;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;两个路径指向同一个文件&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h3><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录 - 比 os.makedirs 更简洁</span></span><br><span class="line">new_dir = Path(<span class="string">&quot;project/src/utils&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录（相当于 mkdir -p）</span></span><br><span class="line">new_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空目录 - 相当于 os.rmdir()</span></span><br><span class="line">empty_dir = Path(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> empty_dir.exists() <span class="keyword">and</span> empty_dir.is_dir():</span><br><span class="line">    empty_dir.rmdir()</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>pathlib最让人惊喜的地方就是内置的文件读写方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空文件（相当于 touch 命令）</span></span><br><span class="line">log_file = Path(<span class="string">&quot;app.log&quot;</span>)</span><br><span class="line">log_file.touch(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码读取文件 - 告别繁琐的open/close</span></span><br><span class="line">config_text = Path(<span class="string">&quot;config.txt&quot;</span>).read_text(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">binary_data = Path(<span class="string">&quot;image.png&quot;</span>).read_bytes()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码写入文件</span></span><br><span class="line">Path(<span class="string">&quot;output.txt&quot;</span>).write_text(<span class="string">&quot;Hello, pathlib!&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">Path(<span class="string">&quot;data.bin&quot;</span>).write_bytes(<span class="string">b&quot;binary data&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重命名 - 相当于 os.rename()</span></span><br><span class="line">old_file = Path(<span class="string">&quot;old_name.txt&quot;</span>)</span><br><span class="line">new_file = old_file.rename(<span class="string">&quot;new_name.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="文件信息查询"><a href="#文件信息查询" class="headerlink" title="文件信息查询"></a>文件信息查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文件详细信息 - 相当于 os.stat()</span></span><br><span class="line">file_path = Path(<span class="string">&quot;document.pdf&quot;</span>)</span><br><span class="line">stat_info = file_path.stat()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文件大小: <span class="subst">&#123;stat_info.st_size&#125;</span> 字节&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改时间: <span class="subst">&#123;stat_info.st_mtime&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;创建时间: <span class="subst">&#123;stat_info.st_ctime&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件权限 - 相当于 chmod</span></span><br><span class="line">script_file = Path(<span class="string">&quot;deploy.sh&quot;</span>)</span><br><span class="line">script_file.chmod(<span class="number">0o755</span>)  <span class="comment"># 给脚本添加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件所有者信息（Unix/Linux系统）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    owner = script_file.owner()</span><br><span class="line">    group = script_file.group()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有者: <span class="subst">&#123;owner&#125;</span>, 组: <span class="subst">&#123;group&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法获取所有者信息&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="pathlib工程实践技巧"><a href="#pathlib工程实践技巧" class="headerlink" title="pathlib工程实践技巧"></a>pathlib工程实践技巧</h2><h3 id="实践技巧一：链式调用的艺术"><a href="#实践技巧一：链式调用的艺术" class="headerlink" title="实践技巧一：链式调用的艺术"></a>实践技巧一：链式调用的艺术</h3><p>pathlib最大的魅力在于可以进行优雅的链式调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行代码完成复杂操作</span></span><br><span class="line">result = (Path.cwd()</span><br><span class="line">          .parent                    <span class="comment"># 获取父目录</span></span><br><span class="line">          .parent                    <span class="comment"># 再获取父目录</span></span><br><span class="line">          / <span class="string">&quot;data&quot;</span>                   <span class="comment"># 进入data文件夹</span></span><br><span class="line">          / <span class="string">&quot;config.json&quot;</span>)           <span class="comment"># 指向配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式判断和操作</span></span><br><span class="line"><span class="keyword">if</span> (Path.home() / <span class="string">&quot;.ssh&quot;</span> / <span class="string">&quot;id_rsa&quot;</span>).exists():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SSH密钥存在&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式文件处理</span></span><br><span class="line">(Path(<span class="string">&quot;temp&quot;</span>) </span><br><span class="line"> .mkdir(exist_ok=<span class="literal">True</span>)             <span class="comment"># 创建临时目录</span></span><br><span class="line"> .joinpath(<span class="string">&quot;output.txt&quot;</span>)           <span class="comment"># 创建文件路径</span></span><br><span class="line"> .write_text(<span class="string">&quot;Hello, World!&quot;</span>))     <span class="comment"># 写入内容</span></span><br></pre></td></tr></table></figure><h3 id="实践技巧二：优雅的错误处理"><a href="#实践技巧二：优雅的错误处理" class="headerlink" title="实践技巧二：优雅的错误处理"></a>实践技巧二：优雅的错误处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_read_config</span>(<span class="params">config_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;安全读取配置文件&quot;&quot;&quot;</span></span><br><span class="line">    path = Path(config_path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path.exists():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;配置文件不存在: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查是否为文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path.is_file():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;路径不是文件: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安全读取</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = path.read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(content)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;读取配置失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实践建议一：使用-Path-替代字符串拼接"><a href="#实践建议一：使用-Path-替代字符串拼接" class="headerlink" title="实践建议一：使用 Path 替代字符串拼接"></a>实践建议一：使用 Path 替代字符串拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐：字符串拼接</span></span><br><span class="line">config_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&quot;.config&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;settings.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐：pathlib方式</span></span><br><span class="line">config_path = Path.home() / <span class="string">&quot;.config&quot;</span> / <span class="string">&quot;app&quot;</span> / <span class="string">&quot;settings.json&quot;</span></span><br></pre></td></tr></table></figure><h3 id="实践建议二：利用-操作符进行路径拼接"><a href="#实践建议二：利用-操作符进行路径拼接" class="headerlink" title="实践建议二：利用 &#x2F; 操作符进行路径拼接"></a>实践建议二：利用 &#x2F; 操作符进行路径拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：使用 / 操作符，简洁直观</span></span><br><span class="line">project_root = Path(__file__).parent.parent</span><br><span class="line">data_dir = project_root / <span class="string">&quot;data&quot;</span></span><br><span class="line">output_file = data_dir / <span class="string">&quot;results&quot;</span> / <span class="string">f&quot;output_<span class="subst">&#123;datetime.now().strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)&#125;</span>.csv&quot;</span></span><br></pre></td></tr></table></figure><h3 id="实践建议三：使用上下文管理器"><a href="#实践建议三：使用上下文管理器" class="headerlink" title="实践建议三：使用上下文管理器"></a>实践建议三：使用上下文管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：安全的文件操作</span></span><br><span class="line"><span class="keyword">with</span> Path(<span class="string">&quot;data.txt&quot;</span>).<span class="built_in">open</span>(<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;重要数据&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更简洁的方式</span></span><br><span class="line">Path(<span class="string">&quot;data.txt&quot;</span>).write_text(<span class="string">&quot;重要数据&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-充分利用内置方法"><a href="#4-充分利用内置方法" class="headerlink" title="4. 充分利用内置方法"></a>4. 充分利用内置方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：使用pathlib内置方法</span></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).iterdir() <span class="keyword">if</span> f.suffix == <span class="string">&quot;.py&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更推荐：使用glob</span></span><br><span class="line">files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).glob(<span class="string">&quot;*.py&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="pathlib的实践应用场景"><a href="#pathlib的实践应用场景" class="headerlink" title="pathlib的实践应用场景"></a>pathlib的实践应用场景</h2><p>让我们通过几个真实场景，看看pathlib如何让复杂的文件操作变得简单。</p><h3 id="场景一：项目结构分析器"><a href="#场景一：项目结构分析器" class="headerlink" title="场景一：项目结构分析器"></a>场景一：项目结构分析器</h3><p>假设你要分析一个Python项目的结构，统计代码行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_project</span>(<span class="params">project_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;分析Python项目结构&quot;&quot;&quot;</span></span><br><span class="line">    project = Path(project_path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计不同类型的文件</span></span><br><span class="line">    py_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.py&quot;</span>))  <span class="comment"># 所有Python文件</span></span><br><span class="line">    test_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;test_*.py&quot;</span>))  <span class="comment"># 测试文件</span></span><br><span class="line">    config_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.json&quot;</span>)) + <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.yaml&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算总代码行数</span></span><br><span class="line">    total_lines = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> py_file <span class="keyword">in</span> py_files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            lines = <span class="built_in">len</span>(py_file.read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>).splitlines())</span><br><span class="line">            total_lines += lines</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;项目分析报告 - <span class="subst">&#123;project.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Python文件: <span class="subst">&#123;<span class="built_in">len</span>(py_files)&#125;</span> 个&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;测试文件: <span class="subst">&#123;<span class="built_in">len</span>(test_files)&#125;</span> 个&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;配置文件: <span class="subst">&#123;<span class="built_in">len</span>(config_files)&#125;</span> 个&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总代码行数: <span class="subst">&#123;total_lines:,&#125;</span> 行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">analyze_project(<span class="string">&quot;/path/to/your/project&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景二：智能文件整理器"><a href="#场景二：智能文件整理器" class="headerlink" title="场景二：智能文件整理器"></a>场景二：智能文件整理器</h3><p>整理下载文件夹，按文件类型自动分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">organize_downloads</span>(<span class="params">downloads_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;智能整理下载文件夹&quot;&quot;&quot;</span></span><br><span class="line">    downloads = Path(downloads_dir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义文件类型映射</span></span><br><span class="line">    type_mapping = &#123;</span><br><span class="line">        <span class="string">&#x27;images&#x27;</span>: [<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.gif&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span>, <span class="string">&#x27;.svg&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;documents&#x27;</span>: [<span class="string">&#x27;.pdf&#x27;</span>, <span class="string">&#x27;.doc&#x27;</span>, <span class="string">&#x27;.docx&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.md&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;videos&#x27;</span>: [<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>, <span class="string">&#x27;.mkv&#x27;</span>, <span class="string">&#x27;.mov&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;music&#x27;</span>: [<span class="string">&#x27;.mp3&#x27;</span>, <span class="string">&#x27;.wav&#x27;</span>, <span class="string">&#x27;.flac&#x27;</span>, <span class="string">&#x27;.m4a&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;archives&#x27;</span>: [<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.rar&#x27;</span>, <span class="string">&#x27;.7z&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建分类文件夹</span></span><br><span class="line">    <span class="keyword">for</span> folder_name <span class="keyword">in</span> type_mapping.keys():</span><br><span class="line">        (downloads / folder_name).mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始整理文件</span></span><br><span class="line">    moved_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> downloads.iterdir():</span><br><span class="line">        <span class="keyword">if</span> file_path.is_file():</span><br><span class="line">            file_ext = file_path.suffix.lower()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到对应的分类</span></span><br><span class="line">            <span class="keyword">for</span> folder_name, extensions <span class="keyword">in</span> type_mapping.items():</span><br><span class="line">                <span class="keyword">if</span> file_ext <span class="keyword">in</span> extensions:</span><br><span class="line">                    new_path = downloads / folder_name / file_path.name</span><br><span class="line">                    file_path.rename(new_path)</span><br><span class="line">                    moved_count += <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot; <span class="subst">&#123;file_path.name&#125;</span> → <span class="subst">&#123;folder_name&#125;</span>/&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;整理完成！共移动了 <span class="subst">&#123;moved_count&#125;</span> 个文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例  </span></span><br><span class="line">organize_downloads(Path.home() / <span class="string">&quot;Downloads&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景三：路径解析"><a href="#场景三：路径解析" class="headerlink" title="场景三：路径解析"></a>场景三：路径解析</h3><p>解析文件路径的各个组成部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_file_path</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;详细分析文件路径组成&quot;&quot;&quot;</span></span><br><span class="line">    path = Path(file_path)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;路径分析：<span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所在目录: <span class="subst">&#123;path.parent&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;完整文件名: <span class="subst">&#123;path.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;主文件名: <span class="subst">&#123;path.stem&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件扩展名: <span class="subst">&#123;path.suffix&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;是否绝对路径: <span class="subst">&#123;path.is_absolute()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示目录层级</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;目录层级:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, parent <span class="keyword">in</span> <span class="built_in">enumerate</span>(path.parents):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  级别 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;parent&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">analyze_file_path(<span class="string">&quot;/xxx/utils/helper.py&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景四：配置文件管理器"><a href="#场景四：配置文件管理器" class="headerlink" title="场景四：配置文件管理器"></a>场景四：配置文件管理器</h3><p>优雅地处理应用配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigManager</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;配置文件管理器&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app_name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.app_name = app_name</span><br><span class="line">        <span class="comment"># 创建配置目录</span></span><br><span class="line">        <span class="variable language_">self</span>.config_dir = Path.home() / <span class="string">f&quot;.<span class="subst">&#123;app_name&#125;</span>&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.config_dir.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义配置文件路径</span></span><br><span class="line">        <span class="variable language_">self</span>.config_file = <span class="variable language_">self</span>.config_dir / <span class="string">&quot;config.json&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.log_file = <span class="variable language_">self</span>.config_dir / <span class="string">&quot;app.log&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_config</span>(<span class="params">self, config_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;保存配置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> json</span><br><span class="line">        <span class="variable language_">self</span>.config_file.write_text(</span><br><span class="line">            json.dumps(config_data, indent=<span class="number">2</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;配置已保存到: <span class="subst">&#123;self.config_file&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_config</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载配置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.config_file.exists():</span><br><span class="line">            <span class="keyword">import</span> json</span><br><span class="line">            <span class="keyword">return</span> json.loads(<span class="variable language_">self</span>.config_file.read_text())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_message</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入日志&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">        timestamp = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        log_entry = <span class="string">f&quot;[<span class="subst">&#123;timestamp&#125;</span>] <span class="subst">&#123;message&#125;</span>\n&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 追加写入日志</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.log_file.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(log_entry)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">config_mgr = ConfigManager(<span class="string">&quot;myapp&quot;</span>)</span><br><span class="line">config_mgr.save_config(&#123;<span class="string">&quot;theme&quot;</span>: <span class="string">&quot;dark&quot;</span>, <span class="string">&quot;language&quot;</span>: <span class="string">&quot;zh-CN&quot;</span>&#125;)</span><br><span class="line">config_mgr.log_message(<span class="string">&quot;应用启动&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>从os.path到pathlib，这不仅仅是一个库的替换，更是Python在”优雅”和”可读性”道路上的又一次进化。</p><p>下次当你需要处理文件路径时，不妨试试pathlib。相信我，一旦习惯了这种优雅的写法，你就再也回不去os.path的繁琐世界了。</p><hr><p><strong>参考资料</strong>：</p><ul><li><a href="https://docs.python.org/3/library/pathlib.html">官方文档</a>  </li><li><a href="https://peps.python.org/pep-0428/">PEP 428: The pathlib module</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常Python开发中，文件路径操作是绕不开的话题。你是否还在使用&lt;code&gt;os.path.join()&lt;/code&gt;拼接路径？是否还在为Windows和Linux的路径分隔符头疼？是否期待一种更Pythonic的方式来处理路径？&lt;/p&gt;
&lt;p&gt;先来看一个直观的对比，即</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python库" scheme="http://sswfive.xyz/tags/python%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【数组】</title>
    <link href="http://sswfive.xyz/2025/09/10/dsa/250910-array/"/>
    <id>http://sswfive.xyz/2025/09/10/dsa/250910-array/</id>
    <published>2025-09-10T13:06:01.000Z</published>
    <updated>2025-10-22T17:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念与原理"><a href="#概念与原理" class="headerlink" title="概念与原理"></a>概念与原理</h2><p>数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组可以分为静态数组和动态数组两大类。</p><ul><li>静态数组：是一块连续的内存空间，我们可以通过索引来访问这块内存空间中的元素，这也是数组的原始形态。</li><li>动态数组：是编程语言为了方便开发者使用，在静态数组的基础上添加了一些常用的API，如<code>push, insert, remove</code> 等方法,这些API可以让我们更方便的操作数组元素，不用自己写代码去实现。<br><img src="http://cdn.sswfive.xyz/2025-10/251023010055678_1761152455685.png" alt="251023010055678.png"></li></ul><h2 id="数组的常用操作（增删改查）"><a href="#数组的常用操作（增删改查）" class="headerlink" title="数组的常用操作（增删改查）"></a>数组的常用操作（增删改查）</h2><blockquote><p>数据结构的职责就是增删改查，再无其他。</p></blockquote><p><img src="http://cdn.sswfive.xyz/2025-10/251023013110619_1761154270626.png" alt="251023013110619.png"></p><h2 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h2><p><strong>适合查询多修改少的操作，在使用时需要警惕数据访问越界的问题。</strong>。</p><ul><li>查询效率快，因为数组的结构特点是，根据偏移量（下标）访问速度快，所以随机访问性好。</li><li>插入、删除效率低，由于其是连续的线性结构，在删除和插入时通常都会伴随着数据的搬迁。</li></ul><h2 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h2><p>在考虑性能时，通常需要去分析不同API的复杂度；另外，数组和链表通常起到了互补的作用，来应对不同的数据处理场景。数组适合查询，链表适合插入和删除。以下列出了常规情况下不同的API的时间复杂度，但具体问题还需要具体分析。</p><ul><li>查询(Access)：<ul><li><strong>根据下标随机访问的时间复杂度：O(1)</strong></li></ul></li><li>插入(Insert)：<ul><li>最好情况（末尾插入）时间复杂度：O(1)</li><li>最坏情况（头部插入）时间复杂度：O(n)</li><li><strong>平均情况时间复杂度：(1+2+…n)&#x2F;n &#x3D; O(n)</strong></li></ul></li><li>删除(Delete)：<ul><li>最好情况（末尾删除）时间复杂度：O(1)</li><li>最坏情况（开头删除）时间复杂度：O(n)</li><li><strong>平均情况时间复杂度：O(n)</strong></li></ul></li><li>修改(Update)：<ul><li>给定指定索引，修改索引对应的元素的值，时间复杂度O(1)。</li></ul></li></ul><h2 id="数组典型应用"><a href="#数组典型应用" class="headerlink" title="数组典型应用"></a>数组典型应用</h2><ul><li><strong>随机访问</strong>：如果想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li><li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li><li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li><li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li><li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li></ul><h2 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h2><h3 id="实践一：插入操作优化"><a href="#实践一：插入操作优化" class="headerlink" title="实践一：插入操作优化"></a>实践一：插入操作优化</h3><p>在数组的k个位置插入一个数据，若不涉及排序操作，只被用来存储数据的集合，比较优选的方案是，将第k个位置的数据移动到数据的末尾，再将需要的数据插入到第k位，这样就避免了其他数据的移动，从而提高了插入效率，且时间复杂度被降到O(1).<br>快排的实现思路就是如此。</p><h3 id="实践二：删除操作优化"><a href="#实践二：删除操作优化" class="headerlink" title="实践二：删除操作优化"></a>实践二：删除操作优化</h3><p>通常情况下，删除第k个位置的数据，为了内存的连续性，k后面的数据都需要向前搬迁。<br>但在不考虑数据的连续性的场景中，则可以将多次删除操作集中在一起操作，从而提升删除效率。具体的做法就是：将需要删除的元素进行标记，并不执行真正的删除操作，当数据没有了更多存储空间时，再触发一次真正的删除操作，这样就能减少因为数据搬迁的次数。<br>JVM的标记清除垃圾回收算法就是此思想。</p><h3 id="实践三：高级编程语言中封装的容器能否替代数组？"><a href="#实践三：高级编程语言中封装的容器能否替代数组？" class="headerlink" title="实践三：高级编程语言中封装的容器能否替代数组？"></a>实践三：高级编程语言中封装的容器能否替代数组？</h3><p>如：python中的List， java中的ArrayList、C++中vector等；<br>通常需要根据实际情况来考虑，通常的关注点是性能方面的，比如说：</p><ul><li>若不是特别关注性能，使用编程语言中封装的对象即可，因为这些容器封装了常用操作，牺牲了性能，但让使用变得简单，可用于日常的业务开发</li><li>若特别关注性能，建议使用原生数组，因为原生性能好，但使用起来相对比较繁琐，一般用于底层框架的开发，如网络库的开发</li></ul><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h3 id="数组题目的解法技巧-双指针技巧"><a href="#数组题目的解法技巧-双指针技巧" class="headerlink" title="数组题目的解法技巧-&gt;双指针技巧"></a>数组题目的解法技巧-&gt;双指针技巧</h3><p>在数组中没有真正意义上的指针，通常把索引当做数组中的指针，</p><ul><li>左右指针：两个指针相向而行或者相背而行；</li><li>快慢指针：两个指针同向而行，一快一慢；</li></ul><h4 id="技巧一、快慢指针"><a href="#技巧一、快慢指针" class="headerlink" title="技巧一、快慢指针"></a>技巧一、快慢指针</h4><p>应用场景：</p><ul><li>应用在【原地修改数组】类型的算法题目上</li><li>应用在【滑动窗口】类型的算法题目上<br>实践思路；</li><li>让慢指针走在后面，快指针走在前面探路，在根据题目中的要求，写出相关判断条件。</li><li>对于滑动窗口的类型而言：慢指针在后，快指针在前，两个指针中间的部分就是【窗口】，算法通过扩大或缩小窗口来解决相关问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 框架Demo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    fast, slow = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        fast += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h4 id="技巧二、左右指针"><a href="#技巧二、左右指针" class="headerlink" title="技巧二、左右指针"></a>技巧二、左右指针</h4><p>常用算法: 二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 框架Demo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 一左一右两个指针相向而行</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right + left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念与原理&quot;&gt;&lt;a href=&quot;#概念与原理&quot; class=&quot;headerlink&quot; title=&quot;概念与原理&quot;&gt;&lt;/a&gt;概念与原理&lt;/h2&gt;&lt;p&gt;数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组可以分为静态数组和</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python异步编程十年沉浮：且看3.14版本重要更新</title>
    <link href="http://sswfive.xyz/2025/09/08/tech/python/250907-py-async-challenges/"/>
    <id>http://sswfive.xyz/2025/09/08/tech/python/250907-py-async-challenges/</id>
    <published>2025-09-08T00:08:59.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周读到了一篇文章《<a href="https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html">Python has had async for 10 years – why isn’t it more popular?</a>》，深有感触，文章提出了一个值得深思的问题：Python 早在 2015 年就引入了 <code>async</code> 和 <code>await</code> 关键字，距今已近十年，为什么异步编程在 Python 社区中的普及仍不及预期？</p><p>这篇文章中指出了三大困境，也让我这个从Python2.7时代走过来的开发者深有共鸣。今天就结合我的实践经历，聊聊Python异步编程的过去、现在和未来。</p><h2 id="异步编程的三座大山"><a href="#异步编程的三座大山" class="headerlink" title="异步编程的三座大山"></a>异步编程的三座大山</h2><h3 id="困境一：适用场景受限"><a href="#困境一：适用场景受限" class="headerlink" title="困境一：适用场景受限"></a><strong>困境一：适用场景受限</strong></h3><p>asyncio 在网络 I&#x2F;O 方面表现出色，但对其他类型的 I&#x2F;O 支持有限。即使是看似异步的文件操作，底层仍然依赖线程池来模拟异步行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看似异步，实际仍使用线程池</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&#x27;large_file.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = <span class="keyword">await</span> f.read()  <span class="comment"># 底层依然是线程池实现</span></span><br></pre></td></tr></table></figure><p>生产环境中出于安全考虑，往往限制使用 <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a> 等系统级异步机制，进一步缩小了 asyncio 的适用范围。</p><h3 id="困境二：GIL-的根本限制"><a href="#困境二：GIL-的根本限制" class="headerlink" title="困境二：GIL 的根本限制"></a><strong>困境二：GIL 的根本限制</strong></h3><p>无论异步代码执行得多么高效，都无法突破 GIL（全局解释器锁）的天花板。async&#x2F;await 虽能优化 I&#x2F;O 密集型任务，但对 CPU 密集型操作帮助有限。</p><p>更麻烦的是错误处理——忘记 <code>await</code> 可能导致协程静默失败，这种隐形问题调试起来很棘手。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单次调用性能相同</span></span><br><span class="line">sync_result = get_data_sync()        <span class="comment"># 耗时 1 秒</span></span><br><span class="line">async_result = <span class="keyword">await</span> get_data_async() <span class="comment"># 同样耗时 1 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有在并发场景下异步才显示优势</span></span><br><span class="line">results = <span class="keyword">await</span> asyncio.gather(*[</span><br><span class="line">    get_data_async() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">])  <span class="comment"># 总耗时约 1 秒（而非 10 秒）</span></span><br></pre></td></tr></table></figure><h3 id="困境三：双-API-的维护负担"><a href="#困境三：双-API-的维护负担" class="headerlink" title="困境三：双 API 的维护负担"></a><strong>困境三：双 API 的维护负担</strong></h3><p>为了兼容性，开发者往往需要同时维护同步和异步两套 API，大大增加了开发和维护成本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步版本</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_records</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Record]:</span><br><span class="line">    <span class="keyword">return</span> fetch_from_database(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版本 - API 设计不一致</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_user_records</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Record]:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> async_fetch_from_database(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时的心理负担：需要记住哪些方法需要 await</span></span><br><span class="line">user.name                                <span class="comment"># 普通属性</span></span><br><span class="line">records = <span class="keyword">await</span> user.get_user_records()  <span class="comment"># 异步方法</span></span><br></pre></td></tr></table></figure><p>从魔法方法无法异步化，到属性访问方式的不一致，再到代码重复和测试复杂度增加，都让开发者望而却步。</p><h2 id="异步编程的演进之路"><a href="#异步编程的演进之路" class="headerlink" title="异步编程的演进之路"></a>异步编程的演进之路</h2><h3 id="什么是异步编程？"><a href="#什么是异步编程？" class="headerlink" title="什么是异步编程？"></a>什么是异步编程？</h3><p>异步编程是一种非阻塞的编程范式，允许程序在等待某些操作（如I&#x2F;O）完成时继续执行其他任务，而不是干等着。</p><p>同步 VS 异步的直观对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步版本 - 顺序执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_demo</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name, delay</span>):</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 完成&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    task(<span class="string">&quot;任务1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    task(<span class="string">&quot;任务2&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    task(<span class="string">&quot;任务3&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;同步总耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版本 - 并发执行  </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_demo</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name, delay</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 完成&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        task(<span class="string">&quot;任务1&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        task(<span class="string">&quot;任务2&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        task(<span class="string">&quot;任务3&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异步总耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行对比</span></span><br><span class="line">sync_demo()    <span class="comment"># 输出：总耗时约3秒</span></span><br><span class="line">asyncio.run(async_demo())  <span class="comment"># 输出：总耗时约1秒</span></span><br></pre></td></tr></table></figure><h3 id="三种实现方式的变迁"><a href="#三种实现方式的变迁" class="headerlink" title="三种实现方式的变迁"></a>三种实现方式的变迁</h3><h4 id="方式一：回调函数（Callback）——原始方案"><a href="#方式一：回调函数（Callback）——原始方案" class="headerlink" title="方式一：回调函数（Callback）——原始方案"></a>方式一：回调函数（Callback）——原始方案</h4><p>兼容性好，但代码难以维护（坊间流传一个词：回调地狱）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;回调函数示例 - 早期的异步解决方案&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download_complete</span>(<span class="params">future</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;下载完成时的回调函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;下载完成，状态码: <span class="subst">&#123;result.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;获取数据长度: <span class="subst">&#123;<span class="built_in">len</span>(result.text)&#125;</span> 字符&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;下载失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始回调函数示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 提交多个任务</span></span><br><span class="line">        futures = []</span><br><span class="line">        urls = [</span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/2&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/1&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            future = executor.submit(requests.get, url)</span><br><span class="line">            future.add_done_callback(download_complete)</span><br><span class="line">            futures.append(future)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;回调函数示例总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">callback_example()</span><br></pre></td></tr></table></figure><h4 id="方式二：生成器（Generator）—过渡方案"><a href="#方式二：生成器（Generator）—过渡方案" class="headerlink" title="方式二：生成器（Generator）—过渡方案"></a>方式二：生成器（Generator）—过渡方案</h4><p>虽然避免了回调地狱，代码变的更清晰了，但需要手动调度，实现变的更复杂了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成器实现协程 - Python 3.4时代的解决方案&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">async_sleep</span>(<span class="params">delay</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟异步sleep&quot;&quot;&quot;</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">while</span> time.time() - start &lt; delay:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;休眠了<span class="subst">&#123;delay&#125;</span>秒&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_coroutines</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行多个协程&quot;&quot;&quot;</span></span><br><span class="line">        tasks = [async_sleep(<span class="number">1</span>), async_sleep(<span class="number">2</span>), async_sleep(<span class="number">1</span>)]</span><br><span class="line">        results = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> tasks:</span><br><span class="line">            current = tasks.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">next</span>(current)</span><br><span class="line">                tasks.append(current)  <span class="comment"># 如果还没完成，放回队列</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                results.append(e.value)  <span class="comment"># 协程完成，获取返回值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始生成器协程示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    results = run_coroutines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成器协程结果: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成器示例总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">generator_example()</span><br></pre></td></tr></table></figure><h4 id="方式三：Async-Await——现代方案"><a href="#方式三：Async-Await——现代方案" class="headerlink" title="方式三：Async&#x2F;Await——现代方案"></a>方式三：Async&#x2F;Await——现代方案</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">modern_async_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;现代async/await示例&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url, delay</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟异步数据获取&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始获取 <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;完成获取 <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> 的数据（延迟<span class="subst">&#123;delay&#125;</span>秒）&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始现代async/await示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发执行多个异步任务</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api1.com&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api2.com&quot;</span>, <span class="number">2</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api3.com&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api4.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有任务完成结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  - <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;现代async/await总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">asyncio.run(modern_async_example())</span><br></pre></td></tr></table></figure><h2 id="asyncio：现代异步解决方案"><a href="#asyncio：现代异步解决方案" class="headerlink" title="asyncio：现代异步解决方案"></a>asyncio：现代异步解决方案</h2><p>异步编程的核心优势在于：<strong>当一个协程等待 I&#x2F;O 操作时，事件循环可以切换执行其他协程，从而提高整体吞吐量</strong>。</p><h3 id="asyncio的核心概念"><a href="#asyncio的核心概念" class="headerlink" title="asyncio的核心概念"></a>asyncio的核心概念</h3><p><strong>协程（Coroutine）</strong>：异步函数</p><ul><li>是异步编程的基础模块，使用<code>async def</code>定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始向 <span class="subst">&#123;name&#125;</span> 问好&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你好, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 的问候完成&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行协程的三种方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 方式1: 直接await</span></span><br><span class="line">    result1 = <span class="keyword">await</span> say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方式2: 使用asyncio.create_task</span></span><br><span class="line">    task = asyncio.create_task(say_hello(<span class="string">&quot;Bob&quot;</span>))</span><br><span class="line">    result2 = <span class="keyword">await</span> task</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方式3: 使用asyncio.gather并发执行</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        say_hello(<span class="string">&quot;Charlie&quot;</span>),</span><br><span class="line">        say_hello(<span class="string">&quot;David&quot;</span>),</span><br><span class="line">        say_hello(<span class="string">&quot;Eve&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行主函数</span></span><br><span class="line">results = asyncio.run(main())</span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure><p><strong>事件循环（Event Loop）</strong>：</p><ul><li>异步引擎，也是asyncio的核心，负责调度和执行协程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">demo_event_loop</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;事件循环demo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前时间: <span class="subst">&#123;loop.time()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安排回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;回调函数被调用: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安排定时回调</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    loop.call_soon(callback, <span class="string">&quot;立即&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;演示结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(demo_event_loop())</span><br></pre></td></tr></table></figure><p><strong>任务（Task）</strong>：</p><ul><li>协程的包装器，用于并发执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_management</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;任务管理演示&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">name, seconds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 开始工作&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(seconds)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 工作完成&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 工作了<span class="subst">&#123;seconds&#125;</span>秒&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建多个任务</span></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人1&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人2&quot;</span>, <span class="number">1</span>)),</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人3&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有任务已创建，开始并发执行...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有任务完成: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 任务状态检查</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;task.get_name()&#125;</span>: 完成=<span class="subst">&#123;task.done()&#125;</span>, 结果=<span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(task_management())</span><br></pre></td></tr></table></figure><p><strong>Future对象</strong>：</p><ul><li>代表一个尚未完成的计算结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">future_demo</span>():</span><br><span class="line">    <span class="comment"># 创建Future对象</span></span><br><span class="line">    future = asyncio.Future()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Future状态: <span class="subst">&#123;future.done()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置结果（通常在别处）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_result</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;设置Future结果&quot;</span>)</span><br><span class="line">        future.set_result(<span class="string">&quot;完成!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2秒后设置结果</span></span><br><span class="line">    asyncio.get_event_loop().call_later(<span class="number">2</span>, set_result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待Future完成</span></span><br><span class="line">    result = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Future状态: <span class="subst">&#123;future.done()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">asyncio.run(future_demo())</span><br></pre></td></tr></table></figure><h3 id="低级API-vs-高级API对比"><a href="#低级API-vs-高级API对比" class="headerlink" title="低级API vs 高级API对比"></a>低级API vs 高级API对比</h3><p>更全面的低级API的用法请：<a href="https://docs.python.org/zh-cn/3.13/library/asyncio-llapi-index.html">点进前往</a></p><p>更全面的高级API的用法请：<a href="https://docs.python.org/zh-cn/3.13/library/asyncio-api-index.html">点进前往</a></p><table><thead><tr><th align="left">类别</th><th align="left">API名称</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left"><strong>低级API</strong></td><td align="left"><code>loop.create_future()</code></td><td align="left">创建Future对象</td><td align="left">需要精细控制时</td></tr><tr><td align="left"></td><td align="left"><code>loop.call_soon()</code></td><td align="left">立即调度回调</td><td align="left">优先级高的任务</td></tr><tr><td align="left"></td><td align="left"><code>loop.call_later()</code></td><td align="left">延迟调度</td><td align="left">定时任务</td></tr><tr><td align="left"></td><td align="left"><code>loop.run_in_executor()</code></td><td align="left">在线程池中运行</td><td align="left">CPU密集型任务</td></tr><tr><td align="left"><strong>高级API</strong></td><td align="left"><code>asyncio.run()</code></td><td align="left">运行协程</td><td align="left">程序入口点</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.create_task()</code></td><td align="left">创建任务</td><td align="left">并发执行协程</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.gather()</code></td><td align="left">并发运行多个任务</td><td align="left">等待多个任务完成</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.wait()</code></td><td align="left">更灵活的任务等待</td><td align="left">需要超时或优先完成时</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.sleep()</code></td><td align="left">异步等待</td><td align="left">模拟I&#x2F;O操作</td></tr></tbody></table><h3 id="asyncio高级特性"><a href="#asyncio高级特性" class="headerlink" title="asyncio高级特性"></a>asyncio高级特性</h3><ul><li><strong>信号量控制并发数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_concurrency</span>():</span><br><span class="line">    semaphore = asyncio.Semaphore(<span class="number">3</span>)  <span class="comment"># 最大并发数3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_task</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;i&#125;</span> 开始&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;i&#125;</span> 完成&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建10个任务，但最多同时执行3个</span></span><br><span class="line">    tasks = [limited_task(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有任务完成: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(limited_concurrency())</span><br></pre></td></tr></table></figure><ul><li><strong>超时与取消控制</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">timeout_cancel_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;超时和取消demo&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">long_running_task</span>(<span class="params">name, seconds</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 开始运行&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(seconds)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 正常完成&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 成功&quot;</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 被取消&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 超时控制</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(</span><br><span class="line">            long_running_task(<span class="string">&quot;任务A&quot;</span>, <span class="number">5</span>), </span><br><span class="line">            timeout=<span class="number">2.0</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;任务A结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务A超时&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 手动取消</span></span><br><span class="line">    task_b = asyncio.create_task(long_running_task(<span class="string">&quot;任务B&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    task_b.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task_b</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务B已取消&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(timeout_cancel_demo())</span><br></pre></td></tr></table></figure><ul><li><strong>队列处理</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">queue_example</span>():</span><br><span class="line">    queue = asyncio.Queue(maxsize=<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(random.random())</span><br><span class="line">            <span class="keyword">await</span> queue.put(<span class="string">f&quot;消息 <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;生产: 消息 <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = <span class="keyword">await</span> queue.get()</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(random.random() * <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">            queue.task_done()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动生产者和消费者</span></span><br><span class="line">    producer_task = asyncio.create_task(producer())</span><br><span class="line">    consumer_task = asyncio.create_task(consumer())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> producer_task</span><br><span class="line">    <span class="keyword">await</span> queue.join()  <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    consumer_task.cancel()</span><br><span class="line"></span><br><span class="line">asyncio.run(queue_example())</span><br></pre></td></tr></table></figure><h3 id="常用场景的代码框架"><a href="#常用场景的代码框架" class="headerlink" title="常用场景的代码框架"></a>常用场景的代码框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">advanced_patterns</span>():</span><br><span class="line">    <span class="comment"># 1. 限制并发数</span></span><br><span class="line">    semaphore = asyncio.Semaphore(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_request</span>(<span class="params">url</span>):</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 超时控制</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(</span><br><span class="line">            limited_request(<span class="string">&#x27;https://httpbin.org/delay/5&#x27;</span>), </span><br><span class="line">            timeout=<span class="number">3.0</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 任务取消</span></span><br><span class="line">    task = asyncio.create_task(limited_request(<span class="string">&#x27;https://httpbin.org/delay/10&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务被取消&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="实践中的挑战与解决方案"><a href="#实践中的挑战与解决方案" class="headerlink" title="实践中的挑战与解决方案"></a>实践中的挑战与解决方案</h2><h3 id="识别适合异步的场景"><a href="#识别适合异步的场景" class="headerlink" title="识别适合异步的场景"></a>识别适合异步的场景</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适合异步：网络 I/O 密集型</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">good_async_example</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_api_data</span>(<span class="params">api_url</span>):</span><br><span class="line">        <span class="comment"># 模拟网络请求</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;数据来自 <span class="subst">&#123;api_url&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 并发执行多个网络请求</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        fetch_api_data(<span class="string">&quot;api1&quot;</span>),</span><br><span class="line">        fetch_api_data(<span class="string">&quot;api2&quot;</span>), </span><br><span class="line">        fetch_api_data(<span class="string">&quot;api3&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异步网络请求耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)  <span class="comment"># 约1秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不适合异步：CPU 密集型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bad_async_example</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>(<span class="params">n</span>):</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total += i * i</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 即使用异步包装，由于 GIL 限制，性能提升有限</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_cpu_task</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> cpu_intensive_task(n)</span><br><span class="line"></span><br><span class="line">asyncio.run(good_async_example())</span><br></pre></td></tr></table></figure><h3 id="混合使用异步与执行器"><a href="#混合使用异步与执行器" class="headerlink" title="混合使用异步与执行器"></a>混合使用异步与执行器</h3><p>针对 GIL 限制，我们可以结合异步和执行器来解决不同类型的任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hybrid_solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cpu_task</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;CPU 密集型任务&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">blocking_io_task</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;阻塞 I/O 任务&quot;&quot;&quot;</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;阻塞任务完成&quot;</span></span><br><span class="line">    </span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># CPU 密集型任务使用进程池</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        cpu_futures = [</span><br><span class="line">            loop.run_in_executor(process_pool, cpu_task, <span class="number">100000</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 阻塞 I/O 使用线程池  </span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> thread_pool:</span><br><span class="line">        io_futures = [</span><br><span class="line">            loop.run_in_executor(thread_pool, blocking_io_task)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发执行所有任务</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    cpu_results = <span class="keyword">await</span> asyncio.gather(*cpu_futures)</span><br><span class="line">    io_results = <span class="keyword">await</span> asyncio.gather(*io_futures)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;混合方案总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(hybrid_solution())</span><br></pre></td></tr></table></figure><h3 id="统一API设计模式"><a href="#统一API设计模式" class="headerlink" title="统一API设计模式"></a>统一API设计模式</h3><p>针对双 API 维护问题，这里提供一个实用的解决方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, Awaitable, overload</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnifiedDataService</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统一的数据服务，支持同步和异步调用&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="built_in">str</span>: ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @overload  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">True</span></span>) -&gt; Awaitable[<span class="built_in">str</span>]: ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">Union</span>[<span class="built_in">str</span>, Awaitable[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据 async_mode 参数决定返回同步还是异步结果&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> async_mode:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._async_get_data(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._sync_get_data(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sync_get_data</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;同步获取: <span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_async_get_data</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;异步获取: <span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">service = UnifiedDataService()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步调用</span></span><br><span class="line">sync_result = service.get_data(<span class="string">&quot;key1&quot;</span>, async_mode=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(sync_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_async</span>():</span><br><span class="line">    async_result = <span class="keyword">await</span> service.get_data(<span class="string">&quot;key1&quot;</span>, async_mode=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(async_result)</span><br><span class="line"></span><br><span class="line">asyncio.run(test_async())</span><br></pre></td></tr></table></figure><h2 id="持续关注：Python-3-14-的革命性变化"><a href="#持续关注：Python-3-14-的革命性变化" class="headerlink" title="持续关注：Python 3.14 的革命性变化"></a>持续关注：Python 3.14 的革命性变化</h2><p>正如文章中所预言的，Python 3.14 带来了两个具有历史意义的并发编程突破，有望彻底改变当前的格局。</p><h3 id="PEP-779-Free-Threading-的历史性突破"><a href="#PEP-779-Free-Threading-的历史性突破" class="headerlink" title="PEP 779: Free-Threading 的历史性突破"></a>PEP 779: Free-Threading 的历史性突破</h3><p><strong>核心改变</strong>：移除 GIL 限制，实现真正的多线程并行执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Free-Threading 模式下，这些操作可以真正并行</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>(<span class="params">name, n</span>):</span><br><span class="line">    total = <span class="built_in">sum</span>(i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;name&#125;</span> 完成: <span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前受 GIL 限制，现在可以真正并行</span></span><br><span class="line">threads = []</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    thread = threading.Thread(</span><br><span class="line">        target=cpu_intensive_task, </span><br><span class="line">        args=[<span class="string">f&quot;Thread-<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="number">1000000</span>]</span><br><span class="line">    )</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="comment"># Free-Threading 模式下，4个线程可以真正并行</span></span><br></pre></td></tr></table></figure><p>重大意义：</p><ul><li>性能革命：CPU 密集型任务可以充分利用多核处理器</li><li>降低复杂性：某些场景下线程可能比协程更简单易用</li><li>向后兼容：现有异步代码仍然有效</li></ul><h3 id="PEP-734-多解释器支持"><a href="#PEP-734-多解释器支持" class="headerlink" title="PEP 734: 多解释器支持"></a>PEP 734: 多解释器支持</h3><p><strong>核心特性</strong>：每个解释器拥有独立的全局状态，提供更安全的并行执行环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例（PEP 734 实现）</span></span><br><span class="line"><span class="keyword">import</span> interpreters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建独立的解释器实例</span></span><br><span class="line">interp1 = interpreters.create()</span><br><span class="line">interp2 = interpreters.create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不同解释器中执行代码，完全隔离</span></span><br><span class="line">code1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def cpu_task():</span></span><br><span class="line"><span class="string">    return sum(i*i for i in range(1000000))</span></span><br><span class="line"><span class="string">result = cpu_task()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">async def io_task():</span></span><br><span class="line"><span class="string">    await asyncio.sleep(1)</span></span><br><span class="line"><span class="string">    return &quot;IO task completed&quot;</span></span><br><span class="line"><span class="string">result = asyncio.run(io_task())</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行执行，每个解释器独立运行</span></span><br><span class="line">interp1.<span class="built_in">exec</span>(code1)</span><br><span class="line">interp2.<span class="built_in">exec</span>(code2)</span><br></pre></td></tr></table></figure><h3 id="对异步编程的影响"><a href="#对异步编程的影响" class="headerlink" title="对异步编程的影响"></a>对异步编程的影响</h3><p><strong>竞争与互补的新格局</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 场景分析：不同工作负载的最优选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># I/O 密集型 - 异步仍然是最佳选择</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">io_heavy_work</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [session.get(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU 密集型 - Free-Threading 提供新选择  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_heavy_work</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(compute, data) <span class="keyword">for</span> data <span class="keyword">in</span> datasets]</span><br><span class="line">        <span class="keyword">return</span> [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> futures]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合工作负载 - 多解释器方案</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hybrid_work</span>():</span><br><span class="line">    io_interp = interpreters.create()</span><br><span class="line">    cpu_interp = interpreters.create()</span><br><span class="line">    <span class="comment"># 不同类型的任务在不同解释器中执行</span></span><br></pre></td></tr></table></figure><h2 id="项目选型的一些建议"><a href="#项目选型的一些建议" class="headerlink" title="项目选型的一些建议"></a>项目选型的一些建议</h2><p><strong>立即可行的方案</strong>：</p><ol><li><strong>I&#x2F;O 密集型项目</strong>：继续使用 FastAPI + aiohttp 异步方案</li><li><strong>CPU 密集型项目</strong>：采用多进程方案或等待 Free-Threading 稳定</li><li><strong>混合负载项目</strong>：考虑 asyncio + 执行器的混合方案</li></ol><p><strong>Web 框架推荐</strong>：</p><ul><li>新项目：FastAPI（异步优先）&gt; Django 4.1+（异步支持）</li><li>现有项目：渐进式引入异步，在 I&#x2F;O 边界使用</li></ul><p><strong>HTTP 客户端推荐</strong>：</p><ul><li>异步场景：aiohttp &gt; httpx（异步模式）</li><li>同步场景：httpx（同步模式）&gt; requests</li></ul><h2 id="异步编程的未来可期"><a href="#异步编程的未来可期" class="headerlink" title="异步编程的未来可期"></a>异步编程的未来可期</h2><p>异步编程就是一把双刃剑——用对了场景能大幅提升性能，用错了反而增加复杂度，开篇引入的那边文章就是很好的揭示了这一点。</p><ul><li><strong>当下</strong>：在适合的场景（Web API、爬虫、实时应用）继续使用异步编程</li><li><strong>未来</strong>：关注 Python 3.14+ 的发展，准备拥抱多样化的并发解决方案</li></ul><p>技术选型没有银弹，只有最适合的方案。随着 Python 并发能力的不断增强，我相信，未来的异步编程会更加简单、强大和普及。</p><hr><p><strong>参考资料</strong>：</p><ul><li><a href="https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html">Python has had async for 10 years – why isn’t it more popular?</a> - Anthony Shaw</li><li><a href="https://peps.python.org/pep-0703/">PEP 703: Making the Global Interpreter Lock Optional</a></li><li><a href="https://peps.python.org/pep-0734/">PEP 734: Multiple Interpreters in the Stdlib</a></li><li><a href="https://docs.python.org/3/library/asyncio.html">asyncio 官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周读到了一篇文章《&lt;a href=&quot;https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html&quot;&gt;Python has had async for 10 years – why i</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python工程实践" scheme="http://sswfive.xyz/tags/python%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="异步编程" scheme="http://sswfive.xyz/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的基本知识</title>
    <link href="http://sswfive.xyz/2025/09/02/dsa/250902-data-structure-basic/"/>
    <id>http://sswfive.xyz/2025/09/02/dsa/250902-data-structure-basic/</id>
    <published>2025-09-02T08:36:01.000Z</published>
    <updated>2025-10-22T17:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构的分类"><a href="#数据结构的分类" class="headerlink" title="数据结构的分类"></a>数据结构的分类</h2><p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从<strong>逻辑结构</strong>和<strong>物理结构</strong>两个维度进行分类。</p><h3 id="逻辑结构：线性与非线性"><a href="#逻辑结构：线性与非线性" class="headerlink" title="逻辑结构：线性与非线性"></a>逻辑结构：线性与非线性</h3><p>逻辑结构主要描述的是数据元素之间的逻辑关系，它可以分为<strong>线性</strong>和<strong>非线性</strong>两大类。简言之，线性结构指数据在逻辑关系上呈线性排列，非线性结构则呈非线性排列。</p><ul><li>线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li><li>非线性数据结构：树、堆、图、哈希表。<br>非线性结构又可以进一步分为<strong>树形结构</strong>和<strong>网状结构</strong>：</li><li>树形结构：树、堆、哈希表、元素之间一对多的关系</li><li>网状结构：图，元素之间是多对多的关系</li></ul><h3 id="物理结构：连续和分散"><a href="#物理结构：连续和分散" class="headerlink" title="物理结构：连续和分散"></a>物理结构：连续和分散</h3><p>物理结构反映了数据在计算机<strong>内存中的存储方式</strong>。可分为连续空间存储（<strong>数组</strong>）和分散空间存储（<strong>链表</strong>）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p>需要注意的是，所有的数据结构都是基于数组、链表或者二者的组合实现的：</p><ul><li>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt; &#x3D;3的数组）等。</li><li>基于链表可实现：栈、队列、哈希表、树、堆、图等。</li></ul><p><img src="http://cdn.sswfive.xyz/2025-10/251022234510355_1761147910368.png" alt="251022234510355.png"></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们日常了解到的文本、图片、视频、语音、3D模型等格式的数据，基本都是由各种基本数据类型组构成。</p><h3 id="什么是基本数据类型"><a href="#什么是基本数据类型" class="headerlink" title="什么是基本数据类型"></a>什么是基本数据类型</h3><p>通常而言，基本数据类型是<strong>CPU可以直接进行运算的类型</strong>，或者在算法中直接被使用的类型，主要包括以下几种：</p><ul><li>整数类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点数类型<code>float</code>、<code>double</code> ，用于表示小数。</li><li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li><li>布尔类型<code>bool</code> ，用于表示“是”与“否”判断。<br>基本数据类型以<strong>二进制的形式存储在计算机中</strong>，一个二进制位即为1bit,在绝大多操作系统中，  1字节（byte）由  8比特（bit）组成。</li></ul><h3 id="基本数据类型与数据结构的关系"><a href="#基本数据类型与数据结构的关系" class="headerlink" title="基本数据类型与数据结构的关系"></a>基本数据类型与数据结构的关系</h3><p>基本数据类型提供了数据的“<strong>内容类型</strong>”，而数据结构提供了数据的“<strong>组织方式</strong>”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用多种基本数据类型来初始化数组</span></span><br><span class="line">numbers: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line">decimals: <span class="built_in">list</span>[<span class="built_in">float</span>] = [<span class="number">0.0</span>] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的字符实际上是长度为 1 的字符串</span></span><br><span class="line">characters: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">5</span></span><br><span class="line">bools: <span class="built_in">list</span>[<span class="built_in">bool</span>] = [<span class="literal">False</span>] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的列表可以自由存储各种基本数据类型和对象引用</span></span><br><span class="line">data = [<span class="number">0</span>, <span class="number">0.0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">False</span>, ListNode(<span class="number">0</span>)]</span><br></pre></td></tr></table></figure><h2 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h2><h3 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h3><blockquote><p>数字是以“补码”的形式存储在计算机中。</p></blockquote><ul><li>原码：将数字的二进制表示的最高位视为符号位，其中0表示正数，1表示负数，其余位表示数字的值。</li><li>反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加1。<br><img src="http://cdn.sswfive.xyz/2025-10/251023000940431_1761149380441.png" alt="251023000940431.png"></li></ul><p>需要注意的是：</p><ul><li>引入反码是为了解决负数不能直接用于用算。</li><li>引入补码是为了解决原码和反码都有正负零歧义问题。</li></ul><h3 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>为什么<code>int</code>和<code>float</code>长度都是4字节，但<code>float</code>取值范围远大于<code>int</code>?</p><p>因为<code>float</code>采用了不同的表示方式，根据 IEEE 754 标准，32-bit 长度的 <code>float</code> 由以下三个部分构成:</p><ul><li>符号位S：占1位</li><li>指数位E：占8位</li><li>分数位N：占23位<br><img src="http://cdn.sswfive.xyz/2025-10/251023002224549_1761150144555.png" alt="251023002224549.png"></li></ul><p><code>float</code>的表示方式包含指数位，导致其取值范围远大于<code>int</code>,但需要明白的是，尽管浮点数<code>float</code>扩展了取值范围，但其副作用是牺牲了精度。同理，双精度<code>double</code>也采用了类似的表示方法。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>在计算机中，所有的数据都是以二进制的形式存储的，字符<code>char</code>也不例外，为了表示字符，需要建立一套字符集，用于规定每个字符和二进制数之间一一对应关系，有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换了。</p><h3 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h3><p>ASCII码，其全称为American Standard Code for Information Interchange（美国标准信息交换代码）：它使用7位2进制数（一个字节的低7位）表示一个字符，最多能够表示128个不同的字符。<br>最开始，ASCII码仅能表示英文，随着计算机的全球化，诞生了一种能够表示更多语言的 EASCII 字符集。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符。</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>后来，EASCII 仍不够用。为处理数千日常汉字，我国于1980年推出了GB2312，收录6763字。后为兼容生僻字和繁体字，又扩展出GBK，收录21886字，并采用ASCII单字节、汉字双字节的编码方式。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>Unicode的中文名称为“统一码”，是一种通用字符集，理论上能容纳100多万个字符，本质上是给每个字符分配一个编码，称为“码点”，它没有规定在计算机中如何存储这些字符码点，而是直接将所有的字符存储为等长的编码，由于ASCII已经证明了编码英文只需要1字符，这就使得英文在Unicode下编码非常浪费内存空间，为了解决这个问题，产生了下列的UTF-8编码。</p><h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><p>UTF-8是当前使用最广泛的Unicode编码方法，它是一种可变长度的编码，使用1到4字节来表示一个字符，根据字符的复杂性而变，ASCII 字符只需 1 字节，拉丁字母和希腊字母需要 2 字节，常用的中文字符需要 3 字节，其他的一些生僻字符需要 4 字节。</p><p>UTF-8 的编码规则并不复杂，分为以下两种情况。</p><ul><li>对于长度为 1 字节的字符，将最高位设置为0 ，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，<strong>UTF-8 编码可以向下兼容 ASCII 码</strong>。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。</li><li>对于长度为 n 字节的字符（其中 n &gt; 1），将首个字节的高 n 位都设置为 1 ，第 n+1  位设置为 0 ；从第二个字节开始，将每个字节的高 2 位都设置为 10 ；其余所有位用于填充字符的 Unicode 码点。</li></ul><p>UTF-8 之外，常见的编码还有 UTF-16 和 UTF-32。</p><ul><li><strong>UTF-16</strong>：使用 2 或 4 字节表示字符。多数常用字符为 2 字节，且其编码值与 Unicode 码点相同。</li><li><strong>UTF-32</strong>：每个字符固定 4 字节，空间占用通常更大。</li></ul><p>总结对比：</p><ul><li><strong>存储空间</strong>：UTF-8 对英文高效（1字节）；UTF-16 对部分中文高效（2字节）。</li><li><strong>兼容性</strong>：UTF-8 通用性最佳，是优先支持的标准。</li></ul><h2 id="编程语言的字符编码"><a href="#编程语言的字符编码" class="headerlink" title="编程语言的字符编码"></a>编程语言的字符编码</h2><p>早期编程语言常采用 UTF-16 或 UTF-32 等长编码存储字符串，便于像数组一样处理，具有以下优势：</p><ul><li><strong>随机访问</strong>：UTF-16 可直接访问第 nn 个字符，时间复杂度为 O(1)O(1)；UTF-8 为变长编码，需要 O(n)O(n) 时间。</li><li><strong>字符计数</strong>：UTF-16 获取字符串长度为 O(1)O(1) 操作，UTF-8 需遍历整个字符串。</li><li><strong>字符串操作</strong>：在 UTF-16 上进行分割、连接、插入等操作更简单；UTF-8 需额外计算以避免编码错误。</li></ul><p>现代语言的改进方案</p><ul><li><strong>Python</strong>：str 类型根据最大 Unicode 码点动态选择存储：全 ASCII 用 1 字节，全在基本多语言平面（BMP）用 2 字节，有超出 BMP 的字符则用 4 字节。</li><li><strong>Go</strong>：string 内部使用 UTF-8，并提供 <code>rune</code> 表示单个 Unicode 码点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构的分类&quot;&gt;&lt;a href=&quot;#数据结构的分类&quot; class=&quot;headerlink&quot; title=&quot;数据结构的分类&quot;&gt;&lt;/a&gt;数据结构的分类&lt;/h2&gt;&lt;p&gt;常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从&lt;strong&gt;逻辑结构&lt;/s</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析与大O表示法</title>
    <link href="http://sswfive.xyz/2025/09/01/dsa/250901-complexity-analysis/"/>
    <id>http://sswfive.xyz/2025/09/01/dsa/250901-complexity-analysis/</id>
    <published>2025-09-01T14:40:49.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”的解决了。问题的难以程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的只是储备。人的知识越完备，经验越多，分析问题就会越深入，问题就能被解决的更优雅。</p><p>——摘录</p></blockquote><p>在前面一篇《DS&amp;A重学日志:[一]浅析数据结构与算法的核心概念》中简单的用个人理解的方式介绍了下复杂度分析和大O复杂度表示法，接下来正式的引入科学的概念及定义。</p><p>在引入之前，先想一个问题：如果我们想准确的预估一段代码的运行时间，应该如何操作呢？</p><ol><li><strong>确定运行平台</strong>，包括硬件配置、编程语言、系统环境等，因为这些因素都会影响代码的运行效率。</li><li><strong>评估各种计算操作所需要的运行时间</strong>，例如加法操作需要1ns, 乘法操作需要10ns,打印操作需要5ns等。</li><li><strong>统计代码滑总所有的计算操作</strong>，并将所有的操作和执行时间求和，从而得到运行时间。</li></ol><p>但实际上，上述的思路仅适合理论情况下，在实际场景中不合理也不现实，因为算法执行效率本就应该与平台无关，另一方面，我们没法准确的获取每种操作的运行时间。</p><p>由于实际测试具有较大的局限性，通常都是通过一些计算来评估算法的效率，也就是<strong>统计时间增长趋势</strong>，这种估算法的方法被称为：渐进复杂度分析（asymptotic complexity analysis）,简称复杂度分析。</p><h2 id="复杂度分析的定义"><a href="#复杂度分析的定义" class="headerlink" title="复杂度分析的定义"></a>复杂度分析的定义</h2><p>复杂度分析描述的是<strong>随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。可以从三个方面来理解：</p><ul><li>时间和空间资源：分别对应时间复杂度（time complexity）和空间复杂度(space complexity)</li><li>随着输入数据大小的增加：反映了算法执行效率与输入数据体量之间的关系。</li><li>时间和空间的增长趋势：表示复杂度分析关注不是运行时间和占用空间的具体值，而是时间或空间增长的“快慢”</li></ul><p>针对事后统计法存在的局限性提出的解决方案, 不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方案，这种方案叫做复杂度分析法，也叫大O复杂度表示法。复杂度分析法又分为：时间复杂度分析、空间复杂度分析</p><h2 id="大O复杂度表示法"><a href="#大O复杂度表示法" class="headerlink" title="大O复杂度表示法"></a>大O复杂度表示法</h2><ul><li>分类<ul><li>大O时间复杂度表示法（又称：渐进时间复杂度，简称：时间复杂度）</li><li>大O空间复杂度表示法（又称：渐进空间复杂度，简称：空间复杂度）</li></ul></li><li>公式：<code>T(n)=O(f(n))</code> <ul><li>T(n) : 表示代码执行的时间，n表示数据规模的大小 </li><li>fn: 表示每行代码执行次数的总和，这是一个公式，所以用fn表示</li><li>O: 表示代码执行时间T(n)与f(n)表达式成正比</li></ul></li></ul><blockquote><p>如：T(n) &#x3D; 2n * unit_time  、   T(n) &#x3D; (2n2+2n+3)*unit_time。<br>fn: 2n      &#x2F; fn: (2n2+2n+3)<br>T(n) &#x3D; O(2n)   &#x2F; T(n) &#x3D; O(2n2+2n+3)</p></blockquote><p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，故也称为渐进时间复杂度。</p><h2 id="如何进行时间复杂度分析？"><a href="#如何进行时间复杂度分析？" class="headerlink" title="如何进行时间复杂度分析？"></a>如何进行时间复杂度分析？</h2><h3 id="专业（数学）方法：求出函数渐近上界"><a href="#专业（数学）方法：求出函数渐近上界" class="headerlink" title="专业（数学）方法：求出函数渐近上界"></a>专业（数学）方法：求出函数渐近上界</h3><blockquote><p>首先统计操作数量，然后判断渐近上界。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    a = <span class="number">1</span>      <span class="comment"># +1</span></span><br><span class="line">    a = a + <span class="number">1</span>  <span class="comment"># +1</span></span><br><span class="line">    a = a * <span class="number">2</span>  <span class="comment"># +1</span></span><br><span class="line">    <span class="comment"># 循环 n 次</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># +1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)        <span class="comment"># +1</span></span><br></pre></td></tr></table></figure><p>如上述代码，给定一个输入大小为n的函数，设算法的操作数量是一个关于数据大小n的函数，记为T(n),则以上函数的操作数量为：T(n) &#x3D; 3 + 2n，T(n)是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。</p><p>通常将线性阶的时间复杂度记为O(n),这个数学符号称为大O记号（big-O natation）,表示函数T(n)的渐近上界（asymptotic upper bound）。</p><p>由此可见时间复杂度分析本质上是<strong>计算“操作数量T(n)”的渐近上界</strong>。</p><p>公式：<code>T(n)=O(f(n))</code> </p><ul><li>T(n) : 表示代码执行的时间，n表示数据规模的大小 </li><li>fn: 表示每行代码执行次数的总和，这是一个公式，所以用fn表示</li><li>O: 表示代码执行时间T(n)与f(n)表达式成正比</li></ul><p>由此可见：确定f(n)之后，就可以得到时间复杂度O(f(n)).</p><h3 id="实用（估算）方法：大O复杂度表示法"><a href="#实用（估算）方法：大O复杂度表示法" class="headerlink" title="实用（估算）方法：大O复杂度表示法"></a>实用（估算）方法：大O复杂度表示法</h3><p><strong>方法一：只关注循环执行次数最多的一段代码</strong></p><ul><li>通常会忽略T(n)的常量、低阶、系统、只需要记录一个最大阶的量级就好，这段代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</li></ul><p><strong>方法二：加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p><ul><li>抽象成公式则为：如果T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么T(n)&#x3D;T1(n)+T2(n)&#x3D;max(O(f(n)), O(g(n))) &#x3D;O(max(f(n), g(n))).</li></ul><p><strong>方法三：乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</strong></p><ul><li>抽象为公式则为：T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么T(n)&#x3D;T1(n)*T2(n)&#x3D;O(f(n))*O(g(n))&#x3D;O(f(n)*g(n)).</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    a = <span class="number">1</span>      <span class="comment"># +0（技巧 1）</span></span><br><span class="line">    a = a + n  <span class="comment"># +0（技巧 1）</span></span><br><span class="line">    <span class="comment"># +n（技巧 2）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span> * n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># +n*n（技巧 3）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * n): </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>完整统计：T(n) &#x3D; 2n(n+1) + (5n+1) + 2 &#x3D; $2n^2 + 7n +3$</p><p>偷懒统计： $n^2 + n$</p><p>上述代码的时间复杂度为：$O(n^2)$</p><h2 id="常见时间复杂度类型"><a href="#常见时间复杂度类型" class="headerlink" title="常见时间复杂度类型"></a>常见时间复杂度类型</h2><ul><li>多项式量级：<ul><li>常量阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、k次方阶O(n^k)</li></ul></li><li>非多项式量级：<ul><li>指数阶O(2n) 、 阶乘阶O(n!)</li><li>当数据规模n越来越大是，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。</li></ul></li></ul><p>按执行效率从高到低排列常见的有：</p><p>$$O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(2ⁿ) &lt; O(n!)$$</p><p>常数阶 &lt; 对数阶  &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt;  指数阶 &lt; 阶乘阶</p><h3 id="常数阶O-1"><a href="#常数阶O-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><p>常数阶的<strong>操作数量与输入数据大小n无关，即不随着n的变化而变化</strong>。</p><ul><li>常量级时间复杂度，并不是指只执行了一行代码；</li><li>只要代码的执行时间不随n的增大而增大，这样的代码的时间复杂度就记作O(1)，</li><li>只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，起时间复杂度依然是O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">constant</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;常数阶&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    size = <span class="number">100000</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h3><p>线性阶的<strong>操作数量相对于输入数据的大小n以线性级别增长，通常出现在单层循环中。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">array_traversal</span>(<span class="params">nums: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性阶（遍历数组）&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环次数与数组长度成正比</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>需要注意的是：输入数据大小n需根据输入数据的类型来具体确定。比如在第一个示例中，变量 为输入数据大小；在第二个示例中，数组长度 为数据大小。</p><h3 id="平方阶O-n-2"><a href="#平方阶O-n-2" class="headerlink" title="平方阶O($n^2$)"></a>平方阶O($n^2$)</h3><p>平方阶的操作数量相对于输入数据大小n以平方级别增长。通常出现在嵌套循环中，外层循环和内存循环的时间复杂度都为$O(n)$，因此总体的时间复杂度为$O(n^2)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环次数与数据大小 n 成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="指数阶-O-2-n"><a href="#指数阶-O-2-n" class="headerlink" title="指数阶 $O(2^n)$"></a>指数阶 $O(2^n)$</h3><p>在算法中，指数阶常出现于递归函数中。在生物学中的“细胞分裂”也是指数阶增长的典型代表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exponential</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;指数阶（循环实现）&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    base = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(base):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        base *= <span class="number">2</span></span><br><span class="line">    <span class="comment"># count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp_recur</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;指数阶（递归实现）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> exp_recur(n - <span class="number">1</span>) + exp_recur(n - <span class="number">1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>指数阶增长速度非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p><h3 id="对数阶-O-log-n"><a href="#对数阶-O-log-n" class="headerlink" title="对数阶$O(log n)$"></a>对数阶$O(log n)$</h3><p>与指数阶相反，对数阶放映了“每轮缩减到一半”的情况。设输入数据大小为n, 由于每轮缩减到一半，因此循环次数是$log2n$，即$2^n$的反函数。</p><p>对数阶也常出现于递归函数和分治策略（一分为多和化繁为简）的算法中。它增长缓慢，是仅次于常数阶的理想的时间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logarithmic</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对数阶（循环实现）&quot;&quot;&quot;</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">        n = n / <span class="number">2</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_recur</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对数阶（递归实现）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> log_recur(n / <span class="number">2</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="线性对数阶-O-nlogn"><a href="#线性对数阶-O-nlogn" class="headerlink" title="线性对数阶$O(nlogn)$"></a>线性对数阶$O(nlogn)$</h3><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为$O(nlogn)$ 和 $O(n)$</p><p>主流的排序算法的时间复杂度通常为$O(nlogn)$，如：快速排序、归并排序、堆排序等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear_log_recur</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性对数阶&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 一分为二，子问题的规模减小一半</span></span><br><span class="line">    count = linear_log_recur(n // <span class="number">2</span>) + linear_log_recur(n // <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 当前子问题包含 n 个操作</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="阶乘-O-n"><a href="#阶乘-O-n" class="headerlink" title="阶乘$O(n!)$"></a>阶乘$O(n!)$</h3><p>阶乘在算法场景中，通常使用递归实现，在数学场景中，对应“全排列”问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">factorial_recur</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;阶乘阶（递归实现）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        count += factorial_recur(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><ul><li>在n较大时是不可接受的。</li></ul><h2 id="如何进行空间复杂度分析？"><a href="#如何进行空间复杂度分析？" class="headerlink" title="如何进行空间复杂度分析？"></a>如何进行空间复杂度分析？</h2><p>空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。其实和时间复杂度很类似，只需将“运行时间”替换成“占用内存空间”就好。</p><h3 id="算法相关空间"><a href="#算法相关空间" class="headerlink" title="算法相关空间"></a>算法相关空间</h3><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li><strong>输入空间</strong>：用于存储算法的输入数据。</li><li><strong>暂存空间</strong>：用于存储算法在运行过程中的变量、对象、函数上下文等数据。</li><li><strong>输出空间</strong>：用于存储算法的输出数据。</li></ul><p>一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。</p><p>暂存空间可以进一步划分为三个部分。</p><ul><li><strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。</li><li><strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。</li><li><strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。</li></ul><p>在分析一段程序的空间复杂度时，<strong>我们通常统计暂存数据、栈帧空间和输出数据三部分</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val: <span class="built_in">int</span> = x              <span class="comment"># 节点值</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span>: Node | <span class="literal">None</span> = <span class="literal">None</span>  <span class="comment"># 指向下一节点的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 执行某些操作...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm</span>(<span class="params">n</span>) -&gt; <span class="built_in">int</span>:  <span class="comment"># 输入数据</span></span><br><span class="line">    A = <span class="number">0</span>                 <span class="comment"># 暂存数据（常量，一般用大写字母表示）</span></span><br><span class="line">    b = <span class="number">0</span>                 <span class="comment"># 暂存数据（变量）</span></span><br><span class="line">    node = Node(<span class="number">0</span>)        <span class="comment"># 暂存数据（对象）</span></span><br><span class="line">    c = function()        <span class="comment"># 栈帧空间（调用函数）</span></span><br><span class="line">    <span class="keyword">return</span> A + b + c      <span class="comment"># 输出数据</span></span><br></pre></td></tr></table></figure><h3 id="推算方法"><a href="#推算方法" class="headerlink" title="推算方法"></a>推算方法</h3><p>空间复杂度的推算方法与时间复杂度大致相同，只需将统计对象从“操作数量”转为“使用空间大小”即可。</p><p>而与时间复杂度不同的是，我们通常只关注<strong>最差空间复杂度</strong>，这是因为内存空间是一项硬性要求，我们必须要确保在所有输入数据下都有足够的内存空间预留。</p><p>一般的最差有两层含义：</p><ol><li>以最差输入数据为准</li><li>以算法运行中的峰值内存为准</li></ol><p>另外需要注意，在递归函数中，需要统计栈帧空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;循环的空间复杂度为 O(1)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        function()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;递归的空间复杂度为 O(n)&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> recur(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>函数 <code>loop()</code> 和 <code>recur()</code> 的时间复杂度都为 ，但空间复杂度不同。</p><ul><li>函数 <code>loop()</code> 在循环中调用了 次 <code>function()</code> ，每轮中的 <code>function()</code> 都返回并释放了栈帧空间，因此空间复杂度仍为 。</li><li>递归函数 <code>recur()</code> 在运行过程中会同时存在 个未返回的 <code>recur()</code> ，从而占用 的栈帧空间。</li></ul><h2 id="常见空间复杂度类型"><a href="#常见空间复杂度类型" class="headerlink" title="常见空间复杂度类型"></a>常见空间复杂度类型</h2><p>$O(1) &lt; O(log n) &lt; O(n) &lt; O(n²) &lt; O(2ⁿ)$</p><p>常数阶 &lt; 对数阶   &lt; 线性阶  &lt; 平方阶  &lt; 指数阶</p><h3 id="常数阶O-1-1"><a href="#常数阶O-1-1" class="headerlink" title="常数阶O(1)"></a>常数阶O(1)</h3><p>常数阶常见于数量与输入数据大小 无关的常量、变量、对象。</p><p>需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">constant</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;常数阶&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 常量、变量、对象占用 O(1) 空间</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    nums = [<span class="number">0</span>] * <span class="number">10000</span></span><br><span class="line">    node = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 循环中的变量占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环中的函数占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        function()</span><br></pre></td></tr></table></figure><h3 id="线性阶O-n-1"><a href="#线性阶O-n-1" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h3><p>线性阶常见于元素数量与n成正比的数组、链表、栈、队列等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">linear</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性阶&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 长度为 n 的列表占用 O(n) 空间</span></span><br><span class="line">    nums = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="comment"># 长度为 n 的哈希表占用 O(n) 空间</span></span><br><span class="line">    hmap = <span class="built_in">dict</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        hmap[i] = <span class="built_in">str</span>(i)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_recur</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;线性阶（递归实现）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;递归 n =&quot;</span>, n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    linear_recur(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="平方阶O-n-2-1"><a href="#平方阶O-n-2-1" class="headerlink" title="平方阶O($n^2$)"></a>平方阶O($n^2$)</h3><p>平方阶常见于矩阵和图，元素数量与n成平方关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic</span>(<span class="params">n: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;平方阶&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 二维列表占用 O(n^2) 空间</span></span><br><span class="line">    num_matrix = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quadratic_recur</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;平方阶（递归实现）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 数组 nums 长度为 n, n-1, ..., 2, 1</span></span><br><span class="line">    nums = [<span class="number">0</span>] * n</span><br><span class="line">    <span class="keyword">return</span> quadratic_recur(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="指数阶-O-2-n-1"><a href="#指数阶-O-2-n-1" class="headerlink" title="指数阶 $O(2^n)$"></a>指数阶 $O(2^n)$</h3><p>指数阶常见于二叉树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_tree</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; TreeNode | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;指数阶（建立满二叉树）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(<span class="number">0</span>)</span><br><span class="line">    root.left = build_tree(n - <span class="number">1</span>)</span><br><span class="line">    root.right = build_tree(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h3 id="对数阶-O-log-n-1"><a href="#对数阶-O-log-n-1" class="headerlink" title="对数阶$O(log n)$"></a>对数阶$O(log n)$</h3><p>对数阶常见于分治算法。例如<strong>归并排序</strong>（输入长度为n 的数组，每轮递归将数组从中点处划分为两半，形成高度为 $(log n)$的递归树，使用$O(log n)$ 栈帧空间。）、<strong>数字转化为字符串</strong>。</p><h2 id="权衡利弊"><a href="#权衡利弊" class="headerlink" title="权衡利弊"></a>权衡利弊</h2><p>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”，反之，则称为“以时间换空间”。</p><p>选择那种思路取决于我们更看中哪个方面。在大多数情况下，时间比空间更宝贵，因此“以空间换时间”通常是更常用的策略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”的解决了。问题的难以程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的只是储备。人的知识越完备，经验越多，分析问题就会越深入，问题就能被解决的更优雅。&lt;/p&gt;
&lt;p&gt;——</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>浅析数据结构与算法的核心概念</title>
    <link href="http://sswfive.xyz/2025/09/01/dsa/250831-dsa-basic/"/>
    <id>http://sswfive.xyz/2025/09/01/dsa/250831-dsa-basic/</id>
    <published>2025-08-31T17:00:34.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>数据结构与算法常被视为一个整体，但它其实是由「数据结构」和「算法」两部分构成。我们很少见到有人将他们完全分开讲解，正是因为二者相辅相成、密不可分：数据结构是为算法的服务的，而算法总要作用在某种特定的数据结构之上。</p><p>此外值得注意的是，算法工程师所从事的“算法”工作，与数据结构与算法中的算法中所有的“算法”是两回事。前者的侧重于在数据建模、特征工程和参数调优，计算机更多是作为实现计算的工具；而后者强调的是一种计算机思维——要求我们能够站在计算机的底层视角，对现实问题进行抽象与简化，并运用合理的数据结构设计出高效的解放方案。</p><h2 id="数据结构：数据该怎么高效的存"><a href="#数据结构：数据该怎么高效的存" class="headerlink" title="数据结构：数据该怎么高效的存"></a>数据结构：数据该怎么高效的存</h2><p>数据结构（data structure）是<strong>指数据组织和存储的方式</strong>，其核心解决的是<strong>数据该怎么存</strong>的问题。</p><p>常见的数据结构可以分为两大类：</p><ul><li>线性结构<ul><li>数组（Array）、链表（Linked List）、栈（Stack）、队列（Queue）</li></ul></li><li>非线性结构<ul><li>树（Tree）、堆（Heap）、散列表（hash Table）、图（Graph）</li></ul></li></ul><p>设计一个好的数据结构，我们通常需要考虑以下几点：</p><ul><li>如何节省内存？-&gt; 尽可能减少内存的占用；</li><li>如何操作更快？-&gt; 优化增删改查等基本操作的效率；</li><li>如何清晰表达？-&gt; 通过简洁的数据表示支持算法高效运行。</li></ul><h2 id="算法：数据该怎么高效的用"><a href="#算法：数据该怎么高效的用" class="headerlink" title="算法：数据该怎么高效的用"></a>算法：数据该怎么高效的用</h2><p>算法（algorithm）是指<strong>在有限时间内解决特定问题的一组指令或者操作步骤</strong>。就像一个靠谱的食谱，只要跟着步骤做，就能在有限时间里做出想要的菜。</p><p>一个好的算法，要有这些特质：</p><ul><li><strong>明确的问题定义</strong>：包含清晰的输入和输出定义；</li><li><strong>可行性</strong>：能够在有限步骤、时间、和内存空间下完成；</li><li><strong>确定性</strong>：在相同的输入和运行条件下，输出始终相同；</li><li><strong>可重复性</strong>：任何人依照步骤执行都应该得到相同输出。</li></ul><p>我们在设计算法的时候，一般会先后追求两个层面的目标：解决问题和尽可能高效的解决问题。也就是说，我们的目标是设计出“既快又省”的算法，具体点就是：</p><ol><li><strong>找到问题解法</strong>：算法需要在规定的输入范围内可靠地求得问题的正确解。</li><li><strong>寻找最优解法</strong>：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。</li></ol><p>常见的算法思想有不少，比如：</p><ul><li>递归（Recursion）-&gt; 自己调用自己</li><li>分治（Divide and Conquer）-&gt; 拆解小问题逐个击破</li><li>动态规划（Dynamic Programming）-&gt; 记住已经做过的，避免重复劳动</li><li>贪心算法（Greedy Algorithm）-&gt; 每一步都选当前最好的</li><li>回溯（Backtracking）-&gt; 试错了就回头</li><li>枚举（Enumeration）-&gt; 把所有可能都试一遍</li></ul><h3 id="复杂度分析：高效判断算法的性价比"><a href="#复杂度分析：高效判断算法的性价比" class="headerlink" title="复杂度分析：高效判断算法的性价比"></a>复杂度分析：高效判断算法的性价比</h3><p>复杂度分析，它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。 说白了就是不看实际运行，就能预估算法随着数据量变大，对执行速度和占用内存有多大影响。</p><p>最常用的方法就是大O复杂度表示法，靠它，就能在不用真跑测试的情况下，大致判断一个算法的效率。</p><p><strong>复杂度分析的常见概念：</strong></p><ul><li>最好情况时间复杂度（best case time complexity）<ul><li>在运气最好的时候执行这段代码</li></ul></li><li>最坏情况时间复杂度（wrost case time complexity）<ul><li>在运气最背的时候执行这段代码</li></ul></li><li>平均情况时间复杂度（average case time complexity）<ul><li>大多数日常情况下，执行这段代码</li></ul></li><li>均摊时间复杂度（amortized complexity）<ul><li>又称：摊还分析、平摊分析</li><li>通过摊还分析法得到的时间复杂度</li><li>均摊时间复杂度是一种特殊的平均时间复杂度</li></ul></li></ul><p>通常情况下，并不都是需要区分最好、最坏、平均情况时间复杂度的，使用一种复杂度就能满足需求了。</p><p><strong>大O复杂度表示法主要看两点：</strong></p><ul><li>时间复杂度：运行时间随数据规模增长的趋势</li><li>空间复杂度：占用内存随数据规模增长的趋势</li></ul><p>它的核心公式是：$T(n)&#x3D;O(f(n))$ , 表示执行时间T(n)和某个函数f(n)成正比。</p><p>大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势，故也称为“渐进时间复杂度”。</p><h2 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h2><h3 id="数据结构与算法到底是什么关系？"><a href="#数据结构与算法到底是什么关系？" class="headerlink" title="数据结构与算法到底是什么关系？"></a>数据结构与算法到底是什么关系？</h3><p>数据结构是算法的基石，算法必须依赖数据结构才能发挥作用。反过来，算法又是数据结构的灵魂，没有算法，数据结构也仅是静态的存储单元。它们共同的目标是解决如何更省、更快地存储和处理数据。</p><h3 id="怎么判断一个算法好不好？"><a href="#怎么判断一个算法好不好？" class="headerlink" title="怎么判断一个算法好不好？"></a>怎么判断一个算法好不好？</h3><p>算法效率的评估通常采用以下两种方法：</p><ul><li><p><strong>事后统计法</strong>（又称实际测试法）：</p><ul><li>一般采取的做法是把算法（代码）运行一遍，根据统计、监控就能得到算法执行的是时间和占用的内存大小。但这种做法有很大的局限性，主要在于，测试结果非常依赖于测试环境（如：运行机器的处理器性能），测试结果受到数据规模大小的影响很大如：对一组数据进行排序，有序的数据一定比无序数据执行效率高，再比如数据量太小的数据，测试结果也无法真实的反应算法的性能）。</li></ul></li><li><p><strong>复杂度分析法</strong>（又称理论估算法）：</p><ul><li>采用大O复杂度表示法。此方法主要从时间复杂度和空间复杂度两个方面对算法进行理论上的估算，该方法不受环境与具体数据干扰，是更为通用和推荐的评估方式。</li></ul></li></ul><h3 id="常见的复杂度类型有哪些？"><a href="#常见的复杂度类型有哪些？" class="headerlink" title="常见的复杂度类型有哪些？"></a>常见的复杂度类型有哪些？</h3><p>按执行效率从高到低排列常见的有：</p><p>$$O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(2ⁿ) &lt; O(n!)$$</p><p>常数阶 &lt; 对数阶  &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt;  指数阶 &lt; 阶乘阶</p><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ul><li>所有数据结构，本质上都是<strong>数组</strong>（顺序存储）和<strong>链表</strong>（链式存储）的组合和扩展。其核心在于如何实现高效的遍历与访问（即增、删、改、查）。</li><li>所有算法思想，本质上都是对穷举的优化。关键在于如何做到<strong>无遗漏、无冗余</strong>——也就是在尽可能少的步骤中，找到问题的解。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;数据结构与算法常被视为一个整体，但它其实是由「数据结构」和「算法」两部分构成。我们很少见到有人将他们完全分开讲解，正是因为二</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重回原点再出发</title>
    <link href="http://sswfive.xyz/2025/08/31/dsa/250831-dsa-intro/"/>
    <id>http://sswfive.xyz/2025/08/31/dsa/250831-dsa-intro/</id>
    <published>2025-08-31T14:30:30.000Z</published>
    <updated>2025-10-14T08:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在AI编程助手高速演进时代，我们每天都在坚持技术的飞跃。然而，越是在浪潮之巅，我越发意识到—真正可持续的成长，依然离不开坚实的技术根基。</p><p>根基无声，却能支撑我们走向更远的未来……</p><p>因此，我从今天（2025.08.31）起，启动一项为期31天的专项计划：重新系统学习数据结构与算法，并将这个系列命名为《DS&amp;A重学日志》。</p><p>“DS&amp;A”代表Data Structure and Algorithms.这不仅是一次温故知新的回顾，更是一场刻意选择的“返璞归真”—在智能工具日益强大的今天，我选择回到底层，夯实每一块知识基石，重建对数据结构与算法的理解。</p><p>在接下来一个月中，我会坚持每日输出一篇学习笔记，内容不局限与概念复述，更会融入代码实践，算法思想拆解和个人总结。我通过这种写作的方式，倒逼自己能够有目标的坚持走完这段里程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在AI编程助手高速演进时代，我们每天都在坚持技术的飞跃。然而，越是在浪潮之巅，我越发意识到—真正可持续的成长，依然离不开坚实的技术根基。&lt;/p&gt;
&lt;p&gt;根基无声，却能支撑我们走向更远的未来……&lt;/p&gt;
&lt;p&gt;因此，我从今天（2025.08.31）起，启动一项为期31天的专项</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor：三年后的更新，把我三年前的笔记唤醒</title>
    <link href="http://sswfive.xyz/2025/08/30/tech/python/250830-supervisor/"/>
    <id>http://sswfive.xyz/2025/08/30/tech/python/250830-supervisor/</id>
    <published>2025-08-30T13:11:31.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="失踪人口回归：Supervisor时隔三年再更新"><a href="#失踪人口回归：Supervisor时隔三年再更新" class="headerlink" title="失踪人口回归：Supervisor时隔三年再更新"></a>失踪人口回归：Supervisor时隔三年再更新</h2><p>时隔近三年，这款经典的进程管理工具终于迎来了更新。</p><p>最近偶然注意到Supervisor项目发布了新版本（4.3.0—2025.08.23)，印象中这个项目已经很久没有动静了。于是特意去翻看了更新日志，才发现距离上个版本发布已经过去了两年零八个月。仔细阅读版本说明后，发现这次更新主要集中在性能优化和稳定性提升，主要包括了：</p><p>两项重要Bug修复:</p><ul><li>CPU 使用率优化：修复了在某些情况下轮询器未注销已关闭的文件描述符，导致过度轮询、CPU 占用异常升高的问题。</li><li>重启稳定性提升：修复了在重启期间若有 HTTP 请求可能导致“端口已被占用”错误的问题。</li></ul><p>兼容性更新</p><ul><li>支持 Python 3.13：修复了仅在 Python 3.13 环境下会失败的单元测试。</li><li>清理依赖关系：Python 3.8 及以上版本不再需要 setuptools 作为运行时依赖；Python 3.7 及以下版本仍需手动安装 setuptools。</li></ul><p>时间飞逝，Supervisor已有近三年未发布版本了，而我也差不多有三年多没有使用这个组件了。正好借此机会，我将之前在使用过程中记录的笔记重新整理了一遍，分享给大家。</p><h2 id="初识Supervisor：你的进程管理"><a href="#初识Supervisor：你的进程管理" class="headerlink" title="初识Supervisor：你的进程管理"></a>初识Supervisor：你的进程管理</h2><p>Supervisor是用Python开发的一款用于Linux的进程管理工具，采用典型的C&#x2F;S架构，够高效监控和管理进程状态。官方资源：<a href="https://github.com/Supervisor/supervisor">Github仓库</a>、<a href="https://supervisord.org/">官方文档</a></p><p>Supervisor主要包含两个组件：</p><ul><li><p>supervisord：服务端，负责启动、监控和管理子进程。</p></li><li><p>supervisorctl：客户端，提供命令行界面管理子进程。</p></li></ul><p>主要特点：</p><ul><li>进程状态监控和管理</li><li>进程崩溃自动重启</li><li>统一的进程管理接口</li><li>Web管理界面支持</li><li>进程组管理功能</li></ul><p>注意事项：</p><ul><li>Supervisor要求要离的程序必须非守护进程方式运行（例如：管理nginx，必须在 nginx 的配置文件里添加一行设置 daemon off 让 nginx 以非 daemon 方式启动）</li><li>修改配置文件（配置文件通常位于<code>/etc/supervisord.conf</code>）后需要执行reload才能更改生效。</li></ul><h2 id="快速上手：你只需要几分钟"><a href="#快速上手：你只需要几分钟" class="headerlink" title="快速上手：你只需要几分钟"></a>快速上手：你只需要几分钟</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor  <span class="comment"># 或 uv add supervisor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成配置文件到指定路径（此处路径指定为了/etc/supervisord.conf）</span></span><br><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>supervisord: 服务端命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">supervisord -c /etc/supervisord.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否在运行</span></span><br><span class="line">ps aux | grep supervisord</span><br></pre></td></tr></table></figure><ul><li>supervisorctl: 客户端命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl status                         <span class="comment"># 查看进程状态</span></span><br><span class="line">supervisorctl start program_name             <span class="comment"># 启动program_name进程</span></span><br><span class="line">supervisorctl stop program_name              <span class="comment"># 终止program_name进程</span></span><br><span class="line">supervisorctl restart program_name           <span class="comment"># 重启program_name进程</span></span><br><span class="line">supervisorctl reread                         <span class="comment"># 更新配置，根据最新的配置启动所有程序</span></span><br><span class="line">supervisorctl update                         <span class="comment"># 更新配置，重启配置有变化的进程</span></span><br></pre></td></tr></table></figure><ul><li>supervisorctl: shell命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl                <span class="comment"># 进入shell命令行</span></span><br><span class="line">&gt; status                     <span class="comment"># 查看进程状态</span></span><br><span class="line">&gt; start program_name         <span class="comment"># 启动program_name进程</span></span><br><span class="line">&gt; stop program_name          <span class="comment"># 终止program_name进程</span></span><br><span class="line">&gt; restart program_name       <span class="comment"># 重启program_name进程</span></span><br><span class="line">&gt; reread                     <span class="comment"># 更新配置，根据最新的配置启动所有程序</span></span><br><span class="line">&gt; update                     <span class="comment"># 更新配置，重启配置有变化的进程</span></span><br><span class="line">&gt; start fastapi:*            <span class="comment"># 启动 fastapi组 程序</span></span><br><span class="line">&gt; stop fastapi:*             <span class="comment"># 停止 fastapi组 程序</span></span><br></pre></td></tr></table></figure><h3 id="基础使用："><a href="#基础使用：" class="headerlink" title="基础使用："></a>基础使用：</h3><ul><li>step1：编辑supervisor主配置文件，在配置文件的末尾加上[include]内容</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[include]</span><br><span class="line">files=/etc/supervisor.d/*.conf  <span class="comment">#若你本地无/etc/supervisor.d目录，请自建</span></span><br></pre></td></tr></table></figure><ul><li>step2：创建应用配置文件：<code>/etc/supervisor.d/demo.conf</code> 配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:自定义的服务名称]</span><br><span class="line"><span class="built_in">command</span>=python3 /xxxx/main.py  <span class="comment">#服务的启动命令，在这里用的python环境为supervisor安装的环境，若想指定其他python环境则可指定python包的位置如command=xxxx/xxxx/bin/python3 /xxxx/main.py便可</span></span><br><span class="line">directory=/xxxx</span><br><span class="line">process_name=%(program_name)s</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">startsecs=3</span><br><span class="line">stdout_logfile=/home/task.log  <span class="comment">#输出日志文件路径</span></span><br><span class="line">stderr_logfile=/home/task.log  <span class="comment">#报错日志文件路径</span></span><br><span class="line">user=your_username</span><br></pre></td></tr></table></figure><ul><li>step3:启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisor.conf</span><br></pre></td></tr></table></figure><h2 id="配置详解：磨刀不误砍柴工"><a href="#配置详解：磨刀不误砍柴工" class="headerlink" title="配置详解：磨刀不误砍柴工"></a>配置详解：磨刀不误砍柴工</h2><blockquote><p>打开配置文件： &#x2F;etc&#x2F;supervisord.conf</p></blockquote><h3 id="基础配置段"><a href="#基础配置段" class="headerlink" title="基础配置段"></a>基础配置段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/var/run/supervisor.sock   ; socket文件路径</span><br><span class="line">;<span class="built_in">chmod</span>=0700                     ;socket文件的mode，默认是0700</span><br><span class="line">;<span class="built_in">chown</span>=nobody:nogroup           ;socket文件的owner，格式：uid:gid</span><br><span class="line"></span><br><span class="line">[inet_http_server]              ;HTTP服务器，提供web管理界面 </span><br><span class="line">port=0.0.0.0:9001               ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">username=user                   ;登录管理后台的用户名</span><br><span class="line">password=<span class="built_in">pwd</span>                    ;登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log    ;日志文件，默认是 <span class="variable">$CWD</span>/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB           ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10              ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                   ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid    ;pid 文件</span><br><span class="line">nodaemon=<span class="literal">false</span>                  ;是否在前台启动，默认是<span class="literal">false</span>，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                     ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                    ;可以打开的进程数的最小值，默认 200</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files=/etc/supervisor.d/*.conf  <span class="comment">#若你本地无/etc/supervisor.d目录，请自建</span></span><br></pre></td></tr></table></figure><h3 id="程序配置段"><a href="#程序配置段" class="headerlink" title="程序配置段"></a>程序配置段</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[program:your_program_name]</span><br><span class="line"><span class="built_in">command</span>=/path/to/your/command   ; 必须：要执行的命令</span><br><span class="line">process_name=%(program_name)s   ; 进程名</span><br><span class="line">numprocs=1                      ; 进程数量</span><br><span class="line">directory=/path/to/run/in       ; 执行命令前切换的目录</span><br><span class="line">autostart=<span class="literal">true</span>                  ; 是否随supervisor启动</span><br><span class="line">autorestart=unexpected          ; 退出时是否自动重启</span><br><span class="line">startsecs=1                     ; 启动后持续运行1秒才认为是成功</span><br><span class="line">startretries=3                  ; 启动失败时的重试次数</span><br><span class="line">user=username                   ; 运行用户</span><br><span class="line">redirect_stderr=<span class="literal">true</span>            ; 重定向stderr到stdout</span><br><span class="line">stdout_logfile=/path/to/logfile ; stdout日志路径</span><br><span class="line">stdout_logfile_maxbytes=1MB     ; 日志文件最大大小</span><br><span class="line">stdout_logfile_backups=10       ; 日志备份数量</span><br><span class="line">environment=KEY=<span class="string">&quot;value&quot;</span>         ; 环境变量</span><br></pre></td></tr></table></figure><h2 id="入门到进阶：让效率翻倍"><a href="#入门到进阶：让效率翻倍" class="headerlink" title="入门到进阶：让效率翻倍"></a>入门到进阶：让效率翻倍</h2><h3 id="Web管理界面"><a href="#Web管理界面" class="headerlink" title="Web管理界面"></a>Web管理界面</h3><p>启动Web管理界面可以直观地监控和管理进程, 在&#x2F;etc&#x2F;supervisord.conf中修改[inet_http_server]的参数下列参数，修改后记得重启supervisor进程，在浏览器访问 <code>http://&lt;host-ip&gt;:9001</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[inet_http_server]</span><br><span class="line">port=0.0.0.0:9001</span><br><span class="line">username=your_username</span><br><span class="line">password=your_password</span><br></pre></td></tr></table></figure><h3 id="进程分组管理"><a href="#进程分组管理" class="headerlink" title="进程分组管理"></a>进程分组管理</h3><p>对于多个相关进程，可以使用分组功能进行统一管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[group:app_group]</span><br><span class="line">programs=app1,app2,app3</span><br><span class="line"></span><br><span class="line">[program:app1]</span><br><span class="line"><span class="built_in">command</span>=/path/to/app1</span><br><span class="line"></span><br><span class="line">[program:app2]</span><br><span class="line"><span class="built_in">command</span>=/path/to/app2</span><br><span class="line"></span><br><span class="line">[program:app3]</span><br><span class="line"><span class="built_in">command</span>=/path/to/app3</span><br></pre></td></tr></table></figure><p>分组后可以使用下列命令进行管理整个组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start app_group:</span><br><span class="line">supervisorctl stop app_group:</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>当添加了上述配置后，app1、app2和app3 的进程名就会变成 app_group:app1 、 app_group:app2和app_group:app1 ，以后就要用这个名字来管理进程了，而不是之前的 app[x]了。</li></ul><h3 id="Supervisor配置开机启动"><a href="#Supervisor配置开机启动" class="headerlink" title="Supervisor配置开机启动"></a>Supervisor配置开机启动</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><blockquote><p>centos-7</p></blockquote><ul><li>进入 &#x2F; lib&#x2F;systemd&#x2F;system 目录，并创建 supervisord.service 文件。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=supervisord</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line">ExecStop=/usr/bin/supervisorctl <span class="variable">$OPTIONS</span> shutdown</span><br><span class="line">ExecReload=/usr/bin/supervisorctl <span class="variable">$OPTIONS</span> reload</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>加入开机启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> supervisord</span><br><span class="line">systemctl start supervisord</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul><li>Linux环境中：以systemd的方式管理<ul><li>编写启动脚本：vim &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;supervisord</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/rc.d/init.d/supervisord</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Supervisor is a client/server system that</span></span><br><span class="line"><span class="comment"># allows its users to monitor and control a</span></span><br><span class="line"><span class="comment"># number of processes on UNIX-like operating</span></span><br><span class="line"><span class="comment"># systems.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: - 64 36</span></span><br><span class="line"><span class="comment"># description: Supervisor Server</span></span><br><span class="line"><span class="comment"># processname: supervisord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source init functions</span></span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">prog=<span class="string">&quot;supervisord&quot;</span></span><br><span class="line"></span><br><span class="line">prefix=<span class="string">&quot;/usr&quot;</span></span><br><span class="line">exec_prefix=<span class="string">&quot;<span class="variable">$&#123;prefix&#125;</span>&quot;</span></span><br><span class="line">prog_bin=<span class="string">&quot;<span class="variable">$&#123;exec_prefix&#125;</span>/bin/supervisord&quot;</span></span><br><span class="line">PIDFILE=<span class="string">&quot;/var/run/<span class="variable">$prog</span>.pid&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">echo</span> -n $<span class="string">&quot;Starting <span class="variable">$prog</span>: &quot;</span></span><br><span class="line">daemon <span class="variable">$prog_bin</span> --pidfile <span class="variable">$PIDFILE</span> -c /etc/supervisord.conf</span><br><span class="line">[ -f <span class="variable">$PIDFILE</span> ] &amp;&amp; success $<span class="string">&quot;<span class="variable">$prog</span> startup&quot;</span> || failure $<span class="string">&quot;<span class="variable">$prog</span> startup&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">stop</span></span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">echo</span> -n $<span class="string">&quot;Shutting down <span class="variable">$prog</span>: &quot;</span></span><br><span class="line">[ -f <span class="variable">$PIDFILE</span> ] &amp;&amp; killproc <span class="variable">$prog</span> || success $<span class="string">&quot;<span class="variable">$prog</span> shutdown&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">start)</span><br><span class="line">start</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">stop)</span><br><span class="line">stop</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">status)</span><br><span class="line">status <span class="variable">$prog</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">restart)</span><br><span class="line">stop</span><br><span class="line">start</span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> &#123;start|stop|restart|status&#125;&quot;</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><ul><li>设置开机启动及systemd方式启动。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> +x /etc/rc.d/init.d/supervisord</span><br><span class="line"><span class="built_in">sudo</span> chkconfig --add supervisord</span><br><span class="line"><span class="built_in">sudo</span> chkconfig supervisord on</span><br><span class="line"><span class="built_in">sudo</span> service supervisord start</span><br></pre></td></tr></table></figure><h2 id="实践出真知"><a href="#实践出真知" class="headerlink" title="实践出真知"></a>实践出真知</h2><h3 id="Django应用配置"><a href="#Django应用配置" class="headerlink" title="Django应用配置"></a>Django应用配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:django]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/root/social_engineering/</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/root/anaconda3/bin/python manage.py runserver 0.0.0.0:8000   <span class="comment"># 或用gunicorn等服务启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#当程序exit的时候，这个program不会自动重启,默认unexpected，设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected和true。如果为false的时候，无论什么情况下，都不会被重新启动，如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/tmp/django_stderr.log</span><br><span class="line">stdout_logfile=/tmp/django_stdout.log</span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 20</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 20</span><br><span class="line"></span><br><span class="line">; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH</span><br><span class="line">; environment=PYTHONPATH=<span class="variable">$PYTHONPATH</span>:/path/to/somewhere</span><br></pre></td></tr></table></figure><h3 id="Celery应用配置"><a href="#Celery应用配置" class="headerlink" title="Celery应用配置"></a>Celery应用配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#项目名</span></span><br><span class="line">[program:celery]</span><br><span class="line"><span class="comment">#脚本目录</span></span><br><span class="line">directory=/root/social_engineering/</span><br><span class="line"><span class="comment">#脚本执行命令</span></span><br><span class="line"><span class="built_in">command</span>=/root/anaconda3/bin/celery -A tasks worker --loglevel=info</span><br><span class="line"></span><br><span class="line"><span class="comment">#supervisor启动的时候是否随着同时启动，默认True</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#程序崩溃时自动重启</span></span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line"><span class="comment">#这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启动成功了。默认值为1</span></span><br><span class="line">startsecs=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#脚本运行的用户身份 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#日志输出 </span></span><br><span class="line">stderr_logfile=/tmp/celery_stderr.log</span><br><span class="line">stdout_logfile=/tmp/celery_stdout.log</span><br><span class="line"><span class="comment">#把stderr重定向到stdout，默认 false</span></span><br><span class="line">redirect_stderr = <span class="literal">true</span></span><br><span class="line"><span class="comment">#stdout日志文件大小，默认 50MB</span></span><br><span class="line">stdout_logfile_maxbytes = 20</span><br><span class="line"><span class="comment">#stdout日志文件备份数</span></span><br><span class="line">stdout_logfile_backups = 20</span><br></pre></td></tr></table></figure><h3 id="Redis服务配置"><a href="#Redis服务配置" class="headerlink" title="Redis服务配置"></a>Redis服务配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[program:zedis]</span><br><span class="line"><span class="built_in">command</span>=/opt/zedis/redis-server /opt/zedis/redis.conf</span><br><span class="line">user=redisuser</span><br><span class="line">autostart=<span class="literal">true</span>                         </span><br><span class="line">;启动supervisord的时候会将该配置项设置为<span class="literal">true</span>的所有进程自动启动</span><br><span class="line">stopasgroup=<span class="literal">true</span>                    </span><br><span class="line">;使用supervisorctl停止zedis时，子进程也会一起停止</span><br><span class="line">killasgroup=<span class="literal">true</span>                    </span><br><span class="line">;向进程组发送<span class="built_in">kill</span>信号，包括子进程</span><br><span class="line">startsecs=10                        </span><br><span class="line">;进程从STARING状态转换到RUNNING状态所需要保持运行10s时间</span><br><span class="line">startretries=3                      </span><br><span class="line">;启动失败自动重试次数，默认是3</span><br><span class="line">autorestart=<span class="literal">true</span>                    </span><br><span class="line">;进程停止后自动启动</span><br><span class="line">stdout_logfile=/var/log/zedis-out</span><br><span class="line">stdout_logfile_maxbytes=1MB</span><br><span class="line">stdout_logfile_backups=10</span><br><span class="line">stderr_logfile=/var/log/zedis-err</span><br><span class="line">stderr_logfile_maxbytes=1MB</span><br><span class="line">stderr_logfile_backups=10</span><br></pre></td></tr></table></figure><ul><li>Ø 因为无法监视后台进程，需要把Zedis前台运行（daemonize no），否则会识别不到Zedis启动，重试启动3次,日志提示6379已占用。</li><li>Ø 因为redis.conf指定了logfile，stdout_logfile并无内容输出；如果不指定redis.conf只是启动redis-server，日志会输出到stdout_logfile。</li></ul><h3 id="组应用配置"><a href="#组应用配置" class="headerlink" title="组应用配置"></a>组应用配置</h3><ul><li>新建文件，fastapi_app.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[group:fastapi]</span><br><span class="line">programs=fastapi-app</span><br><span class="line"></span><br><span class="line">[program:fastapi-1]</span><br><span class="line"><span class="built_in">command</span>=/home/python/scripts/fastapi1_app.sh</span><br><span class="line">directory=/home/python/fastapi-1-backend</span><br><span class="line">user=python</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">redirect_stderr=<span class="literal">false</span></span><br><span class="line">loglevel=info</span><br><span class="line">stopsignal=KILL</span><br><span class="line">stopasgroup=<span class="literal">true</span></span><br><span class="line">killasgroup=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:fastapi-2]</span><br><span class="line"><span class="built_in">command</span>=/home/python/scripts/fastapi-2.sh</span><br><span class="line">directory=/home/python/fastapi-2-backend</span><br><span class="line">user=python</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">redirect_stderr=<span class="literal">false</span></span><br><span class="line">loglevel=info</span><br><span class="line">stopsignal=KILL</span><br><span class="line">stopasgroup=<span class="literal">true</span></span><br><span class="line">killasgroup=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><h3 id="问题1：sock文件不存在"><a href="#问题1：sock文件不存在" class="headerlink" title="问题1：sock文件不存在"></a>问题1：sock文件不存在</h3><p><strong>问题描述</strong>：<code>unix:///tmp/supervisor.sock no such file</code></p><p>**根源分析：**在supervisor默认配置中，其启动的sock等都会放到tmp目录，而tmp目录会自动清理导致无法使用supervisorctl</p><p><strong>解决方案</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改主配置文件中的tmp路径</span></span><br><span class="line">sed -i <span class="string">&#x27;s|/tmp/supervisor|/var/run/supervisor|g&#x27;</span> /etc/supervisord.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建所需目录并设置权限</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/supervisor</span><br><span class="line"><span class="built_in">chmod</span> 755 /var/run/supervisor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启supervisor</span></span><br><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><h3 id="问题2：进程不断重启"><a href="#问题2：进程不断重启" class="headerlink" title="问题2：进程不断重启"></a>问题2：进程不断重启</h3><p><strong>问题描述</strong>：进程启动后Supervisor不断尝试重启</p><p><strong>解决方案</strong>：</p><ul><li>确保管理的进程以前台方式运行</li><li>检查进程启动命令是否正确</li><li>查看日志文件定位具体问题</li></ul><h3 id="问题3：启动了多个supervisord服务，导致无法正常关闭服务"><a href="#问题3：启动了多个supervisord服务，导致无法正常关闭服务" class="headerlink" title="问题3：启动了多个supervisord服务，导致无法正常关闭服务"></a>问题3：启动了多个supervisord服务，导致无法正常关闭服务</h3><p><strong>问题描述</strong>：在运行<code>supervisord -c /etc/supervisord.conf</code>之前，直接运行过&#96;&#96;supervisord -c &#x2F;etc&#x2F;supervisord.d&#x2F;xx.conf&#96;导致有些进程被多个superviord管理，无法正常关闭进程</p><p><strong>解决方案</strong>：</p><ul><li>使用<code>ps -fe | grep supervisord</code>查看所有启动过的supervisord服务，kill相关的进程。</li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>Supervisor是一款强大且灵活的进程管理工具，合理配置显著提升服务的稳定性和可维护性。本文从安装配置、基础使用到进阶使用全面介绍了Supervisor的使用方法， 希望能帮助你在实际工作中更好地运用这一工具。</p><p>最佳实践建议：</p><ul><li>为每个服务创建独立的配置文件</li><li>合理配置日志轮转，避免磁盘空间不足</li><li>使用Web界面进行日常监控和管理</li><li>设置进程分组，简化管理操作</li><li>配置开机启动，确保服务可靠性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;失踪人口回归：Supervisor时隔三年再更新&quot;&gt;&lt;a href=&quot;#失踪人口回归：Supervisor时隔三年再更新&quot; class=&quot;headerlink&quot; title=&quot;失踪人口回归：Supervisor时隔三年再更新&quot;&gt;&lt;/a&gt;失踪人口回归：Supervi</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="进程管理" scheme="http://sswfive.xyz/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
