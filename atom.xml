<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AInLife</title>
  
  <subtitle>BluesSen Blog</subtitle>
  <link href="http://sswfive.xyz/atom.xml" rel="self"/>
  
  <link href="http://sswfive.xyz/"/>
  <updated>2026-01-28T17:24:17.000Z</updated>
  <id>http://sswfive.xyz/</id>
  
  <author>
    <name>BluesSen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Claude Code的架构设计浅析Agent</title>
    <link href="http://sswfive.xyz/2026/01/29/260128-understrand-agent-from-design-of-claude-code/"/>
    <id>http://sswfive.xyz/2026/01/29/260128-understrand-agent-from-design-of-claude-code/</id>
    <published>2026-01-28T16:08:12.000Z</published>
    <updated>2026-01-28T17:24:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>AI编程工具的发展正在重新定义编程工作范式，从“执行者”到“指挥者”，并且AI编程工具如Claude Code代表了一种新的人机协作范式</p></blockquote><h2 id="关于Claude-Code"><a href="#关于Claude-Code" class="headerlink" title="关于Claude Code"></a>关于Claude Code</h2><h3 id="什么是Claude-Code？"><a href="#什么是Claude-Code？" class="headerlink" title="什么是Claude Code？"></a>什么是Claude Code？</h3><ul><li>Claude Code不仅仅是一个编程工具，它代表了一种范式，人们在使用它时不再只是把自然语言翻译成代码，而是在做设计、拆解问题、分配任务和组织多个智能体协作完成目标。</li><li>Claude Code更是一个可编程、可扩展、可组合的AI Agent框架。</li></ul><h3 id="Claude-Code的常用命令"><a href="#Claude-Code的常用命令" class="headerlink" title="Claude Code的常用命令"></a>Claude Code的常用命令</h3><ul><li><code>claude</code>: 启动交互模式</li><li><code>cluade &quot;任务描述&quot;</code>： 执行单次任务</li><li><code>claude -p &quot;问题&quot;</code>：快速查询后退出</li><li><code>claude -c</code>: 继续最近的对话</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Usage: claude [options] [<span class="built_in">command</span>] [prompt]</span><br><span class="line"></span><br><span class="line">Claude Code - starts an interactive session by default, use -p/--print <span class="keyword">for</span> non-interactive output</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  prompt                                            Your prompt</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  doctor                                            Check the health of your Claude Code auto-updater</span><br><span class="line">  install [options] [target]                        Install Claude Code native build. Use [target] to specify version (stable, latest, or specific version)</span><br><span class="line">  mcp                                               Configure and manage MCP servers</span><br><span class="line">  plugin                                            Manage Claude Code plugins</span><br><span class="line">  setup-token                                       Set up a long-lived authentication token (requires Claude subscription)</span><br><span class="line">  update                                            Check <span class="keyword">for</span> updates and install <span class="keyword">if</span> available</span><br></pre></td></tr></table></figure><h2 id="Claude-Code-技术架构"><a href="#Claude-Code-技术架构" class="headerlink" title="Claude Code 技术架构"></a>Claude Code 技术架构</h2><h3 id="基础层：-Memory"><a href="#基础层：-Memory" class="headerlink" title="基础层： Memory"></a>基础层： Memory</h3><p>Memory是一个记忆系统，它的核心文件是<code>CLAUDE.md</code>, 工作原理则是每次开启对话时，都会读取这个文件。（PS: 这样它就记住了你的项目规范，不需要每次重复说明）</p><p>不同级别下的CLAUDE.md文件</p><ul><li>全局（所有项目共用）：<code>~/.claude/CLAUDE.md</code></li><li>项目级（当前项目）：<code>项目根目录/CLAUDE.md</code></li><li>模块级（特定目录）：<code>项目根目录/.claude/rules/*.md</code></li></ul><p>示例</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Project: E-commerce Platform</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Tech Stack</span></span><br><span class="line"><span class="bullet">-</span> Frontend: React + TypeScript</span><br><span class="line"><span class="bullet">-</span> Backend: Node.js + Express</span><br><span class="line"><span class="bullet">-</span> Database: PostgreSQL</span><br><span class="line"></span><br><span class="line"><span class="section">## Code Style</span></span><br><span class="line"><span class="bullet">-</span> Use functional components</span><br><span class="line"><span class="bullet">-</span> Prefer async/await over .then()</span><br><span class="line"><span class="bullet">-</span> Maximum line length: 100 characters</span><br><span class="line"></span><br><span class="line"><span class="section">## Important Rules</span></span><br><span class="line"><span class="bullet">-</span> NEVER commit to main directly</span><br><span class="line"><span class="bullet">-</span> Always run tests before pushing</span><br></pre></td></tr></table></figure><h3 id="扩展层：四大核心组件"><a href="#扩展层：四大核心组件" class="headerlink" title="扩展层：四大核心组件"></a>扩展层：四大核心组件</h3><h4 id="Commands-斜杠命令"><a href="#Commands-斜杠命令" class="headerlink" title="Commands(斜杠命令)"></a>Commands(斜杠命令)</h4><p>是Claude Code内置或用户自定义的一系列核心能力，其触发方式是用户手动输入 <code>/command</code></p><p>是显式、可复用、可审计、通过斜杠命令固定触发的操作指令集，是相对固化的标准流程。</p><p>Commands 适合标准化操作： 团队统一的commit格式、固定的部署流程等。</p><h4 id="Skills-技能"><a href="#Skills-技能" class="headerlink" title="Skills(技能)"></a>Skills(技能)</h4><p>代表着AI的一系列专属能力组合，其触发方式是Claude自动判断（语义推理）是否激活相应技能。Skills可以是CC内置的，也可以是用户自己设定。</p><blockquote><p>与Tools的区别：</p><ul><li>Tools是外部能力接口， Skills是模型内部的“行为模式+触发逻辑”。</li><li>如果Tools是函数调用，Skill就是把if-else、prompt、策略和调用顺序，全部折叠进一个文档的整体封装，是对一个专有能力集的全面定义</li><li>Tools解决的是：我能不能做；Skill解决的是：我该不该做、怎么做、做到什么程度。</li></ul></blockquote><p>Skills的理念：是专家判断，而非流程执行。</p><h4 id="SubAgents-子代理"><a href="#SubAgents-子代理" class="headerlink" title="SubAgents(子代理)"></a>SubAgents(子代理)</h4><p>用于独立完成专项任务。其触发方式可以由Claude决定或用户指定。</p><p>原理是：主Claude发送任务，SubAgents执行任务，只把结果汇报给Claude.</p><p>适合隔离执行，比如高噪声任务，需求特定权限的任务、从大量日志心中寻找错误信息。</p><blockquote><p>与Skills的关系：</p><ul><li>和Skills类似，它本质上解决的是一个在Agent系统模块化必然出现的问题：单一Agent的上下文、权限与职责无法无限膨胀。</li></ul></blockquote><h4 id="Hooks-钩子"><a href="#Hooks-钩子" class="headerlink" title="Hooks(钩子)"></a>Hooks(钩子)</h4><p>是在特定事件触发自动执行的脚本，其触发方式是事件自动触发。</p><p>适合自动化检查类的任务：如格式化、安全检查、日志记录等</p><h3 id="集成层：连接外部信息"><a href="#集成层：连接外部信息" class="headerlink" title="集成层：连接外部信息"></a>集成层：连接外部信息</h3><h4 id="Headless-无头模式"><a href="#Headless-无头模式" class="headerlink" title="Headless(无头模式)"></a>Headless(无头模式)</h4><p>让Claude Code在没有人工交互的情况下运行，适合CI&#x2F;CD集成——自动化代码审查、自动修复、自动生成变更日志等。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># GitHub Actions 中</span></span><br><span class="line"><span class="bullet">-</span> name: Auto-fix code issues</span><br><span class="line">  run: claude --headless &quot;Fix all linting errors in src/&quot;</span><br></pre></td></tr></table></figure><h4 id="MCP-Model-Context-Protocol"><a href="#MCP-Model-Context-Protocol" class="headerlink" title="MCP(Model Context Protocol)"></a>MCP(Model Context Protocol)</h4><p>MCP让Claude连接外部工具和服务，适合工具连接，可以把任何外部系统变成Claude可调用的工具。</p><h3 id="编程接口层"><a href="#编程接口层" class="headerlink" title="编程接口层"></a>编程接口层</h3><h4 id="Agent-SDK"><a href="#Agent-SDK" class="headerlink" title="Agent SDK"></a>Agent SDK</h4><p>当配置式的扩展不够用时，可以用代码来驱动Claude.这种方式适合构建自定义Agent，完全控制执行流程、自定义工具、复杂工作流。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> claude_sdk <span class="keyword">import</span> ClaudeSDKClient</span><br><span class="line"></span><br><span class="line">client = ClaudeSDKClient()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行任务</span></span><br><span class="line">result = client.query(</span><br><span class="line">    prompt=<span class="string">&quot;Review this code for security issues&quot;</span>,</span><br><span class="line">    tools=[<span class="string">&quot;Read&quot;</span>, <span class="string">&quot;Grep&quot;</span>],</span><br><span class="line">    max_turns=<span class="number">10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Plugins-打包"><a href="#Plugins-打包" class="headerlink" title="Plugins:打包"></a>Plugins:打包</h3><p>当开发了一套好用的Command、Skills、Hooks组合，想要分享给团队或社区时，就需要用Plugins打包。</p><p>Plugins不是一种新能力，而是打包机制，类似npm打包js文件。Plugins把一组相关的Claude Code扩展打包在一起。</p><p>Plugins的价值在于可复用、可版本化、可分发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">my-team-plugin/</span><br><span class="line">├── commands/           <span class="comment"># 斜杠命令</span></span><br><span class="line">│   └── review.md</span><br><span class="line">├── skills/             <span class="comment"># 技能</span></span><br><span class="line">│   └── security-check/</span><br><span class="line">│       └── SKILL.md</span><br><span class="line">├── agents/             <span class="comment"># 子代理</span></span><br><span class="line">│   └── test-runner.md</span><br><span class="line">├── hooks/              <span class="comment"># 钩子</span></span><br><span class="line">│   └── pre-edit.sh</span><br><span class="line">└── plugin.json         <span class="comment"># 插件配置</span></span><br></pre></td></tr></table></figure><h2 id="四大核心组件场景与选型对照表"><a href="#四大核心组件场景与选型对照表" class="headerlink" title="四大核心组件场景与选型对照表"></a>四大核心组件场景与选型对照表</h2><table><thead><tr><th>组件</th><th>本质定位</th><th>谁触发</th><th>决策权在谁</th><th>适合解决的问题</th><th>不适合做什么</th><th>典型一句话总结</th></tr></thead><tbody><tr><td>Commands (斜杠命令)</td><td>人工触发的标准操作流程（SOP）</td><td>用户 &#x2F; command</td><td>人</td><td>固定流程、可复现操作、团队统一规范</td><td>依赖语义判断、需要灵活决策的任务</td><td>“按我写好的步骤，严格执行”</td></tr><tr><td>Skills (技能)</td><td>模型内部的专家行为模式</td><td>Claude自动（语义推理）</td><td>模型</td><td>领域能力、上下文判断、策略可变的问题</td><td>纯机械、无判断空间的操作</td><td>“我判断这是我的专业领域，让我像专家一样来”</td></tr><tr><td>SubAgents (子代理)</td><td>独立上下文与权限的执行单元</td><td>Claude或用户</td><td>架构设计</td><td>高噪声任务、权限隔离、并行处理</td><td>简单一步就能完成的任务</td><td>“这件事我不亲自干，交给专人处理”</td></tr><tr><td>Hooks (钩子)</td><td>事件触发的强制规则</td><td>系统事件</td><td>系统事件</td><td>安全、合规、自动化校验</td><td>需要权衡、讨论、模糊判断的事情</td><td>“不管你想不想，这条规则必须执行”</td></tr></tbody></table><h2 id="Agent协作的常见的痛点与解决方案"><a href="#Agent协作的常见的痛点与解决方案" class="headerlink" title="Agent协作的常见的痛点与解决方案"></a>Agent协作的常见的痛点与解决方案</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>解决Agent每次对话都“从零开始”、不理解项目背景的问题，让AI真正记住你的代码结构、约束和上下文。</p><h3 id="Sub-Agents"><a href="#Sub-Agents" class="headerlink" title="Sub-Agents"></a>Sub-Agents</h3><p>解决单一Agent角色混乱、上下文污染、又写代码又审查的问题，通过职责拆分实现关注点分离。</p><h3 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h3><p>解决Prompt不可复用、经验无法沉淀、团队能力难以传承的问题，把个人技巧变成可组合的工程资产。</p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>解决Agent执行过程不可控、缺乏检查点、容易“越权操作”的问题，在关键点引入自动校验和人工兜底。</p><h3 id="Headless"><a href="#Headless" class="headerlink" title="Headless"></a>Headless</h3><p>解决Agent只能在IDE里交互、无法自动化流程的问题，让AI能在CI&#x2F;CD中无人值守地运行。</p><h3 id="Agent-SDK-1"><a href="#Agent-SDK-1" class="headerlink" title="Agent SDK"></a>Agent SDK</h3><p>解决只会用对话的方式使用Agent,难以嵌入现有系统和工作流的问题，用代码驱动Agent，构建可编排的工程流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;AI编程工具的发展正在重新定义编程工作范式，从“执行者”到“指挥者”，并且AI编程工具如Claude Code代表了一种新的人机协作范式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于Claude-Code&quot;&gt;&lt;a href=&quot;#关于Cl</summary>
      
    
    
    
    <category term="LLM与AI应用" scheme="http://sswfive.xyz/categories/LLM%E4%B8%8EAI%E5%BA%94%E7%94%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>不止Rust，uv如此速度的背后真实原因</title>
    <link href="http://sswfive.xyz/2026/01/06/tech/python/260106-why-is-uv-so-fast/"/>
    <id>http://sswfive.xyz/2026/01/06/tech/python/260106-why-is-uv-so-fast/</id>
    <published>2026-01-06T08:09:26.000Z</published>
    <updated>2026-01-06T09:18:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在众多Python包管理工具中，uv的热度近两年持续攀升，并受到越来越多的开发者的认可与采用。一个关键原因是，uv被公认为目前社区中依赖管理速度最快的工具。尽管许多人将其出色的性能归功于其采用Rust语言开发，但实际上，uv的性能表现更主要源于其开发团队的设计思路和工程决策。</p><blockquote><p>设计选择比编程语言更能计策工具的性能上限。</p></blockquote><h2 id="一、Python打包标准的演进"><a href="#一、Python打包标准的演进" class="headerlink" title="一、Python打包标准的演进"></a>一、Python打包标准的演进</h2><p>在早期，pip的缓慢并非实现问题，而是被历史包袱所累。主要有以下几个原因：</p><blockquote><p>setup.py的致命缺陷</p></blockquote><p>过去，要安装一个包，必须运行其setup.py才能知道依赖，但运行setup.py,又需要先安装它的构建依赖——形成了典型的“鸡生蛋蛋生鸡”的问题，这迫使pip不得不：</p><ul><li>下载源码包</li><li>执行不受信任的任意代码</li><li>失败后重试，反复生成子进程</li><li>整个过程像<code>curl | bash</code> ，既慢又危险</li></ul><p>PEP的出现解决了上述问题：</p><ul><li>PEP 518（2016）：引入<code>pyproject.toml</code> ,允许声明式指定构建依赖</li><li>PEP 517（2017）：分离构建前后端，pip不再需要理解setuptools内部</li><li>PEP 621（2020）：标准化<code>[project]</code>表，依赖信息可直接从TOML解决</li><li>PEP 658（2022， PyPI 2023年上线）：在Simple API 中直接提供wheel元数据，无需下载整个文件即可获取依赖。</li></ul><p>从上述的时间线可以看出，uv之所以快，是因为生态系统终于有了支持它的基础设施。</p><ul><li><blockquote><p>Tips: PEP 658 在 2023 年 5 月上线 PyPI，而 uv 在 2024 年 2 月发布</p></blockquote></li></ul><h2 id="二、设计取舍：uv主动“放弃”的功能"><a href="#二、设计取舍：uv主动“放弃”的功能" class="headerlink" title="二、设计取舍：uv主动“放弃”的功能"></a>二、设计取舍：uv主动“放弃”的功能</h2><p>uv 的速度很大程度上源于 <strong>有意识地剔除兼容性负担</strong>。它明确不支持以下 pip 支持的功能：</p><table><thead><tr><th>功能</th><th>uv 的处理</th><th>性能收益</th></tr></thead><tbody><tr><td><strong>.egg 格式</strong></td><td>完全不支持（已淘汰十余年）</td><td>避免解析旧格式的开销</td></tr><tr><td><strong>pip.conf 配置</strong></td><td>忽略所有 pip 配置文件</td><td>省去配置解析、继承、环境变量查找</td></tr><tr><td><strong>字节码编译（.pyc）</strong></td><td>默认跳过（可选开启）</td><td>减少每次安装的 I&#x2F;O 和 CPU 开销</td></tr><tr><td><strong>系统 Python 安装</strong></td><td>强制使用虚拟环境（除非显式指定）</td><td>省去权限检查、安全防护逻辑</td></tr><tr><td><strong>宽松包规范容忍</strong></td><td>严格拒绝不符合标准的包</td><td>避免 fallback 逻辑和异常处理</td></tr><tr><td><strong>requires-python 上界</strong></td><td>忽略 <code>python&lt;4.0</code> 这类上界</td><td>极大减少依赖解析器回溯</td></tr><tr><td><strong>多索引源行为</strong></td><td>“第一个索引命中即停”</td><td>避免跨多个仓库查询</td></tr></tbody></table><blockquote><p><strong>核心理念</strong>：每一条被移除的代码路径，都是用户等待时间的节省。</p></blockquote><h2 id="三、可移植优化：与语言无关的提速实现"><a href="#三、可移植优化：与语言无关的提速实现" class="headerlink" title="三、可移植优化：与语言无关的提速实现"></a>三、可移植优化：与语言无关的提速实现</h2><ol><li>HTTP Range 请求获取元数据<ul><li>wheel是zip文件，目录在末尾。uv优先使用PEP 658元数据 ，否则用Range请求只下载zip目录， 最后才全量下载，这覆盖了绝大部分的场景。</li></ul></li><li>并行下载<ul><li>pip 串行下载；uv 并发下载多个包。</li></ul></li><li>全局缓存 + 硬链接<ul><li>pip每次复制文件到venv; uv 全局存一份，通过硬链接共享。10个venv安装同一个包约等于1份磁盘空间。</li></ul></li><li>无Python的依赖解析<ul><li>uv直接解析TOML和wheel元数据。仅在遇到纯setup.py包时才调用Python子进程。</li></ul></li><li>PubGrub依赖解析算法<ul><li>来自Dart的pub,采用冲突驱动子句学习（CDCL）。比pip的回溯更智能；失败时记录原因，避免重复探索。更快解决复杂依赖，且错误提示更清晰。pip完全可以集成PubGrub，无需重写。</li></ul></li></ol><h2 id="四、Rust发挥作用的地方"><a href="#四、Rust发挥作用的地方" class="headerlink" title="四、Rust发挥作用的地方"></a>四、Rust发挥作用的地方</h2><ul><li>零拷贝反序列化（rkyv）：缓存数据直接映射为内存结构，无需解析、拷贝</li><li>真正的线程级并行：Python受GIL限制，并行需多进程 + IPC；Rust可高效共享内存并行</li><li>无解释器启动开销：uv是静态二进制，启动即运行；pip每次子进程都需要加载Python解释器</li><li>紧凑的版本表示：90%+ 的版本号可压缩为当个u64，加速比较与哈希（微优化，但在百万次操作中显著）</li></ul><blockquote><p>启发： </p><ul><li>如果你的生态系统需要运行任意代码才能发现包的依赖关系，那它就已经输了</li><li>性能提升往往不是靠换语言，而是靠重新思考“什么才是真正必要的”</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在众多Python包管理工具中，uv的热度近两年持续攀升，并受到越来越多的开发者的认可与采用。一个关键原因是，uv被公认为目前社区中依赖管理速度最快的工具。尽管许多人将其出色的性能归功于其采用Rust语言开发，但实际上，uv的性能表现更主要源于其开发团队的设计思路和工程决策</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="包管理工具" scheme="http://sswfive.xyz/tags/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python开发者必知的性能数据与实用技巧</title>
    <link href="http://sswfive.xyz/2026/01/04/tech/python/260104-py-performace-analysis-and-practice/"/>
    <id>http://sswfive.xyz/2026/01/04/tech/python/260104-py-performace-analysis-and-practice/</id>
    <published>2026-01-04T06:59:55.000Z</published>
    <updated>2026-01-04T17:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常开发中，我们常常凭借直觉选择数据结构、编写函数、或决定是否使用异步。然而在Python中，那些”看起来差不多“的操作，实际开销可能相差几个数量级。</p><p>最近读到一篇文章《<a href="https://mkennedy.codes/posts/python-numbers-every-programmer-should-know/">Python Numbers Every Programmer Should Know</a>》，作者通过实测给出了常见操作的时间与内存开销，这些数字不仅令人惊叹，更能指导我们写出更高效、更省资源的代码。</p><p>本文将结合原文内容与实践经验，分享一些关键的性能认知与开发技巧。</p><h2 id="一、内存开销：看不见的资源消耗"><a href="#一、内存开销：看不见的资源消耗" class="headerlink" title="一、内存开销：看不见的资源消耗"></a>一、内存开销：看不见的资源消耗</h2><p>Python的便利性背后，是显著的内存开销。理解这些开销，是处理大数据集或高并发应用的前提。</p><p><strong>1. 基础对象的“体重”</strong></p><ul><li>一个空的字符串 <code>&quot;&quot;</code> 重达 <strong>41字节</strong>。</li><li>一个小整数（如 <code>1</code>）占用 <strong>28字节</strong>（得益于-5到256的整数池缓存，相同小整数是共享的）。</li><li>一个空列表 <code>[]</code> 需要 <strong>56字节</strong>，一个空字典 <code>&#123;&#125;</code> 需要 <strong>64字节</strong>。</li></ul><p><strong>2. 集合的容量增长</strong><br>当存储1000个元素时，不同数据结构的内存效率差异显著：</p><ul><li>列表（1000个整数）：<strong>约36 KB</strong></li><li>字典（1000个键值对）：<strong>约91 KB</strong> (是列表的2.5倍)</li><li>集合（1000个成员）：<strong>约60 KB</strong></li></ul><p><strong>3. 类的内存激增</strong><br>面向对象编程的便利伴随着成本。一个具有5个属性的普通类实例占用约 <strong>694字节</strong>。如果程序中需要创建成千上万个实例，内存压力会急剧上升。</p><h2 id="二、常见操作的性能概览：从纳秒到毫秒"><a href="#二、常见操作的性能概览：从纳秒到毫秒" class="headerlink" title="二、常见操作的性能概览：从纳秒到毫秒"></a>二、常见操作的性能概览：从纳秒到毫秒</h2><p>让我们看一下”性能金字塔”，从最快的操作到较慢的操作：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">属性读取 (obj.x)                         14 ns</span><br><span class="line">字典查询                                 22 ns</span><br><span class="line">函数调用（空函数）                         22 ns</span><br><span class="line">列表追加                                 29 ns</span><br><span class="line">f-string 格式化                          65 ns</span><br><span class="line">异常捕获                                 140 ns</span><br><span class="line">orjson 序列化复杂对象                     310 ns</span><br><span class="line">json 反序列化简单对象                     714 ns</span><br><span class="line">遍历 1000 个元素的列表                    7.9 μs</span><br><span class="line">打开并关闭文件                            9.1 μs</span><br><span class="line">SQLite 主键查询                          3.6 μs</span><br><span class="line">写入 1KB 文件                            35 μs</span><br><span class="line">MongoDB find_one                        121 μs</span><br><span class="line">SQLite 插入（带提交）                     192 μs</span><br><span class="line">导入 json 模块                           2.9 ms</span><br><span class="line">导入 asyncio 模块                        18 ms</span><br><span class="line">导入 fastapi 模块                        104 ms</span><br></pre></td></tr></table></figure><p>数据说话：</p><ul><li>基本操作（属性访问、字典查询）在纳秒级</li><li>文件操作和数据库操作在微秒到毫秒级</li><li>模块导入可能比你想象的慢的多</li></ul><h2 id="三、数据结构选择：性能差距可达200倍"><a href="#三、数据结构选择：性能差距可达200倍" class="headerlink" title="三、数据结构选择：性能差距可达200倍"></a>三、数据结构选择：性能差距可达200倍</h2><p> 列表 vs 字典 vs 集合的成员检查，在 1000 个元素中查找一个元素：</p><table><thead><tr><th>数据结构</th><th>耗时</th><th>每秒操作数</th></tr></thead><tbody><tr><td><strong>集合</strong><code>item in set</code></td><td>19 ns</td><td>52.7M ops&#x2F;sec</td></tr><tr><td><strong>字典</strong><code>item in dict</code></td><td>22 ns</td><td>45.7M ops&#x2F;sec</td></tr><tr><td><strong>列表</strong><code>item in list</code></td><td>3,850 ns</td><td>259.6k ops&#x2F;sec</td></tr></tbody></table><p>数据说话：</p><ul><li><p>结论：列表比集合&#x2F;字典慢 200 倍！本质原因：集合和字典使用哈希表，时间复杂度 O(1)，列表需要线性扫描，时间复杂度 O(n)</p></li><li><p>实践建议</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐：频繁的成员检查</span></span><br><span class="line">allowed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;charlie&#x27;</span>, ...]  <span class="comment"># 列表</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">in</span> allowed_users:  <span class="comment"># 慢！</span></span><br><span class="line">    process()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐：使用集合</span></span><br><span class="line">allowed_users = &#123;<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;charlie&#x27;</span>, ...&#125;  <span class="comment"># 集合</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">in</span> allowed_users:  <span class="comment"># 快 200 倍！</span></span><br><span class="line">    process()</span><br></pre></td></tr></table></figure><h2 id="四、列表推导式真的更快"><a href="#四、列表推导式真的更快" class="headerlink" title="四、列表推导式真的更快"></a>四、列表推导式真的更快</h2><ul><li>对比生成 1000 个元素：</li></ul><table><thead><tr><th>方法</th><th>耗时</th><th>性能提升</th></tr></thead><tbody><tr><td><strong>列表推导式</strong></td><td>9.45 μs</td><td>+26%</td></tr><tr><td><strong>for 循环 + append</strong></td><td>11.9 μs</td><td>基准</td></tr></tbody></table><p>数据说话：</p><ul><li>原因：列表推导式在 C 层面优化，减少了 Python 层面的函数调用开销。</li></ul><h2 id="五、内存优化：强大的-slots"><a href="#五、内存优化：强大的-slots" class="headerlink" title="五、内存优化：强大的__slots__"></a>五、内存优化：强大的<code>__slots__</code></h2><p>单个对象的内存占用</p><table><thead><tr><th>类型</th><th>5个属性的实例</th><th>内存节省</th></tr></thead><tbody><tr><td>普通类</td><td>694 bytes</td><td>-</td></tr><tr><td><code>__slots__</code>类</td><td>212 bytes</td><td><strong>69%</strong></td></tr><tr><td>dataclass</td><td>694 bytes</td><td>-</td></tr><tr><td>dataclass(slots&#x3D;True)</td><td>212 bytes</td><td><strong>69%</strong></td></tr></tbody></table><p>1000 个实例的集合</p><table><thead><tr><th>类型</th><th>总内存</th><th>内存节省</th></tr></thead><tbody><tr><td>1000 个普通实例</td><td>301.8 KB</td><td>-</td></tr><tr><td>1000 个 slots 实例</td><td>215.7 KB</td><td><strong>28%</strong></td></tr></tbody></table><p><strong>使用</strong> <code>__slots__</code> 的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, email, age, city, score</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.email = email</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.city = city</span><br><span class="line">        <span class="variable language_">self</span>.score = score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __slots__（节省 69% 内存）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, email, age, city, score</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.email = email</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.city = city</span><br><span class="line">        <span class="variable language_">self</span>.score = score</span><br></pre></td></tr></table></figure><p><strong>访问速度几乎相同</strong>：</p><ul><li>普通类读取：14.1 ns</li><li>slots 类读取：14.1 ns</li></ul><p><strong>何时使用</strong> <code>__slots__</code>：</p><ul><li>需要创建大量实例（数千个以上）</li><li>属性固定且已知</li><li>内存受限的环境（如游戏实体、缓存项、日志记录）</li></ul><p><strong>不适用场景：</strong></p><ul><li>需要动态添加属性</li><li>需要使用 <code>__dict__</code> 或 <code>__weakref__</code></li></ul><blockquote><p>tips: Python便利性背后，是显著的内存开销。对于需要海量创建的小型数据对象，优先考虑使用<code>namedtuple</code>、<code>dataclass</code>或手动定义<code>__slots__</code>，可以带来巨大的内存节约</p></blockquote><h2 id="六、JSON-序列化：选对库提速-8-倍"><a href="#六、JSON-序列化：选对库提速-8-倍" class="headerlink" title="六、JSON 序列化：选对库提速 8 倍"></a>六、JSON 序列化：选对库提速 8 倍</h2><p>复杂对象序列化性能对比</p><table><thead><tr><th>JSON 库</th><th>序列化耗时</th><th>反序列化耗时</th><th>相对标准库</th></tr></thead><tbody><tr><td><strong>orjson</strong></td><td>310 ns</td><td>839 ns</td><td><strong>8.5x 更快</strong></td></tr><tr><td><strong>msgspec</strong></td><td>445 ns</td><td>850 ns</td><td><strong>6x 更快</strong></td></tr><tr><td>ujson</td><td>1.64 μs</td><td>1.46 μs</td><td>1.6x 更快</td></tr><tr><td>json (标准库)</td><td>2.65 μs</td><td>2.22 μs</td><td>基准</td></tr></tbody></table><p>数据说话：</p><ul><li>Python 的标准库稳定可靠，但在性能敏感场景，第三方库往往更胜一筹。如果你的 API 需要高频返回 JSON，换一个序列化库可能就解决了瓶颈。</li></ul><h2 id="七、Web-框架性能对比"><a href="#七、Web-框架性能对比" class="headerlink" title="七、Web 框架性能对比"></a>七、Web 框架性能对比</h2><p>返回简单 JSON 响应的基准测试：</p><table><thead><tr><th>框架</th><th>平均响应时间</th><th>每秒请求数</th><th>相对性能</th></tr></thead><tbody><tr><td><strong>Starlette</strong></td><td>8.01 μs</td><td>124.8k</td><td>最快</td></tr><tr><td><strong>Litestar</strong></td><td>8.19 μs</td><td>122.1k</td><td>1.02x</td></tr><tr><td><strong>FastAPI</strong></td><td>8.63 μs</td><td>115.9k</td><td>1.08x</td></tr><tr><td><strong>Flask</strong></td><td>16.5 μs</td><td>60.7k</td><td>2.06x</td></tr><tr><td><strong>Django</strong></td><td>18.1 μs</td><td>55.4k</td><td>2.26x</td></tr></tbody></table><p>数据说话：</p><ol><li>现代异步框架（Starlette、FastAPI、Litestar）性能相近</li><li>FastAPI 比 Django 快约 <strong>2 倍</strong></li><li>传统同步框架（Flask、Django）相对较慢</li></ol><p><strong>框架选择建议</strong>：</p><ul><li><strong>高性能 API</strong>：Starlette、Litestar、FastAPI</li><li><strong>快速原型</strong>：Flask</li><li><strong>全功能应用</strong>：Django</li><li><strong>性能不是唯一考量</strong>：还要考虑生态系统、团队熟悉度、项目需求</li></ul><h2 id="八、数据库操作性能"><a href="#八、数据库操作性能" class="headerlink" title="八、数据库操作性能"></a>八、数据库操作性能</h2><p>SQLite、diskcache、MongoDB 对比</p><table><thead><tr><th>操作</th><th>SQLite</th><th>diskcache</th><th>MongoDB</th></tr></thead><tbody><tr><td><strong>写入</strong></td><td>192 μs</td><td>23.9 μs</td><td>119 μs</td></tr><tr><td><strong>主键读取</strong></td><td>3.57 μs</td><td>4.25 μs</td><td>121 μs</td></tr><tr><td><strong>字段查询</strong></td><td>4.27 μs</td><td>N&#x2F;A</td><td>124 μs</td></tr><tr><td><strong>更新</strong></td><td>5.22 μs</td><td>23.9 μs</td><td>115 μs</td></tr></tbody></table><p>数据说话：</p><ul><li><strong>SQLite 读取极快</strong>（微秒级），适合读多写少</li><li><strong>diskcache 写入最快</strong>，适合缓存场景</li><li><strong>MongoDB 受网络延迟影响</strong>，进程内数据库（SQLite）更快</li></ul><h2 id="九、字符串格式化：f-string-的优势"><a href="#九、字符串格式化：f-string-的优势" class="headerlink" title="九、字符串格式化：f-string 的优势"></a>九、字符串格式化：f-string 的优势</h2><table><thead><tr><th>格式化方法</th><th>耗时</th><th>相对性能</th></tr></thead><tbody><tr><td>字符串拼接 <code>+</code></td><td>39.1 ns</td><td>最快（简单场景）</td></tr><tr><td><strong>f-string</strong></td><td>64.9 ns</td><td><strong>推荐</strong></td></tr><tr><td><code>%</code>格式化</td><td>89.8 ns</td><td>1.4x 慢</td></tr><tr><td><code>.format()</code></td><td>103 ns</td><td>1.6x 慢</td></tr></tbody></table><p>数据说话：</p><ul><li>f-string 在性能和可读性之间达到了最佳平衡，应作为首选。</li></ul><h2 id="十、异步（Async）不是银弹，它有成本"><a href="#十、异步（Async）不是银弹，它有成本" class="headerlink" title="十、异步（Async）不是银弹，它有成本"></a>十、异步（Async）不是银弹，它有成本</h2><p>同步 vs 异步函数调用</p><table><thead><tr><th>操作</th><th>耗时</th><th>倍数差异</th></tr></thead><tbody><tr><td>同步函数调用</td><td>20.3 ns</td><td>基准</td></tr><tr><td>异步函数调用</td><td>28.2 μs</td><td><strong>1,400x 慢</strong></td></tr></tbody></table><p>异步操作的开销</p><table><thead><tr><th>操作</th><th>耗时</th></tr></thead><tbody><tr><td>创建协程对象</td><td>47 ns</td></tr><tr><td><code>run_until_complete</code><br><br>空协程</td><td>27.6 μs</td></tr><tr><td><code>asyncio.sleep(0)</code></td><td>39.4 μs</td></tr><tr><td><code>gather</code><br><br>10 个协程</td><td>55 μs</td></tr></tbody></table><p>关键认知：很多人以为“用了 async 就更快”，但事实并非如此。</p><ul><li>启动一次空的 <code>asyncio</code> 事件循环：<strong>～28 微秒</strong></li><li>调用一个普通函数：<strong>～20 纳秒</strong></li><li>async 的启动开销比一次磁盘 I&#x2F;O（～10 微秒）还要大！</li></ul><p>这意味着：</p><ul><li>如果你的任务是 CPU 密集型（如图像处理、数值计算），async 不仅没用，反而拖慢速度。</li><li>如果你只是调用一次数据库或 API，同步代码更简单、更快。</li><li><strong>只有当你需要同时处理成百上千个 I&#x2F;O 请求时（如聊天服务器、爬虫），async 才真正发挥价值。</strong></li></ul><h2 id="十一、异常处理的成本"><a href="#十一、异常处理的成本" class="headerlink" title="十一、异常处理的成本"></a>十一、异常处理的成本</h2><table><thead><tr><th>操作</th><th>耗时</th><th>倍数差异</th></tr></thead><tbody><tr><td>try&#x2F;except（无异常）</td><td>21.5 ns</td><td>基准</td></tr><tr><td>try&#x2F;except（有异常）</td><td>139 ns</td><td><strong>6.5x 慢</strong></td></tr></tbody></table><p><strong>最佳实践</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不要用异常控制正常流程</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">d, key</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> d[key]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 异常路径慢 6.5 倍</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用条件判断</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">d, key</span>):</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> d:</span><br><span class="line">        <span class="keyword">return</span> d[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 dict.get()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">d, key</span>):</span><br><span class="line">    <span class="keyword">return</span> d.get(key)</span><br></pre></td></tr></table></figure><h2 id="十二、必须警惕的“性能陷阱”"><a href="#十二、必须警惕的“性能陷阱”" class="headerlink" title="十二、必须警惕的“性能陷阱”"></a>十二、必须警惕的“性能陷阱”</h2><ol><li><strong>异常滥用</strong>：<code>try/except</code> 在无异常发生时开销很小（21.5 ns），但<strong>一旦触发并捕获异常，成本激增至约140 ns</strong>，是正常流程的6-7倍。切勿将异常用于常规控制流。</li><li><strong>昂贵的导入</strong>：如前述，<strong>大型模块的首次导入成本极高</strong>。在设计需要快速启动的CLI工具或Lambda函数时，应考虑延迟导入或减少依赖。</li><li><strong>列表的成员检查</strong>：在1000个元素的列表中检查成员，需要 <strong>3.85 µs</strong>，而等量集合的成员检查仅需 <strong>19 ns</strong>，<strong>快200倍以上</strong>。<strong>频繁的成员检查，务必使用集合（set）</strong>。</li><li><strong>写文件 vs 读文件</strong>：写入1KB数据（35 µs）比读取（10 µs）<strong>慢3.5倍</strong>，比单纯打开关闭文件（9 µs）<strong>慢近4倍</strong>。对写操作密集的程序，缓冲和批量写入策略尤为重要。</li></ol><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>理解这些性能数字不是为了过早优化，而是为了在架构设计和关键路径上做出明智的决策。</p><blockquote><p>“过早优化是万恶之源。” —— Donald Knuth</p></blockquote><p>但同时，了解基本的性能特性可以帮助我们避免明显的性能陷阱.</p><p>性能优化的黄金原则：</p><ol><li>先让代码正确运行</li><li>用 <code>cProfile</code>、<code>py-spy</code> 等工具定位瓶颈</li><li>针对瓶颈做有针对性的优化</li><li>用基准测试验证效果</li></ol><p><strong>真正的性能艺术，是在开发效率、可读性与执行效率之间找到平衡</strong>。不必对每个纳秒斤斤计较，但要对数量级（倍数的差异）保持敏感**。</p><p>希望这些”应该知道的数字”，能帮助我们写出不仅正确，而且优雅高效的 Python 代码。</p><p><strong>参考资源</strong>：</p><ul><li>原文：<a href="https://mkennedy.codes/posts/python-numbers-every-programmer-should-know/">Python Numbers Every Programmer Should Know</a></li><li>测试代码：<a href="https://github.com/mikeckennedy/python-numbers-everyone-should-know">GitHub Repository</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常开发中，我们常常凭借直觉选择数据结构、编写函数、或决定是否使用异步。然而在Python中，那些”看起来差不多“的操作，实际开销可能相差几个数量级。&lt;/p&gt;
&lt;p&gt;最近读到一篇文章《&lt;a href=&quot;https://mkennedy.codes/posts/python</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python工程实践" scheme="http://sswfive.xyz/tags/python%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>从前端视角理解浏览器和HTTP的缓存机制</title>
    <link href="http://sswfive.xyz/2025/11/06/tech/others/251116-browser-cache/"/>
    <id>http://sswfive.xyz/2025/11/06/tech/others/251116-browser-cache/</id>
    <published>2025-11-06T01:45:49.000Z</published>
    <updated>2025-11-07T02:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h2><p>我们都知道，一个典型的Web应用请求-响应流程通常如下所示：</p><ul><li><blockquote><p>客户端 -&gt; 发起HTTP请求 -&gt; 服务器端接收请求 -&gt;查询数据库 -&gt; 执行业务逻辑处理 -&gt; 构造HTTP响应 -&gt; 返回客户端</p></blockquote></li></ul><p>在这一链路中，性能瓶颈往往集中在两个关键阶段：<strong>网络请求阶段</strong>和<strong>服务端计算阶段</strong>。</p><ul><li>网络请求阶段：主要包括客户端发起的HTTP请求以及服务端对数据库的查询请求；</li><li>服务端计算阶段：主要包括业务逻辑处理和数据库查询结果的加工处理。</li></ul><p>为了提高Web应用的响应速度和用户体验，引入缓存技术成为了优化Web应用性能的关键手段之一。通过在不同层级引入缓存，可以显著减少重复计算和网络开销，从而提高页面响应效率。常见的缓存策略包括：</p><ul><li>数据库缓存</li><li>CDN（内容分发网络）缓存</li><li>代理服务器缓存（如反向代理）</li><li>浏览器缓存</li><li>应用层缓存（如Redis、Memcached)</li></ul><p>本文将从前端视角出发，重点探讨浏览器缓存的原理、类型及其实践。</p><h2 id="浏览器缓存的基本原理"><a href="#浏览器缓存的基本原理" class="headerlink" title="浏览器缓存的基本原理"></a>浏览器缓存的基本原理</h2><p>浏览器缓存工作流程：</p><ol><li><strong>浏览器发起第一次HTTP请求</strong>：用户在浏览器中访问某个资源（如页面、图片、脚本等），浏览器向缓存系统发送首次请求。</li><li><strong>缓存未命中（无缓存结果）</strong>：缓存系统检查是否存在该资源的缓存副本，由于是首次请求，缓存中没有对应数据，因此返回“未命中”状态。</li><li><strong>浏览器向服务器发起请求</strong>：由于缓存未命中，浏览器继续向后端服务器发送原始HTTP请求以获取资源。</li><li><strong>服务器返回请求资源</strong>：服务器接收到请求后，处理并返回所需要的资源内容（如HTML、CSS、JS文件等）。</li><li><strong>资源存入缓存中</strong>：浏览器在接收到服务器返回的资源后，将其存储到本地缓存中，以便后续请求时快速读取，避免重复向服务器发起请求。</li></ol><p>整个浏览器缓存的过程基于两个核心原则：</p><ol><li>浏览器每次发起请求时，都会先在浏览器缓存中查找该请求的结果和缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ol><p>接下来将从两个维度来介绍浏览器缓存：</p><ul><li>缓存的存储位置</li><li>缓存的类型</li></ul><h2 id="按照缓存位置分类"><a href="#按照缓存位置分类" class="headerlink" title="按照缓存位置分类"></a>按照缓存位置分类</h2><p>浏览器缓存存存储位置上分为四种，按照优先级依次查找：</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker（简称：SW）是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。值得注意的是，使用SW，传输协议必须是HTTPS，因为SW中涉及到请求拦截，所以必须使用HTTPS协议来保障安全。</p><p>SW的的缓存与浏览器的其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存、并且缓存是持续性的，常用于PWA离线访问场景。</p><p>SW的工作流程：</p><ol><li>注册Service Worker</li><li>监听install事件并缓存文件</li><li>拦截请求查询缓存、存在则直接返回，否则继续网络请求</li></ol><p>通常，当SW没有命中缓存时，需要去调用fetch函数获取数据，也就是说，如果没有在SW命中缓存时，会根据缓存优先级查找数据。但不管我们是从Memory Cache中还是请求网络中获取数据，浏览器都会显示我们是从SW中获取的内容。<br><img src="http://cdn.sswfive.xyz/2025-11/1762450691248_1762450691252.png" alt="1762450691248.png"></p><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache（简称：MC）是内存中的缓存，主要包含的是当前页面中已经抓取的资源，例如页面上已经下载的样式、脚本、图片等。</p><p>读取内存的数据肯定比磁盘高效，但毕竟内存空间有限，所以缓存有效期很短，一般会随着进程的结束而释放，也就是说当我们关闭Tab页面，内存中的缓存也就被释放了。</p><p>当我们访问过页面后，再次刷新页面，可以发现很多数据都来自内存缓存。如下图所示：<br><img src="http://cdn.sswfive.xyz/2025-11/251107013917055_1762450757338.png" alt="251107013917055.png"></p><p>MC机制保证了一个页面如果有两个相同的请求，都只会被请求最多一次，避免请求浪费，如：</p><ul><li>两个<code>src</code>相同的<code>&lt;*img*&gt;</code></li><li>两个<code>href</code>相同的<code>&lt;*link*&gt;</code></li></ul><h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache（简称：DC）是存储在硬盘中的缓存，读取速度慢点，但什么都能存储到磁盘中，比 MC胜在容量和对存储时效性上。</p><p>在所有浏览器缓存中，DC覆盖面是最大的，它会根据HTTP Header中的字段（如：<code>Cache-Control</code>、<code>ETag</code>、<code>Last-Modified</code> ）判断哪些资源需要被缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。</p><p>通常，在跨站点时，只要相同地址的资源一旦被硬盘缓存下来，就不会再次去请求，因此绝大部分时候数据都来源于DC。但所有的持久化存储都会面临容量增长的问题，DC也不例外，在浏览器自动清理时，会有特殊的算法去把“最老的”或“最可能过时的”资源删除，因此是一个一个删除的，不过每个浏览器是缓存清除算法不尽相同，这点也可以看作是各个浏览器差异性的体现。</p><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache（简称：PC）译作“推送缓存”，是属于HTTP&#x2F;2中新增的内容，当前面三种缓存都没有命中时，它才会被使用。它只会Session中存在，一旦Session结束就会被释放，并且缓存时间也是短暂的。通常在Chrome浏览器中只有5分钟的有效期，同时它也并非严格执行HTTP&#x2F;2头的缓存指令。</p><p>如果想进进一步深入了解PC， 推荐阅读文章：<a href="https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/"><em>HTTP&#x2F;2 push is tougher than I thought</em></a></p><h3 id="总体缓存流程的总结"><a href="#总体缓存流程的总结" class="headerlink" title="总体缓存流程的总结"></a>总体缓存流程的总结</h3><p>如果一个请求在上述所有阶段都没有找到缓存，那么浏览器会正式发送网络请求去获取资源，之后为了提升请求的缓存命中率，会把请求的资源添加到缓存中去，具体来说：</p><ol><li>根据SW中的handler决定是否存入Cache Storage（额外的缓存位置）。SW是由开发者编写的额外的脚本，且缓存位置独立，出现也比较晚，使用还不算广泛。</li><li>MC保存一份资源的引用，以备下次使用。MC是浏览器为了加快读取缓存速度而进行的自身优化行为，不受开发者控制，也不受HTTP协议头的约束，算是一个黑盒。</li><li>根据HTTP头部的相关字段（<code>Cache-Control</code> 、<code>Pragma</code>等）决定是否存入DS。DS也是我们平时最熟悉的一种缓存机制，也叫HTTP Cache（因为不像MC，它遵守HTTP协议头中的字段)。值得一提的是，我们常说的强制缓存，协商缓存，以及<code>Cache-Control</code>等都归于此类。</li></ol><h2 id="按照缓存类型分类"><a href="#按照缓存类型分类" class="headerlink" title="按照缓存类型分类"></a>按照缓存类型分类</h2><p>按照缓存类型进行分类，可以分为强制缓存和协商缓存。但需要注意的是，这两种缓存类型都是属于Disk Cache或者叫做HTTP Cache里的一种。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>强制缓存是指当客户端请求时，会先访问本地缓存看缓存是否存在且未过期，若缓存中资源有效直接返回，否则请求后端服务器获取最新资源，并在响应后存储到本地缓存中。通过减少不必要的网络请求，强制缓存能够显著提升网页的加载速度及用户体验，是性能优化中最有效的缓存策略之一。因此，考虑到性能优化时，强化缓存通常是首先得优化手段。</p><p>实现强制缓存的主要依靠HTTP响应头中的相关字段，具体包括：</p><ul><li>Expires：指定了一个具体的日期时间作为缓存的过期时间，它是一个绝对的时间 (通常设置为当前时间+缓存时长)。尽管它是一个早期引入的头字段，但在与Cache-Control共存的情况下，后者优先级更高。</li><li>Cache-Control: 用于指定资源缓存的最大有效时间，在该时间范围内，客户端可以直接使用缓存而无需向服务器发送请求。</li></ul><p>Expires字段存在两个主要缺点：</p><ul><li>由于它使用绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，从而重新请求该资源。此外，即使不考虑人为修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，进而影响缓存准确性。</li><li>写法太复杂了。表示时间的字符串多个空格，少个字母，都会导致变为非法属性从而设置失效。</li></ul><p>为了解决Expires的不足，在HTTP&#x2F;1.1中引入了 Cache-Control字段，该字段常用值如下(完整的列表可以查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control"><em>MDN</em></a>)：</p><ul><li>max-age：设置缓存的最大有效时间，单位为秒，是一个相对时间。</li><li><em>must-revalidate</em>：如果超过了 <em>max-age</em> 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。</li><li><em>no-cache</em>：虽然字面意思是“不要缓存”，但实际上还是要求客户端缓存内容的，只是是否使用这个内容由后续的协商缓存来决定。</li><li><em>no-store</em>：真正意义上的“不要缓存”。所有内容都不走缓存，包括强制缓存和协商缓存。</li><li><em>public</em>：所有的内容都可以被缓存（包括客户端和代理服务器， 如 <em>CDN</em> ）</li><li><em>private</em>：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</li></ul><p>这些值可以混合使用，例如<code>Cache-control:public, max-age=2592000</code>.在混合使用时，它们的优先级如下图所示：<br><img src="http://cdn.sswfive.xyz/2025-11/251107003355976_1762446835993.png" alt="251107003355976.png"></p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强制缓存失效时，就需要使用协商缓存，由服务器决定缓存内容是否失效。具体流程为：浏览器先请求本地缓存数据库获取缓存标识，，随后浏览器拿着这个标识和服务器通讯，若资源未发生变化，则服务器返回HTTP状态码304，通知浏览器继续使用缓存，否则返回200状态码及最新资源。</p><p>协商缓存在请求数上和未使用缓存时相同，但如果是304状态码，返回的仅仅是一个状态码而已，并没有实际的文件内容，从而显著减小了网络传输体积。它的优化点主要体现在“响应”上面通过减少响应体体积，来缩短网络传输时间。因此和强制缓存相比提升幅度较小，但总比没有缓存好。</p><p>协商缓存是可以和强制缓存一起用的，作为强制缓存失效后的一种后备方案，在实际项目中也确实一同出现。对比缓存有 <em>2</em> 组字段（不是两个）：</p><ul><li>Last-Modified &amp; If-Modified-Since</li><li>Etag &amp; If-None-Match</li></ul><p><strong>Last-Modified &amp; If-Modified-Since</strong></p><ol><li>服务器通过 <code>Last-Modified</code> 字段告知客户端，资源最后一次被修改的时间。</li><li>浏览器将这个值和资源一起记录在缓存数据库中。</li><li>再次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 <code>Last-Modified</code> 的值写入到请求头的 <code>If-Modified-Since</code> 字段</li><li>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 字段进行对比。如果相等，则表示未修改，响应 <em>304</em>；反之，则表示修改了，响应 <em>200</em> 状态码，并返回数据。</li></ol><p>然而，该机制存在一定局限性：</p><ul><li>如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li><li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li></ul><p>因此在 <em>HTTP&#x2F;1.1</em> 出现了 ETag和 If-None-Match</p><p><strong>Etag &amp; If-None-Match</strong><br>为了解决上述问题，出现了一组新的字段 <em>Etag</em> 和 <em>If-None-Match</em>。</p><p><em>Etag</em> 存储的是文件的特殊标识（一般都是一个 <em>Hash</em> 值），服务器存储着文件的 <em>Etag</em> 字段。后续流程和 <em>Last-Modified</em> 一致，只是 Last-Modified 字段和它所表示的更新时间改变成了 Etag 字段和它所表示的文件 <em>hash</em>，把 If-Modified-Since 变成了 If-None-Match。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到请求头里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag是一致的，则直接返回 <em>304</em> 告诉客户端直接使用本地缓存即可。</p><p>以下是对协商缓存中两组字段的简要对比：</p><ul><li>精确度<ul><li><blockquote><p><strong>Etag 更精确</strong>：Last-Modified 的时间单位为秒，若文件在1秒内多次更新，Last-Modified 无法准确反映变化；而 Etag 基于文件内容生成哈希值，任何修改都会改变该值，能准确识别内容变化。</p></blockquote></li></ul></li><li>性能<ul><li><blockquote><p><strong>Last-Modified 更高效</strong>：Last-Modified 仅需记录时间戳，服务端开销较小；而 Etag 需通过算法计算哈希值，对服务器性能有一定消耗。</p></blockquote></li></ul></li><li>优先级<ul><li><blockquote><p><strong>Etag 优先级更高</strong>：当两者同时存在时，服务器会优先校验 Etag，仅在 Etag 不一致或缺失时，才使用 Last-Modified 进行判断。</p></blockquote></li></ul></li></ul><h2 id="浏览器的缓存读取规则"><a href="#浏览器的缓存读取规则" class="headerlink" title="浏览器的缓存读取规则"></a>浏览器的缓存读取规则</h2><p>当浏览器要请求资源时：</p><ol><li>从 Service Worker 中获取内容（ 如果设置了 Service Worker ）</li><li>查看 Memory Cache</li><li>查看 Disk Cache。这里又细分：<ul><li><blockquote><p>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200</p></blockquote></li><li><blockquote><p>如果有强制缓存但已失效，使用协商缓存，比较后确定 304 还是 200</p></blockquote></li></ul></li><li>发送网络请求，等待网络响应</li><li>把响应内容存入 Disk Cache (如果 <em>HTTP</em> 响应头信息有相应配置的话)</li><li>把响应内容的引用存入 Memory Cache_(无视 <em>HTTP</em> 头信息的配置)</li><li>把响应内容存入 Service Worker的 Cache Storage（ 如果设置了 Service Worker）</li></ol><p>其中针对第 <em>3</em> 步，具体的流程图如下：<br><img src="http://cdn.sswfive.xyz/2025-11/251107011034261_1762449034268.png" alt="251107011034261.png"></p><h2 id="用户行为对浏览器缓存影响"><a href="#用户行为对浏览器缓存影响" class="headerlink" title="用户行为对浏览器缓存影响"></a>用户行为对浏览器缓存影响</h2><p>在理解了缓存的基本原理后，还需要关注用户的不同操作会出发浏览器采用不同的缓存策略。主要可分为以下三种情况：</p><ol><li>正常打开网页（地址栏输入URL并回车）<ul><li>浏览器会优先查找Disk Cache。如果存在有效缓存，则直接使用；否则向服务器发送网络请求。</li></ul></li><li>普通刷新（F5 或者工具栏刷新按钮）<ul><li>由于页面标签页并未关闭，Memory Cache此时是可用的，因此浏览器会优先使用它（如果命中），其次才会检查Disk Cache。</li></ul></li><li>强制刷新（<code>Ctrl + F5</code> 或 <code>Ctrl + Shift + R</code>）<ul><li>浏览器不使用缓存。因此发送请求头部均带有 <code>Cache-Control: no-cache</code> 和 <code>Pragma: no-cache</code>（为了兼容 HTTP&#x2F;1.0），服务器收到后则会返回 200 状态码及最新的内容。</li></ul></li></ol><h2 id="默认请求与F5与Ctrl-F5刷新"><a href="#默认请求与F5与Ctrl-F5刷新" class="headerlink" title="默认请求与F5与Ctrl + F5刷新"></a>默认请求与F5与Ctrl + F5刷新</h2><table><thead><tr><th>操作</th><th>行为</th><th>缓存影响</th></tr></thead><tbody><tr><td><strong>普通加载（直接输入 URL &#x2F; 点击链接 &#x2F; 从书签打开）</strong></td><td>正常加载流程</td><td><strong>优先使用强缓存（Memory → Disk）</strong></td></tr><tr><td><strong>刷新（F5）</strong></td><td>“软刷新”，保留部分缓存</td><td><strong>跳过 Memory Cache，但会使用 Disk Cache；仍可能触发协商缓存（304）</strong></td></tr><tr><td><strong>强制刷新（Ctrl + F5 &#x2F; Cmd + Shift + R）</strong></td><td>“硬刷新”，重新拉取</td><td><strong>跳过所有缓存（Memory + Disk），直接向服务器请求新资源（200 from network）</strong></td></tr></tbody></table><h2 id="HTTP缓存协议"><a href="#HTTP缓存协议" class="headerlink" title="HTTP缓存协议"></a>HTTP缓存协议</h2><h3 id="来自服务器的缓存指令"><a href="#来自服务器的缓存指令" class="headerlink" title="来自服务器的缓存指令"></a>来自服务器的缓存指令</h3><p>当客户端发出一个<code>get</code>请求到服务器，服务器可能有以下的内心活动：「你请求的这个资源，我很少会改动它，干脆你把它缓存起来吧，以后就不要来烦我了」</p><p>为了表达这个美好的愿望，服务器在<strong>响应头</strong>中加入了以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600</span><br><span class="line">ETag: W/&quot;121-171ca289ebf&quot;</span><br><span class="line">Date: Thu, 30 Apr 2020 12:39:56 GMT</span><br><span class="line">Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</span><br></pre></td></tr></table></figure><p>这个响应头表达了下面的信息：</p><ul><li><code>Cache-Control: max-age=3600</code>，我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）</li><li><code>ETag: W/&quot;121-171ca289ebf&quot;</code>，这个资源的编号是<code>W/&quot;121-171ca289ebf&quot;</code></li><li><code>Date: Thu, 30 Apr 2020 12:39:56 GMT</code>，我给你响应这个资源的服务器时间是格林威治时间<code>2020-04-30 12:39:56</code></li><li><code>Last-Modified: Thu, 30 Apr 2020 08:16:31 GMT</code>，这个资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li></ul><p>这个美好的缓存愿望，就这样通过响应头传递给客户端了，如果客户端是其他应用程序，可能并不会理会服务器的愿望，也就是说，可能根本不会缓存任何东西。但是凑巧客户端是一个浏览器，它和服务器一直以来都是相亲相爱的小伙伴，当它看到服务器的这个响应头表达的美好愿望后，立即忙起来：</p><ul><li>浏览器把这次请求得到的响应体缓存到本地文件中</li><li>浏览器标记这次请求的请求方法和请求路径</li><li>浏览器标记这次缓存的时间是3600秒</li><li>浏览器记录服务器的响应时间是格林威治时间<code>2020-04-30 12:39:56</code></li><li>浏览器记录服务器给予的资源编号<code>W/&quot;121-171ca289ebf&quot;</code></li><li>浏览器记录资源的上一次修改时间是格林威治时间<code>2020-04-30 08:16:31</code></li></ul><h3 id="来自客户端的缓存指令"><a href="#来自客户端的缓存指令" class="headerlink" title="来自客户端的缓存指令"></a>来自客户端的缓存指令</h3><p>当客户端收拾好行李，准备再次请求<code>GET /index.js</code>时，它突然想起了一件事：我需要的东西在不在缓存里呢？此时，客户端会到缓存中去寻找是否有缓存的资源，寻找的过程如下：</p><ol><li>缓存中是否有匹配的请求方法和路径？</li><li>如果有，该缓存资源是否还有效呢？</li></ol><p>以上两个验证会导致浏览器产生不同的行为，要验证是否有匹配的缓存非常简单，只需要验证当前的请求方法<code>GET</code>和当前的请求路径<code>/index.js</code>是否有对应的缓存存在即可，如果没有，就直接请求服务器，就和第一次请求服务器时一样，无需赘述。</p><p>关键在于如何验证缓存是否有效？<br>非常简单，就是把<code>max-age + Date</code>，得到一个过期时间，看看这个过期时间是否大于当前时间，如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效。</p><h3 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h3><p><img src="http://cdn.sswfive.xyz/2025-11/251107013632544_1762450592722.png" alt="251107013632544.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是浏览器缓存&quot;&gt;&lt;a href=&quot;#什么是浏览器缓存&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器缓存&quot;&gt;&lt;/a&gt;什么是浏览器缓存&lt;/h2&gt;&lt;p&gt;我们都知道，一个典型的Web应用请求-响应流程通常如下所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b</summary>
      
    
    
    
    <category term="技术实践" scheme="http://sswfive.xyz/categories/%E6%8A%80%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="技术原理" scheme="http://sswfive.xyz/tags/%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>阅后记：刘润2025年度演讲《进化的力量》</title>
    <link href="http://sswfive.xyz/2025/10/26/thinking/251026-liurun-speech-2025/"/>
    <id>http://sswfive.xyz/2025/10/26/thinking/251026-liurun-speech-2025/</id>
    <published>2025-10-26T08:20:01.000Z</published>
    <updated>2025-10-26T16:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个周六的晚上，朋友在群里分享了一篇微信公众号文章<a href="https://mp.weixin.qq.com/s/QOef7-YF_-XHKYm1Y729tA">《刘润年度演讲2025：进化的力量》</a>，文章很长，我花了整整75分钟才读完——印象中这是第一次为一篇文章投入了这么长时间，而且是一口气读完。内容非常打动我，于是趁着今天周日，特意找了这场演讲的视频（全长4小时55分钟）下载下来并上传到网盘（附<a href="https://pan.baidu.com/s/1hawbWZexPvFeRuU5D-h0MQ?pwd=fmn8">视频链接</a>），又花了一整个下午认真看完。下面是我个人觉得演讲中一些值得记录的精彩观点。</p><p>整场演讲围绕“大迁徙”这一核心主题，系统阐述了当前商业环境下企业生存与增长的六大进化路径。核心命题是：在“生态位干旱化”（如餐饮客流减少、母婴市场萎缩等）的背景下，企业如何活下去并实现持续增长？刘润老师指出，问题的根源在于需求端发生结构性变化，而解决方案是：开启“大迁徙”，主动离开内卷红海，寻找新的需求草原。</p><p>演讲共分为六个主题，具体内容如下：</p><h2 id="开篇：大迁徙"><a href="#开篇：大迁徙" class="headerlink" title="开篇：大迁徙"></a>开篇：大迁徙</h2><p>用角马迁徙的三个关建选择来比喻企业的出路：</p><ul><li>停止内卷：角马面临的选择：留在干旱的塞伦盖蒂与同类争夺有限资源（内卷），或冒险向北迁徙寻找新草原。对应企业：在红海市场中继续价格战，还是寻找新需求。</li><li>穿越生死线：角马必须渡过充满鳄鱼的马拉河，对应企业转型过程中的阵痛与风险。</li><li>抵达新草原：成功迁徙的角马获得新生，对应企业找到新增长点的美好前景。</li></ul><blockquote><p>大迁徙的本质是：告别内卷、穿越生死、奔向新生。</p></blockquote><h2 id="主题一：品类大迁徙，打破品类僵化"><a href="#主题一：品类大迁徙，打破品类僵化" class="headerlink" title="主题一：品类大迁徙，打破品类僵化"></a>主题一：品类大迁徙，打破品类僵化</h2><blockquote><p>对旧需求，用力过猛；对新需求，反应迟钝。</p></blockquote><p>问题：企业过度成迷优化旧产品（如床仅用于睡觉，餐桌忽略电器需求），忽视新需求。<br>案例：</p><ul><li>烤匠麻辣烤鱼：从“好吃”迁移到“情绪价值”（黑金风格、花椒冰淇淋、生日惊喜）。</li><li>AirBuggy: 从婴儿车转型到宠物车，核心能力是“为无法言说的爱设计产品”。<br>方法：</li><li><blockquote><p><strong>停下笔</strong>（反思旧需求是否仍然重要）-&gt;<strong>换卷子</strong>（识别用户新抱怨）-&gt; <strong>答新题</strong>（用能力满足新需求）。</p></blockquote><ul><li>第一，关于“停下笔”：我们产品的本质，到底是为了解决哪个“旧问题”？这个旧问题，今天还重要吗？</li><li>第二，关于“换卷子”：今天，用户正在抱怨的“新问题”是什么？哪些正在涌现？哪些正在变强？</li><li>第三，关于“答新题”：如果我们放下对现有产品的执念，从零开始创造一个新“物种”，它会是什么样子？</li></ul></li></ul><h2 id="主题二：价值大迁徙，消费心理重构"><a href="#主题二：价值大迁徙，消费心理重构" class="headerlink" title="主题二：价值大迁徙，消费心理重构"></a>主题二：价值大迁徙，消费心理重构</h2><blockquote><p>价值重排，指的是同一个人。同一个人，在心中对一类商品，越来越谨慎，但对另一类商品，花钱不眨眼。价值重排，讲的是“你”和“另一个你”的斗争。是同一个你的内心挣扎。以及挣扎之后的，“该省省，该花花，骑着自行车去酒吧”。</p></blockquote><p>现象：消费者“该省省该花花”（如省打车费，却愿为Labubu花99元），本质是“<strong>价值重排</strong>”</p><ul><li>该省省账户（生存型支出）：追求性价比，如5.9元咖啡。</li><li>该花花账户（意义型支出）：追求“心价比”，为热爱情感买单。</li></ul><p>方法：提供三种情绪解药：</p><ul><li>多回掌控感（如保健品零食化：东阿阿胶软糖）</li><li>共鸣软反抗（如哪咤，Labubu的叛逆审美）</li><li>创造小满足（如地铁卡做成玉玺造型）</li></ul><h2 id="主题三：模式大迁徙，回归能力原点"><a href="#主题三：模式大迁徙，回归能力原点" class="headerlink" title="主题三：模式大迁徙，回归能力原点"></a>主题三：模式大迁徙，回归能力原点</h2><blockquote><p>产品被淘汰，可能只是表象；只要能力不被淘汰，你就还有机会。</p></blockquote><p>关键：区分“产品”（可能被淘汰）和“能力”（可迁移）<br>案例：</p><ul><li>京都纹付（百年染坊）：从和服染黑转型二手服装染黑，核心是“深黑染色技术”。</li><li>味之素（味精厂）：利用氨基酸技术生产芯片绝缘体（市占率99%）。</li><li>微软埋粪案：废物公司Vaulted Deep用深井技术封存碳，卖“碳抵消指标”给微软。<br>方法：</li><li><blockquote><p>能力盘点（行业消失后还剩什么？）-&gt; 市场扫描（谁需要这能力？）-&gt; 模式验证（新业务如何赚钱？）</p></blockquote></li></ul><h2 id="主题四：出海大迁徙，规避盲区"><a href="#主题四：出海大迁徙，规避盲区" class="headerlink" title="主题四：出海大迁徙，规避盲区"></a>主题四：出海大迁徙，规避盲区</h2><blockquote><p>成功的路径，往往千差万别；但失败的陷进，却总是惊人地相似。</p></blockquote><p>心态盲区：</p><ul><li>勿用”故乡的地图“导航全球（如印尼用煤气罐而非管道煤气）</li><li>勿用”一把尺管理“全球员工（如肯尼亚重族群认可）</li></ul><p>战术盲区：</p><ul><li>忌“刻舟执念”（强卖中国产品）</li><li>忌“焦土竞争”（价格战毁市场）</li><li>忌“淘金客心态”（不贡献本地就业&#x2F;税收）</li></ul><p>格局盲区：</p><ul><li>克服”荒野恐惧”（肯尼亚电商需自建提货点、支付系统）</li><li>补“合规短板”（ESG规则）</li></ul><p>终极忠告：</p><ul><li>反对“遥控式出海”，必须肉身实地调研。</li></ul><h2 id="主题五：智能大迁徙，与AI智能体共生"><a href="#主题五：智能大迁徙，与AI智能体共生" class="headerlink" title="主题五：智能大迁徙，与AI智能体共生"></a>主题五：智能大迁徙，与AI智能体共生</h2><blockquote><p>我们以为数字分身的上限是“以假乱真”，但其实它的起点是“解放真人”。<br>AI不会让新手凭空起飞，但它能给高手插上翅膀。</p></blockquote><p>智能体分五级（L1-L5),核心是让AI从“聊天工具”变成“行动主体”：</p><ul><li>L1数字分身（模仿）：如罗永浩数字人直播带货5500万。</li><li>L2创作伙伴（思考）：如AI生成视频（角马过河），人做导演。</li><li>L3执行助手（执行）：如Base 44 用AI 3分钟开发销售培训APP。</li><li>L4协作团队（组队）：如AI写作团（主编、写手、资料员协作改稿）。</li><li>L5具身智能（物理改造）：如人形机器人（宇树科技）兼容人类环境。</li></ul><h2 id="主题六：人口大迁徙，服务银发经济"><a href="#主题六：人口大迁徙，服务银发经济" class="headerlink" title="主题六：人口大迁徙，服务银发经济"></a>主题六：人口大迁徙，服务银发经济</h2><blockquote><p>年轻时，我们想尽办法省时间；等到老了，我们又得想尽办法花时间。<br>用看见，去回应“奋斗者”的渴望。应该是，用陪伴，去驱散“自由者”的孤独。应该是，用科技，去接住“托付者”的尊严。</p></blockquote><p>中国3亿“婴儿潮”（1962-1975生）进入50+岁，分为三类：</p><ul><li>奋斗者（50-65岁）：忙累需被看见（如中老年短剧《闪婚老伴是豪门》充值3000万）。</li><li>自由者（65-75岁）：孤独需陪伴（如健身教练上门陪老人并记录“口述史”）。</li><li>托付者（75+岁）：失能需尊严（如助浴仓用雾化技术免水洗）。</li></ul><h2 id="结尾：第四百万零一种活法"><a href="#结尾：第四百万零一种活法" class="headerlink" title="结尾：第四百万零一种活法"></a>结尾：第四百万零一种活法</h2><blockquote><p>所以，进化，是人类最好的战略顾问。</p></blockquote><p>刘润老师表达了在充满不确定性的时代，企业不应只模仿“狮子”或“角马”这两种显而易见的生存策略，而应该从自然界400万种物种的进化智慧中，找到属于自己的第400万零一种活法。</p><p>向进化求战略</p><p>哨刺金合欢的“空房子”策略：共生​</p><ul><li><blockquote><p>曾聪明的增长不是竞争，而是共生</p></blockquote></li></ul><p>织布鸟的“样板间”策略：终局体验​</p><ul><li><blockquote><p>最精彩的开局，是让客户直接看到终局。</p></blockquote></li></ul><p>其他生物的生存智慧​</p><ul><li><blockquote><p><strong>汤姆逊瞪羚​</strong>​：通过夸张的跳跃（炫耀体力）来告诉猎豹“我很强，别追我”，从而​<strong>​避免战斗​</strong>​。</p></blockquote></li><li><blockquote><p><strong>​斑马​</strong>​：依靠黑白条纹在群体奔跑时让狮子眼花缭乱，从而​<strong>​模糊目标​</strong>​。</p></blockquote></li><li><blockquote><p><strong>​疣猪​</strong>​：因腿长脖子短，采用“跪姿”吃草，以​<strong>​妥协​</strong>​解决自身身体结构的短板。</p></blockquote></li></ul><h2 id="一些精彩的观点"><a href="#一些精彩的观点" class="headerlink" title="一些精彩的观点"></a>一些精彩的观点</h2><ul><li><blockquote><p>当水草不在丰美，停在原地不是坚守，而是一种错付。</p></blockquote></li><li><blockquote><p>大迁徙的终点，有时，不是让你去到一个新地方，而是让你成为一个新自己。</p></blockquote></li><li><blockquote><p>所有产品的价值，都在于满足用户的需求。“产品”本身没有价值，能满足“需求”的产品，才有价值。但是，消费者的需求从来不止一个。他们彼此交织，错综复杂，就组成了“需求空间”。</p></blockquote></li><li><blockquote><p>完美适应“昨天”的代价，是失去拥抱“明天”的能力。一旦需求变化，最先陷入变动的，就是曾经的王者。</p></blockquote></li><li><blockquote><p>停下笔，换卷子，答新题。</p></blockquote></li><li><blockquote><p>该省省，该花花，骑着自行车去酒吧。（骑着自行车去酒吧，省下的是路费，花掉的是对苟且生活的反抗）</p></blockquote></li><li><blockquote><p>为什么？因为黑色，是所有颜色的终点，也是所有故事的起点。我们常说，一白遮百丑；但在这里，是一黑获新生。</p></blockquote></li><li><blockquote><p>我们经常犯的一个致命错误，就是把“产品”当成了“能力”。，然而，能力是“根”，产品是“花”。</p></blockquote></li><li><blockquote><p>你眼里的“副产品”，可能是别人眼里的“救命稻草”。</p></blockquote></li><li><blockquote><p>不要拿着“故乡的地图”，去导航全世界。放下想当然，学会看当地的地图。</p></blockquote></li><li><blockquote><p>什么是荒野的恐惧？就是只敢走别人走过的路，不敢踏入没人开垦过的荒野。</p></blockquote></li><li><blockquote><p>所谓“契约优先”，就是：关系是“易碎品”，规则才是“承重墙”。</p></blockquote></li><li><blockquote><p>AI不会让新手凭空起飞，但它能给高手插上翅膀。</p></blockquote></li><li><blockquote><p>过去，人的价值在于“解决问题”；未来，人的价值在于“定义问题”。</p></blockquote></li><li><blockquote><p>年轻时，我们想尽办法省时间；等到老了，我们又得想尽办法花时间。</p></blockquote></li><li><blockquote><p>当想象的成本降为零，决策的质量，就无限接近100%。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个周六的晚上，朋友在群里分享了一篇微信公众号文章&lt;a href=&quot;https://mp.weixin.qq.com/s/QOef7-YF_-XHKYm1Y729tA&quot;&gt;《刘润年度演讲2025：进化的力量》&lt;/a&gt;，文章很长，我花了整整75分钟才读完——印象中这是第一次为一</summary>
      
    
    
    
    <category term="时笺" scheme="http://sswfive.xyz/categories/%E6%97%B6%E7%AC%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法之【排序】</title>
    <link href="http://sswfive.xyz/2025/09/23/dsa/algo_sort/"/>
    <id>http://sswfive.xyz/2025/09/23/dsa/algo_sort/</id>
    <published>2025-09-23T15:46:27.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的概述"><a href="#排序的概述" class="headerlink" title="排序的概述"></a>排序的概述</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul><li><p>常用的：</p><ul><li><p>冒泡排序</p></li><li><p>插入排序</p></li><li><p>选择排序</p></li><li><p>归并排序</p></li><li><p>快速排序</p></li><li><p>计数排序</p></li><li><p>基数排序</p></li><li><p>桶排序</p></li></ul></li><li><p>不常用的：</p><ul><li>猴子排序</li><li>睡眠排序</li><li>面条排序</li></ul></li></ul><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><blockquote><p>按照时间复杂度进行分类</p></blockquote><ul><li>冒泡、插入、选择 ： O(n^2)</li><li>快排、归并： O(nlogn)</li><li>桶、计数、基数：O(n)</li></ul><h2 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h2><blockquote><p>学习排序算法，除了学习算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法</p></blockquote><h3 id="分析执行效率"><a href="#分析执行效率" class="headerlink" title="分析执行效率"></a>分析执行效率</h3><ol><li>最好情况、最坏情况、平均情况时间复杂度<ul><li>对于要排序的数据，有的接近排序，有的完全无序，有序度不同的数据，对于排序的执行时间效率会差别很大</li></ul></li><li>时间复杂度的系数、常数、低阶<ul><li>在数据规模很大的时候，通常会忽略系数、常数、低阶，但实际开发中，通常需要排序的数据量级是相对较小的，所以此时需要考虑系数、常数、低阶对排序的执行时间效率的影响。</li></ul></li><li>比较次数和交换（或移动）次数<ul><li>基于比较的排序算法，通常会涉及两种操作，元素大小比较和元素交换移动，</li></ul></li></ol><h3 id="分析内存消耗"><a href="#分析内存消耗" class="headerlink" title="分析内存消耗"></a>分析内存消耗</h3><ol><li>算法的内存消耗可以通过空间复杂度来衡量，在排序算法的空间复杂度中，引入了原地排序概念，对于原地排序算法，就是特指空间复杂度是O(1)的排序算法。<ul><li>冒泡、插入、选择都是原地排序算法。</li></ul></li></ol><h3 id="分析稳定性"><a href="#分析稳定性" class="headerlink" title="分析稳定性"></a>分析稳定性</h3><ol><li>稳定性是衡量排序算法好坏的重要指标。<ul><li>稳定的排序算法：经过排序后，相等元素之间的原有的先后顺序不变</li><li>不稳定的排序算法：经过排序后，相等元素之间的位置发生改变</li></ul></li></ol><h2 id="冒泡排序（Bubble-Sort）分析"><a href="#冒泡排序（Bubble-Sort）分析" class="headerlink" title="冒泡排序（Bubble Sort）分析"></a>冒泡排序（Bubble Sort）分析</h2><ul><li><p>概念：</p><ul><li><p>冒泡排序只会操作相邻的两个数据。</p></li><li><p>每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满就让他俩互换。</p></li><li><p>一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序。</p></li></ul></li><li><p>特点：</p><ul><li>冒泡排序是原地排序算法.<ul><li>冒泡过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以空间复杂度是O(1)</li></ul></li><li>最好情况时间复杂度：O(n)</li><li>最坏情况时间复杂度：O(n^2)</li><li>平均时间复杂度：O(n^2)<ul><li>结合概率论知识进行分析</li><li>引入有序度和逆序度进行分析</li></ul></li></ul></li><li><p>有序度：</p><ul><li><p>有序度是数组中具有有序关系的元素对的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure></li><li><p>满有序度：完全有序的数组的有序度叫做满有序度</p></li></ul></li><li><p>逆序度：</p><ul><li><p>和有序度相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果 i &lt; j。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>公式分析：</p><ul><li>逆序度 &#x3D; 满有序度 - 有序度</li><li>排序的过程其实就是一种增加有序度，减少逆序度的过程，最后达到 满有序度，就说明排序完成。</li><li>冒泡排序包含两个操作原子，比较和交换，每交换一次，有序度加1，不管算法怎么改变，交换次数总是确定的，即为逆序度，也就是：n*(n-1)&#x2F;2–初始有序度。</li></ul></li></ul><h2 id="插入排序（Insertion-Sort）分析"><a href="#插入排序（Insertion-Sort）分析" class="headerlink" title="插入排序（Insertion Sort）分析"></a>插入排序（Insertion Sort）分析</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序的概述&quot;&gt;&lt;a href=&quot;#排序的概述&quot; class=&quot;headerlink&quot; title=&quot;排序的概述&quot;&gt;&lt;/a&gt;排序的概述&lt;/h2&gt;&lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python开发必备：解锁魔法方法的实用技巧大全</title>
    <link href="http://sswfive.xyz/2025/09/23/tech/python/250923-py-magic-methods/"/>
    <id>http://sswfive.xyz/2025/09/23/tech/python/250923-py-magic-methods/</id>
    <published>2025-09-23T14:34:51.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python的魔法方法是Python面向对象编程的精髓，理解魔法方法不仅能让开发者写出更优雅的代码，更重要的是能让你深入理解Python对象模型的工作原理。那么今天我们就来系统性的梳理一下Python魔法方法的基础知识、常用魔法方法与分类，以及应用场景实践。</p><ul><li>官方文档：点击前往 -&gt;<a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">魔法方法介绍</a></li></ul><h2 id="什么是魔法方法？"><a href="#什么是魔法方法？" class="headerlink" title="什么是魔法方法？"></a>什么是魔法方法？</h2><p>想象一下这样的场景：当你写下 <code>len([1, 2, 3])</code> 时，Python是如何知道要返回3的？当你使用 <code>+</code> 连接两个字符串时，背后发生了什么？答案就藏在魔法方法中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些看似普通的操作，背后都有魔法方法在工作</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))        <span class="comment"># 调用了 list.__len__()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>)     <span class="comment"># 调用了 str.__add__()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">42</span>))               <span class="comment"># 调用了 int.__str__()</span></span><br></pre></td></tr></table></figure><p>魔法方法是Python中以双下划线开头和结尾的特殊方法，也称为双下划线方法（如<code>__init__</code>、<code>__str__</code>、<code>__new__</code>等）。它们是Python中的一种协议机制，也是面向对象编程的核心机制之一，赋予了开发者自定义类行为的能力，让自定义类能像内置类型一样与Python语法无缝集成。</p><h2 id="了解并理解魔法方法"><a href="#了解并理解魔法方法" class="headerlink" title="了解并理解魔法方法"></a>了解并理解魔法方法</h2><p>对于我们Pythoner来说，不要把它们看作简单的”特殊方法”，而应该理解为：</p><ul><li><strong>是协议的实现</strong>：魔法方法是Python鸭子类型的核心体现</li><li><strong>是语言的扩展点</strong>：通过它们可以扩展Python语言本身的能力</li><li><strong>是语法的委托机制</strong>：Python的语法很大程度上委托给对象本身来定义<br>正如Python之禅所说：”Python应该提供一种方法，但最好是只有一种明显的方法来做这件事。”魔法方法正是这种哲学的完美体现。</li></ul><h2 id="魔法方法的特点与分类"><a href="#魔法方法的特点与分类" class="headerlink" title="魔法方法的特点与分类"></a>魔法方法的特点与分类</h2><p>魔法方法是由Python解释器在特定场景下自动调用，无需显示调用，例如当你使用<code>len(obj)</code> 时，Python会调用对象的<code>__len__</code>方法。<br>由于魔法方法种类繁多，根据功能可以分为以下几类：</p><ul><li>对象生命周期管理</li><li>对象表示与格式化</li><li>运算符重载</li><li>属性访问控制</li><li>容器与迭代器</li><li>同（异）步上下文管理</li><li>可调用对象与描述符</li><li>一些不常见但很有用的用法</li></ul><p>下面将针对常用的场景进行展开分析</p><h2 id="魔法方法在不同场景中的分析与实践"><a href="#魔法方法在不同场景中的分析与实践" class="headerlink" title="魔法方法在不同场景中的分析与实践"></a>魔法方法在不同场景中的分析与实践</h2><h3 id="场景1：对象生命周期管理"><a href="#场景1：对象生命周期管理" class="headerlink" title="场景1：对象生命周期管理"></a>场景1：对象生命周期管理</h3><p>下列这些魔法方法控制对象的创建，初始化和销毁。</p><ul><li><code>__new__(cls, *args, **kwargs)</code>：控制对象的创建，是真正的<strong>构造器</strong>，是对象创建过程中的第一个方法（静态方法），它在<code>__init__</code>之前调用。通常情况下，是不需要直接使用<code>__new__</code>，但如果你需要控制对象的创建过程（如：实现单例模式或自定义元类），可以重写它。</li><li><code>__init__(self, *args, **kwargs)</code>：是<strong>初始化器</strong>，初始化对象的，对象在内存已经分配，即self已经存在，接收参数并设置初始状态，它在每次创建对象时被自动调用，几乎每个类都会实现它。</li><li><code>__del__(self)</code>：定义对象被垃圾回收时的行为。需要注意的是，最好谨慎使用，如果使用不当，可能引发资源管理问题。因为该方法不保证一定被调用，其主要依赖垃圾回收机制的策略。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在__init__之前调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__new__: 创建对象实例&quot;</span>)</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;设置对象初始状态&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__init__: 初始化资源 &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>._resource = <span class="variable language_">self</span>._acquire_resource()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;对象被垃圾回收时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__del__: 清理资源 &#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>._release_resource()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_acquire_resource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取系统资源...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;模拟的资源句柄&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_release_resource</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;释放系统资源...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">resource = Resource(<span class="string">&quot;数据库连接&quot;</span>)</span><br><span class="line"><span class="comment"># 当对象被垃圾回收时，__del__会自动调用</span></span><br></pre></td></tr></table></figure><h3 id="场景2：对象表示与格式化"><a href="#场景2：对象表示与格式化" class="headerlink" title="场景2：对象表示与格式化"></a>场景2：对象表示与格式化</h3><p>下列这些魔法方法控制对象的字符串表示，用于调试或展示。</p><ul><li><code>__str__(self)</code>：为最终用户设计，要求可读性好，定义<code>str(obj)</code>或<code>print(obj)</code>时的行为，也就是常被用于输出或打印，这个方法应该返回一个易于理解的字符串，用于展示对象的“外观”。</li><li><code>__repr__(self)</code>：为开发者设计，要求明确无误，定义<code>repr(obj)</code>或交互环境中对象的表示，通常用于开发者调试，返回详细信息，它的目标是生成一个可以通过<code>eval()</code>恢复的字符串（即反向构造对象）。</li><li><code>__format__(self, format_spec)</code>：定义<code>format(obj, spec)</code>或<code>f-string</code> 中的格式化的行为，支持自定义格式化。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是对象的官方字符串表示，主要给开发者看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, age=<span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;这是对象的非正式字符串表示，主要给用户看&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span>，<span class="subst">&#123;self.age&#125;</span>岁&quot;</span></span><br><span class="line"></span><br><span class="line">ssw = Student(<span class="string">&quot;BluesSen&quot;</span>, <span class="number">32</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(tom))  <span class="comment"># Student(name=&#x27;BluesSen&#x27;, age=32)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(tom))   <span class="comment"># ssw，32岁</span></span><br><span class="line"><span class="built_in">print</span>(tom)        <span class="comment"># ssw，32岁</span></span><br></pre></td></tr></table></figure><h3 id="场景3：属性访问控制"><a href="#场景3：属性访问控制" class="headerlink" title="场景3：属性访问控制"></a>场景3：属性访问控制</h3><p>下列这些魔法方法控制对象的访问、设置和删除行为，适合实现动态属性或代理模式。</p><ul><li><code>__getattr__(self, name)</code>：当访问不存在的属性时调用，适合实现灵活的属性延迟加载或代理模式,比如实现一个ORM模型。</li><li><code>__setattr__(self, name, value)</code>：设置属性时调用，但需要注意避免无限递归的问题，实际开发中建议使用 <code>super().__setattr__</code> 来避免递归。</li><li><code>__delattr__(self, name)</code>：删除属性时调用。</li><li><code>__getattribute__(self, name)</code>：无条件访问任何属性时都会调用。极其强大，也极其危险，容易引发无限递归（必须通过<code>super().__getattribute__</code>来访问属性）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.exists = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;只有在找不到已存在的属性时才会调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;__getattr__被调用，尝试获取不存在的属性: &#x27;<span class="subst">&#123;name&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        value = <span class="string">f&quot;这是动态生成的属性 &#x27;<span class="subst">&#123;name&#125;</span>&#x27; 的值&quot;</span></span><br><span class="line">        <span class="built_in">setattr</span>(<span class="variable language_">self</span>, name, value)  <span class="comment"># 将其设置为实例属性，下次就不用走__getattr__了</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 谨慎使用 __getattribute__，容易导致无限递归！</span></span><br><span class="line">    <span class="comment"># def __getattribute__(self, name):</span></span><br><span class="line">    <span class="comment">#    print(f&quot;__getattribute__被调用，获取属性: &#x27;&#123;name&#125;&#x27;&quot;)</span></span><br><span class="line">    <span class="comment">#    # 必须通过super()来避免递归</span></span><br><span class="line">    <span class="comment">#    return super().__getattribute__(name)</span></span><br><span class="line"></span><br><span class="line">obj = LazyObject()</span><br><span class="line"><span class="built_in">print</span>(obj.exists)    <span class="comment"># 输出：5 (正常访问，不会触发__getattr__)</span></span><br><span class="line"><span class="built_in">print</span>(obj.foo)       <span class="comment"># 输出：__getattr__被调用... -&gt; 这是动态生成的属性 &#x27;foo&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span>(obj.foo)       <span class="comment"># 输出：这是动态生成的属性 &#x27;foo&#x27; 的值 (第二次访问，foo已存在，不再触发__getattr__)</span></span><br></pre></td></tr></table></figure><h3 id="场景4：容器与迭代器"><a href="#场景4：容器与迭代器" class="headerlink" title="场景4：容器与迭代器"></a>场景4：容器与迭代器</h3><p>首先需要明确的什么是容器、可迭代对象、迭代器对象：</p><ul><li><strong>容器</strong>：详见<a href="https://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/">Python中的数据类型用法剖析：从底层实现到高效应用</a></li><li><strong>可迭代对象</strong>：实现 <code>__iter__</code>，返回迭代器对象（通常 <code>return self</code>）</li><li><strong>迭代器对象</strong>：实现 <code>__iter__</code> 和 <code>__next__</code>，返回下一个值，结束时抛出 <code>StopIteration</code>。<br>下列这些魔法方法让类支持容器操作（如<code>in</code>、索引)和迭代。</li><li><code>__len__(self)</code>：定义<code>len(obj)</code>的行为。</li><li><code>__getitem__(self, key)</code>：可以实现自定义对象的下标访问行为，但需要注意的是在实现切片支持时，<code>__getitem__</code>需要处理slice对象。</li><li><code>__setitem__(self, key, value)</code>：可以实现自定义对象的下标赋值行为。</li><li><code>__delitem__(self, key)</code> ：用于实现删除通过键或索引访问的元素的操作。</li><li><code>__iter__(self)</code>、<code>__next__(self)</code> ：使对象可迭代（即支持<code>for</code>循环），这二者可与生成器结合优化内存。</li><li><code>__contains__(self, item)</code> ：定义 <code>in</code> 操作符的行为。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, items</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = <span class="built_in">list</span>(items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.items[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>.items)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> <span class="variable language_">self</span>.items</span><br><span class="line"></span><br><span class="line">ml = MyList([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(ml))      <span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(ml[<span class="number">1</span>])        <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> ml)      <span class="comment"># True</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> ml:</span><br><span class="line">    <span class="built_in">print</span>(x)        <span class="comment"># 1, 2, 3</span></span><br></pre></td></tr></table></figure><h3 id="场景5：同步-上下文管理"><a href="#场景5：同步-上下文管理" class="headerlink" title="场景5：同步-上下文管理"></a>场景5：同步-上下文管理</h3><p>下列这些魔法方法让类支持<code>with</code>语句，用于资源管理。</p><ul><li><code>__enter__(self)</code>：进入<code>with</code>时调用，返回上下文对象。</li><li><code>__exit__(self, exc_type, exc_value, traceback)</code>：退出<code>with</code>时调用，处理异常，需要提醒的是，该方法返回<code>True</code>时可抑制异常，也就是说异常会被“吞掉”，上下文管理器外的代码不会收到异常。这是一个强大但危险的特性。很适合事务处理，如果结合<code>contextlib</code>模块可简化上下文管理器的实现。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个计时器上下文管理器&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        <span class="variable language_">self</span>.start = time.time()</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># as 后面的变量得到的是这个返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        <span class="variable language_">self</span>.elapsed = time.time() - <span class="variable language_">self</span>.start</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;代码块运行耗时: <span class="subst">&#123;self.elapsed:<span class="number">.4</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line">        <span class="comment"># 返回 False 表示不压制异常；返回 True 则异常会被吞掉，外部不会收到异常。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> Timer() <span class="keyword">as</span> t:</span><br><span class="line">    <span class="comment"># 模拟一些耗时操作</span></span><br><span class="line">    <span class="built_in">sum</span>(i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 with 块后会自动打印时间</span></span><br><span class="line"><span class="comment"># 并且我们还可以访问 t.elapsed 这个属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;外部访问耗时: <span class="subst">&#123;t.elapsed&#125;</span>秒&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景6：异步-上下文管理"><a href="#场景6：异步-上下文管理" class="headerlink" title="场景6：异步-上下文管理"></a>场景6：异步-上下文管理</h3><p>下列这些魔法方法必须定义在支持异步的类中。</p><ul><li><code>__await__(self)</code>(可等待对象)：必须返回一个迭代器（通常通过 <code>iter()</code> 包装一个生成器）,可用于实现自定义可等待对象（如 <code>asyncio.Future</code>）。</li><li><code>__alter__(self)</code>(异步迭代器)：返回异步迭代器对象，通常<code>return self</code>。</li><li><code>__anext__</code>：必须返回一个<code>awaitable</code> 对象，（通常是 <code>coroutine</code> 或 <code>Task</code>）。</li><li><code>__aenter__(self)</code>(异步上下文管理器)：返回进入时的资源，常为<code>await self.connect()</code>.</li><li><code>__aexit__(self, exc_type, exc_value, traceback)</code>：用于异步清理（如关闭连接），可处理异常</li><li><code>StopAsyncIteration</code> 是异步迭代结束的信号（不要手动抛出，除非你控制迭代逻辑）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义异步上下文管理器</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncDatabase</span>:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在连接数据库...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库连接成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">disconnect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在断开数据库...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库已断开&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 异步上下文管理器</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.connect()  <span class="comment"># 返回一个协程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.disconnect()  <span class="comment"># 返回一个协程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncDatabase() <span class="keyword">as</span> db:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;数据库操作中...&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义异步迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncCounter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, limit</span>):</span><br><span class="line">        <span class="variable language_">self</span>.limit = limit</span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.limit:</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.current</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> num <span class="keyword">in</span> AsyncCounter(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h3 id="场景7：可调用对象"><a href="#场景7：可调用对象" class="headerlink" title="场景7：可调用对象"></a>场景7：可调用对象</h3><p>下列魔法方法让普通对象变为可调用对象，可用于实现函数式接口、装饰器类、回调等。</p><ul><li><code>__call__(self, *args, **kwargs)</code> ：让类的实例像函数一样被调用，适合实现装饰器或函数式接口。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个计数器，每次调用都会递增&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;使得实例可以像函数一样被调用：obj()&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;当前计数: <span class="subst">&#123;self.count&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.count</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个计数器实例</span></span><br><span class="line">counter = Counter(<span class="number">10</span>)</span><br><span class="line">counter()  <span class="comment"># 输出：当前计数: 11</span></span><br><span class="line">counter()  <span class="comment"># 输出：当前计数: 12</span></span><br><span class="line"><span class="comment"># 它是有状态的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallLogger</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;记录函数调用信息的装饰器类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line">        <span class="variable language_">self</span>.call_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>.call_count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始执行第 <span class="subst">&#123;self.call_count&#125;</span> 次调用: <span class="subst">&#123;self.func.__name__&#125;</span>&quot;</span>)</span><br><span class="line">        result = <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;函数 <span class="subst">&#123;self.func.__name__&#125;</span> 执行完毕&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallLogger</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 开始执行第 1 次调用: say_hello</span></span><br><span class="line"><span class="comment"># Hello, Alice!</span></span><br><span class="line"><span class="comment"># 函数 say_hello 执行完毕</span></span><br></pre></td></tr></table></figure><h3 id="场景8：描述符协议"><a href="#场景8：描述符协议" class="headerlink" title="场景8：描述符协议"></a>场景8：描述符协议</h3><p>下列这些魔法方法，用于创建描述符类，控制属性的访问，本质是属性代理。简单地说，它允许一个对象在作为另一个对象的属性时，自定义其获取、设置、删除行为。常被用于<strong>属性验证</strong>、<strong>懒加载</strong>、<strong>ORM 字段</strong>等场景。</p><ul><li><code>__get__(self, instance, owner)</code>：获取属性值。</li><li><code>__set__(self, instance, value)</code>：设置属性值。</li><li><code>__delete__(self, instance)</code> ：输出属性。</li><li><code>__set_name__(self, owner, name)</code>：在类创建时设置描述符名称（Python3.6+）<br><strong>值得一提</strong>：它们是 <code>@property</code>、<code>@classmethod</code>等装饰器的底层实现。在Django中被广泛使用。<br><strong>需要注意</strong>：描述符是实现了<code>__get__</code>、<code>__set__</code>或<code>__delete__</code>中至少一个方法的类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositiveNumber</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个描述符，确保数值是正数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="comment"># instance 是使用描述符的类的实例（如Rectangle的实例）</span></span><br><span class="line">        <span class="comment"># owner 是使用描述符的类本身（如Rectangle类）</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__.get(<span class="variable language_">self</span>.name, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;值必须是正数&quot;</span>)</span><br><span class="line">        <span class="comment"># 将值存储在实例的 __dict__ 中，而不是描述符实例自身</span></span><br><span class="line">        instance.__dict__[<span class="variable language_">self</span>.name] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    width = PositiveNumber(<span class="string">&#x27;width&#x27;</span>)  <span class="comment"># 描述符实例</span></span><br><span class="line">    height = PositiveNumber(<span class="string">&#x27;height&#x27;</span>) <span class="comment"># 描述符实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, w, h</span>):</span><br><span class="line">        <span class="variable language_">self</span>.width = w  <span class="comment"># 触发 PositiveNumber.__set__</span></span><br><span class="line">        <span class="variable language_">self</span>.height = h <span class="comment"># 触发 PositiveNumber.__set__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.width * <span class="variable language_">self</span>.height <span class="comment"># 触发 PositiveNumber.__get__</span></span><br><span class="line"></span><br><span class="line">r = Rectangle(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(r.area) <span class="comment"># 输出：15</span></span><br><span class="line">r.width = <span class="number">10</span>  <span class="comment"># 正常设置</span></span><br><span class="line"><span class="built_in">print</span>(r.area) <span class="comment"># 输出：30</span></span><br><span class="line"><span class="comment"># r.width = -5 # 会抛出 ValueError: 值必须是正数</span></span><br></pre></td></tr></table></figure><p><strong>上述代码分析</strong>：</p><ul><li>描述符<code>PositiveNumber</code>的实例作为类属性（<code>width</code>, <code>height</code>）被赋值给<code>Rectangle</code>类。</li><li>当对实例<code>r</code>的属性（如<code>r.width</code>）进行访问或赋值时，实际上被拦截，转而调用描述符的<code>__get__</code>或<code>__set__</code>方法。</li><li><code>@property</code>本质上就是一个实现了<code>__get__</code>和<code>__set__</code>的描述符。<br>总结：描述符是实现精细属性管理、ORM框架映射关系等高级功能的利器。</li></ul><h3 id="场景9：运算符重载"><a href="#场景9：运算符重载" class="headerlink" title="场景9：运算符重载"></a>场景9：运算符重载</h3><p>下列这些魔法方法允许自定义类支持Python的运算符（如：<code>+</code>、<code>-</code>、<code>&lt;</code>等）。<br>(一) 实现算术运算符：</p><ul><li><code>__add__(self, other)</code>：实现加法运算符 <code>+</code>。</li><li><code>__sub__(self, other)</code>：实现减法运算符 <code>-</code>。</li><li><code>__mul__(self, other)</code>：实现乘法运算符 <code>*</code>。</li><li><code>__truediv__(self, other)</code>：实现真除法运算符 <code>/</code>。</li><li><code>__floordiv__(self, other)</code>：实现整数除法运算符 <code>//</code>。</li><li><code>__mod__(self, other)</code>：实现取模运算符 <code>%</code>。</li><li><code>__pow__(self, other[, modulo])</code>：实现幂运算符 <code>**</code>。</li><li><code>__iadd__(self, other)</code>：实现复合运算符 <code>+=</code></li><li><code>__isub__(self, other)</code>：实现复合运算符 <code>-=</code></li><li><code>__imul__(self, other)</code> ：实现复合运算符 <code>*=</code><br>（二）实现位运算符（不常用）</li><li><code>__lshift__(self, other)</code>：实现左移位运算符 <code>&lt;&lt;</code>。</li><li><code>__rshift__(self, other)</code>：实现右移位运算符 <code>&gt;&gt;</code>。</li><li><code>__and__(self, other)</code>：实现按位与运算符 <code>&amp;</code>。</li><li><code>__xor__(self, other)</code>：实现按位异或运算符 <code>^</code>。</li><li><code>__or__(self, other)</code>：实现按位或运算符 <code>|</code>。<br>（三）实现比较运算符：</li><li><code>__lt__(self, other)</code>：实现小于运算符 <code>&lt;</code>。</li><li><code>__le__(self, other)</code>：实现小于等于运算符 <code>&lt;=</code>。</li><li><code>__eq__(self, other)</code>：实现等于运算符 <code>==</code>。</li><li><code>__ne__(self, other)</code>：实现不等于运算符 <code>!=</code>。</li><li><code>__gt__(self, other)</code>：实现大于运算符 <code>&gt;</code>。 </li><li><code>__ge__(self, other)</code>：实现大于等于运算符 <code>&gt;=</code>。<br>**友情提醒：**实现比较运算符时，建议使用 <code>functools.total_ordering</code> 装饰器，只需定义 <code>__eq__</code> 和 <code>__lt__</code> 即可自动生成其他比较方法。</li></ul><p>（四）实现容器类型类似方法（如序列、映射等）：</p><blockquote><p>这些方法允许对象像列表或字典一样被操作。</p></blockquote><ul><li><code>__getitem__(self, key)</code>：实现通过键或索引获取元素，如 <code>self[key]</code>。</li><li><code>__setitem__(self, key, value)</code>：实现通过键或索引设置元素，如 <code>self[key] = value</code>。</li><li><code>__delitem__(self, key)</code>：实现通过键或索引删除元素，如 <code>del self[key]</code>。</li><li><code>__contains__(self, item)</code>：实现成员测试运算符 <code>in</code>。</li><li><code>__len__(self)</code>：实现内置函数 <code>len()</code>，返回容器的长度。<br>由于方法太多，这里就简单的实现一个计算器功能吧</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让对象参与数学运算，支持向量的加减法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 v1 + v2 或 v1 + number&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Vector):</span><br><span class="line">            <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">            <span class="comment"># 标量加法，x和y都加</span></span><br><span class="line">            <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other, <span class="variable language_">self</span>.y + other)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span>  <span class="comment"># 告诉Python此操作不支持，让Python尝试 other.__radd__</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__radd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 number + v1（当数字在左边时调用）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 向量加法满足交换律，所以直接调用 __add__</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__add__(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iadd__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 v1 += v2 或 v1 += number（就地修改）&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Vector):</span><br><span class="line">            <span class="variable language_">self</span>.x += other.x</span><br><span class="line">            <span class="variable language_">self</span>.y += other.y</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(other, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">            <span class="variable language_">self</span>.x += other</span><br><span class="line">            <span class="variable language_">self</span>.y += other</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>  <span class="comment"># 就地运算必须返回self</span></span><br><span class="line"></span><br><span class="line">v1 = Vector(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">v2 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(v1 + v2)      <span class="comment"># 输出：Vector(4, 6) (调用 __add__)</span></span><br><span class="line"><span class="built_in">print</span>(v1 + <span class="number">5</span>)       <span class="comment"># 输出：Vector(6, 7) (调用 __add__)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> + v1)       <span class="comment"># 输出：Vector(6, 7) (先尝试 int.__add__(5, v1) 失败，然后调用 v1.__radd__(5))</span></span><br><span class="line">v1 += v2</span><br><span class="line"><span class="built_in">print</span>(v1)           <span class="comment"># 输出：Vector(4, 6) (调用 __iadd__，就地修改)</span></span><br></pre></td></tr></table></figure><h3 id="场景10：一些不常见但很有用的方法"><a href="#场景10：一些不常见但很有用的方法" class="headerlink" title="场景10：一些不常见但很有用的方法"></a>场景10：一些不常见但很有用的方法</h3><ul><li><code>__slots__</code> ：限制类可添加的属性，优化内存和性能。</li><li><code>__class__</code>  ：获取或修改对象的类，动态性极强。</li><li><code>__copy__(self)</code>：<code>copy.copy(obj)</code>，浅拷贝</li><li><code>__deepcopy__(self, memo)</code>：<code>copy.deepcopy(obj)</code>，深拷贝</li><li><code>__getstate__(self)</code>：<code>pickle</code> 序列化时获取对象状态</li><li><code>_setstate__(self, state)</code>：<code>pickle</code> 反序列化时恢复状态</li><li><code>__dir__(self)</code>：<code>dir(obj)</code>，自定义属性列表</li><li><code>__sizeof__(self)</code>：<code>sys.getsizeof(obj)</code>，返回对象内存大小，</li><li><code>__hash__(self)</code>：<code>hash(obj)</code>，用于哈希表（如字典键），</li><li><code>__instancecheck__(self, instance)</code>、<code>__subclasscheck__(self, subclass)</code> ：自定义 <code>isinstance</code> 和 <code>issubclass</code> 行为，通常在元类中使用。</li></ul><h2 id="一些开箱即用的实践案例"><a href="#一些开箱即用的实践案例" class="headerlink" title="一些开箱即用的实践案例"></a>一些开箱即用的实践案例</h2><h3 id="案例1：实现一个像列表和字典一样的类"><a href="#案例1：实现一个像列表和字典一样的类" class="headerlink" title="案例1：实现一个像列表和字典一样的类"></a>案例1：实现一个像列表和字典一样的类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Playlist</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个简单的播放列表类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *songs</span>):</span><br><span class="line">        <span class="variable language_">self</span>._songs = <span class="built_in">list</span>(songs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 len(obj)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._songs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 obj[index]，还支持切片！&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 直接返回内部列表的对应项，巧妙利用列表的切片功能</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._songs[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, song</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现 item in obj&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> song <span class="keyword">in</span> <span class="variable language_">self</span>._songs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;实现迭代，支持 for 循环&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>._songs)</span><br><span class="line"></span><br><span class="line">my_playlist = Playlist(<span class="string">&quot;Song A&quot;</span>, <span class="string">&quot;Song B&quot;</span>, <span class="string">&quot;Song C&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_playlist))        <span class="comment"># 输出：3 (调用 __len__)</span></span><br><span class="line"><span class="built_in">print</span>(my_playlist[<span class="number">1</span>])          <span class="comment"># 输出：Song B (调用 __getitem__)</span></span><br><span class="line"><span class="built_in">print</span>(my_playlist[<span class="number">0</span>:<span class="number">2</span>])        <span class="comment"># 输出：[&#x27;Song A&#x27;, &#x27;Song B&#x27;] (切片也有效！)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Song B&quot;</span> <span class="keyword">in</span> my_playlist) <span class="comment"># 输出：True (调用 __contains__)</span></span><br><span class="line"><span class="keyword">for</span> song <span class="keyword">in</span> my_playlist:       <span class="comment"># 调用 __iter__</span></span><br><span class="line">    <span class="built_in">print</span>(song)                <span class="comment"># 依次输出 Song A, Song B, Song C</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="案例2：实现一个支持对象支持比较类"><a href="#案例2：实现一个支持对象支持比较类" class="headerlink" title="案例2：实现一个支持对象支持比较类"></a>案例2：实现一个支持对象支持比较类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Student(name=&#x27;<span class="subst">&#123;self.name&#125;</span>&#x27;, age=<span class="subst">&#123;self.age&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;定义相等性：姓名和年龄都相同就认为是同一个学生&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(other, Student):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.name == other.name <span class="keyword">and</span> <span class="variable language_">self</span>.age == other.age</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;如果两个对象相等，它们的hash值必须相同&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>((<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.age))</span><br><span class="line"></span><br><span class="line">tom1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line">tom2 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(tom1 == tom2)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在可以把学生对象放进set或用作dict的key了</span></span><br><span class="line">students = &#123;tom1, tom2&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(students))  <span class="comment"># 1，因为两个Tom被认为是同一个</span></span><br></pre></td></tr></table></figure><h3 id="案-3：实现一个缓存器"><a href="#案-3：实现一个缓存器" class="headerlink" title="案:3：实现一个缓存器"></a>案:3：实现一个缓存器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;LRU缓存实现&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, maxsize=<span class="number">128</span>, ttl=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.maxsize = maxsize</span><br><span class="line">        <span class="variable language_">self</span>.ttl = ttl</span><br><span class="line">        <span class="variable language_">self</span>.cache = OrderedDict()</span><br><span class="line">        <span class="variable language_">self</span>.times = &#123;&#125; <span class="keyword">if</span> ttl <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            key = <span class="variable language_">self</span>._make_key(args, kwargs)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查缓存</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> <span class="variable language_">self</span>.cache:</span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._is_valid(key):</span><br><span class="line">                    <span class="comment"># 移到末尾（最近使用）</span></span><br><span class="line">                    <span class="variable language_">self</span>.cache.move_to_end(key)</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">self</span>.cache[key]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 过期，删除</span></span><br><span class="line">                    <span class="variable language_">self</span>._delete_key(key)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算结果</span></span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 存储结果</span></span><br><span class="line">            <span class="variable language_">self</span>._store_result(key, result)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        wrapper.cache_info = <span class="variable language_">self</span>.cache_info</span><br><span class="line">        wrapper.cache_clear = <span class="variable language_">self</span>.cache_clear</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make_key</span>(<span class="params">self, args, kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建缓存键&quot;&quot;&quot;</span></span><br><span class="line">        key = args</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            key += <span class="built_in">tuple</span>(<span class="built_in">sorted</span>(kwargs.items()))</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_is_valid</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查缓存是否有效&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.ttl <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> time.time() - <span class="variable language_">self</span>.times[key] &lt; <span class="variable language_">self</span>.ttl</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_delete_key</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除缓存项&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.cache[key]</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="keyword">del</span> <span class="variable language_">self</span>.times[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_store_result</span>(<span class="params">self, key, result</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;存储缓存结果&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 检查容量</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.cache) &gt;= <span class="variable language_">self</span>.maxsize:</span><br><span class="line">            <span class="comment"># 删除最老的项</span></span><br><span class="line">            oldest_key = <span class="built_in">next</span>(<span class="built_in">iter</span>(<span class="variable language_">self</span>.cache))</span><br><span class="line">            <span class="variable language_">self</span>._delete_key(oldest_key)</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.cache[key] = result</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="variable language_">self</span>.times[key] = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cache_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;缓存信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Cache size: <span class="subst">&#123;<span class="built_in">len</span>(self.cache)&#125;</span>/<span class="subst">&#123;self.maxsize&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cache_clear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;清空缓存&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.cache.clear()</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.times:</span><br><span class="line">            <span class="variable language_">self</span>.times.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="meta">@LRUCache(<span class="params">maxsize=<span class="number">100</span>, ttl=<span class="number">300</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expensive_function</span>(<span class="params">x, y</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x * y + x ** <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="案例4：实现一个配置管理器"><a href="#案例4：实现一个配置管理器" class="headerlink" title="案例4：实现一个配置管理器"></a>案例4：实现一个配置管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;支持点号访问和字典访问的配置管理器&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>._data = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="variable language_">self</span>[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;字典式访问：config[&#x27;database_url&#x27;]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;字典式赋值：config[&#x27;database_url&#x27;] = &#x27;sqlite:///app.db&#x27;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._data[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;删除配置项：del config[&#x27;database_url&#x27;]&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>._data[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查是否存在：&#x27;database_url&#x27; in config&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> <span class="variable language_">self</span>._data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;配置项数量：len(config)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;迭代配置项：for key in config&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(<span class="variable language_">self</span>._data)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;点号访问：config.database_url&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._data[name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">f&quot;配置项 &#x27;<span class="subst">&#123;name&#125;</span>&#x27; 不存在&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;点号赋值：config.database_url = &#x27;sqlite:///app.db&#x27;&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&#x27;_&#x27;</span>):</span><br><span class="line">            <span class="comment"># 私有属性正常处理</span></span><br><span class="line">            <span class="built_in">super</span>().__setattr__(name, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 公共属性存储到配置中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(<span class="variable language_">self</span>, <span class="string">&#x27;_data&#x27;</span>):</span><br><span class="line">                <span class="built_in">super</span>().__setattr__(<span class="string">&#x27;_data&#x27;</span>, &#123;&#125;)</span><br><span class="line">            <span class="variable language_">self</span>._data[name] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        items = [<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;v!r&#125;</span>&quot;</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="variable language_">self</span>._data.items()]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Config(<span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(items)&#125;</span>)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.keys()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">values</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.values()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">items</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.items()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._data.get(key, default)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="variable language_">self</span>[key] = value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">config = Config(</span><br><span class="line">    database_url=<span class="string">&quot;sqlite:///app.db&quot;</span>,</span><br><span class="line">    debug=<span class="literal">True</span>,</span><br><span class="line">    max_connections=<span class="number">100</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多种访问方式</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&#x27;database_url&#x27;</span>])    <span class="comment"># sqlite:///app.db</span></span><br><span class="line"><span class="built_in">print</span>(config.database_url)       <span class="comment"># sqlite:///app.db</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;debug&#x27;</span> <span class="keyword">in</span> config)         <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态添加配置</span></span><br><span class="line">config.secret_key = <span class="string">&quot;my-secret-key&quot;</span></span><br><span class="line">config[<span class="string">&#x27;cache_timeout&#x27;</span>] = <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代配置</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> config:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;key&#125;</span>: <span class="subst">&#123;config[key]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;共有 <span class="subst">&#123;<span class="built_in">len</span>(config)&#125;</span> 个配置项&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="案例5：实现一个单例类"><a href="#案例5：实现一个单例类" class="headerlink" title="案例5：实现一个单例类"></a>案例5：实现一个单例类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;单例模式元类&quot;&quot;&quot;</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    _lock = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">mcs, name, bases, namespace, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建新类时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;创建类 <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">        cls = <span class="built_in">super</span>().__new__(mcs, name, bases, namespace)</span><br><span class="line">        <span class="comment"># 为每个类创建一个锁</span></span><br><span class="line">        mcs._lock[cls] = <span class="built_in">__import__</span>(<span class="string">&#x27;threading&#x27;</span>).Lock()</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建实例时调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            <span class="keyword">with</span> cls._lock[cls]:</span><br><span class="line">                <span class="comment"># 双重检查</span></span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;创建 <span class="subst">&#123;cls.__name__&#125;</span> 的第一个实例&quot;</span>)</span><br><span class="line">                    instance = <span class="built_in">super</span>().__call__(*args, **kwargs)</span><br><span class="line">                    cls._instances[cls] = instance</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;返回 <span class="subst">&#123;cls.__name__&#125;</span> 的现有实例&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;返回 <span class="subst">&#123;cls.__name__&#125;</span> 的现有实例&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DatabaseConnection</span>(metaclass=SingletonMeta):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数据库连接类（单例）&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">5432</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(<span class="variable language_">self</span>, <span class="string">&#x27;_initialized&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.host = host</span><br><span class="line">        <span class="variable language_">self</span>.port = port</span><br><span class="line">        <span class="variable language_">self</span>.connected = <span class="literal">False</span></span><br><span class="line">        <span class="variable language_">self</span>._initialized = <span class="literal">True</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;初始化数据库连接: <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.connected:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;连接到数据库 <span class="subst">&#123;self.host&#125;</span>:<span class="subst">&#123;self.port&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="variable language_">self</span>.connected = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已经连接到数据库&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, sql</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.connected:</span><br><span class="line">            <span class="variable language_">self</span>.connect()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;执行查询: <span class="subst">&#123;sql&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;查询结果 for &#x27;<span class="subst">&#123;sql&#125;</span>&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试单例</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=== 创建数据库连接实例 ===&quot;</span>)</span><br><span class="line">db1 = DatabaseConnection(<span class="string">&quot;192.168.1.100&quot;</span>)</span><br><span class="line">db2 = DatabaseConnection(<span class="string">&quot;localhost&quot;</span>)  <span class="comment"># 参数被忽略</span></span><br><span class="line">db3 = DatabaseConnection()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;db1 is db2: <span class="subst">&#123;db1 <span class="keyword">is</span> db2&#125;</span>&quot;</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;db1.host: <span class="subst">&#123;db1.host&#125;</span>&quot;</span>)      <span class="comment"># 192.168.1.100</span></span><br><span class="line"></span><br><span class="line">db1.connect()</span><br><span class="line">db2.query(<span class="string">&quot;SELECT * FROM users&quot;</span>)    <span class="comment"># 使用同一个连接</span></span><br></pre></td></tr></table></figure><h2 id="一些好的实践与建议"><a href="#一些好的实践与建议" class="headerlink" title="一些好的实践与建议"></a>一些好的实践与建议</h2><ul><li><strong>开发调试阶段</strong>：<ul><li><code>__repr__</code> 比 <code>__str__</code> 更重要，调试时非常有用。</li></ul></li><li><strong>建议使用</strong>：<ul><li>实现 <code>__eq__</code> 时，通常也要实现 <code>__hash__</code>（除非对象是可变的）。</li><li>使用 <code>@total_ordering</code> 装饰器可以减少比较方法的编写量（只需实现 <code>__eq__</code> 和一个如 <code>__lt__</code>）。</li><li>在设计类时最好做到总是检查参数类型，使用<code>NotImplemented</code>而不是抛出异常。</li><li>在设计类时考虑使用<code>@dataclass</code>或<code>@attrs</code>来减少样板代码</li><li>魔法方法调用有开销,在性能敏感的循环中，直接调用方法可能比操作符更快。</li></ul></li><li>谨慎使用：<ul><li>在<code>__getattribute__</code>、<code>__setattr__</code>中直接使用<code>self.attr</code>会导致无限递归。必须使用<code>super()</code>或直接操作<code>__dict__</code>。</li></ul></li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><table><thead><tr><th>类别</th><th>主要方法</th><th>应用场景</th></tr></thead><tbody><tr><td>对象生命周期</td><td><code>__new__</code>, <code>__init__</code>, <code>__del__</code></td><td>对象创建、初始化、销毁</td></tr><tr><td>对象表示与格式化</td><td><code>__str__</code>, <code>__repr__</code>, <code>__format__</code></td><td>字符串表示、调试输出</td></tr><tr><td>运算符重载</td><td><code>__add__</code>, <code>__eq__</code>, <code>__lt__</code>等</td><td>数学运算、比较操作</td></tr><tr><td>属性访问控制</td><td><code>__getattr__</code>, <code>__setattr__</code>, <code>__getattribute__</code></td><td>动态属性、代理模式</td></tr><tr><td>容器与迭代器</td><td><code>__len__</code>, <code>__getitem__</code>, <code>__iter__</code></td><td>序列、映射、迭代</td></tr><tr><td>上下文管理</td><td><code>__enter__</code>, <code>__exit__</code></td><td>资源管理、with语句</td></tr><tr><td>可调用对象</td><td><code>__call__</code></td><td>函数式接口、装饰器类</td></tr><tr><td>描述符协议</td><td><code>__get__</code>, <code>__set__</code>, <code>__delete__</code></td><td>属性验证、ORM字段</td></tr><tr><td>异步编程</td><td><code>__aenter__</code>, <code>__aexit__</code>, <code>__anext__</code></td><td>异步上下文、迭代</td></tr></tbody></table><p>Python的魔法方法不是“黑魔法”，而是一套精心设计的、用于扩展语言能力的协议系统。作为Python开发者，深入理解并恰当地运用它们，能够让我们设计出API更清晰、更符合Python风格、更强大的代码库。</p><p>然而，常言道：能力越大，责任越大……</p><p>魔法方法虽然功能强大，但滥用魔法方法会让代码变得难以理解和调试。我们应该始终遵循“明确胜于隐晦”的Python之禅，只在真正需要让对象模拟内置行为或实现特定协议时才使用它们。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Python的魔法方法是Python面向对象编程的精髓，理解魔法方法不仅能让开发者写出更优雅的代码，更重要的是能让你深入理解Python对象模型的工作原理。那么今天我们就来系统性的梳理一下Python魔法方法的基础知识、常用魔法方法与分类，以及应用场景实践。&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="Python核心知识" scheme="http://sswfive.xyz/tags/Python%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>遇见Stellar：我的博客站点的又一次翻新之旅</title>
    <link href="http://sswfive.xyz/2025/09/22/tools/250922-blog-theme-migrate/"/>
    <id>http://sswfive.xyz/2025/09/22/tools/250922-blog-theme-migrate/</id>
    <published>2025-09-22T15:08:33.000Z</published>
    <updated>2025-10-17T03:27:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，无意中看到一个博客主题：<a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a> ，第一眼就被它优雅的设计所吸引。随后我仔细阅读了它的使用文档和一些实际案例，越发觉得它强大而富有美感，尤其触动我的是文档中的一句话：</p><blockquote><p>真正的简约远不止删繁就简，而是在纷繁中建立秩序</p></blockquote><p>这句话彻底动摇了我之前一直追求的极简主义理念，之前我使用的是<a href="https://github.com/HiNinoJay/hexo-theme-A4">hexo-theme-A4</a>，它确实非常简洁，但在功能和内容组织上略显单一。而 Stellar 不仅外观现代，还内置了丰富的模块和组件，支持博客、知识库、专栏、笔记等多种内容形式，真正做到了“简约而不简单”。<br>于是我决定动手试一试。按照官方文档，我把感兴趣的配置都体验了一遍后，经过几个小时冷静思考，决定当晚就把博客迁移到Stellar，并借此机会好好梳理一下自己的建站历程——毕竟之前尝试过不少博客平台和主题，却一直没有系统的记录，有些细节已经模糊甚至遗忘了。</p><h2 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h2><ul><li>内容排版：<a href="https://markdown.com.cn/">Markdown语法介绍</a>，<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></li><li>站点框架：<a href="https://hexo.io/zh-cn/docs/">Hexo</a></li><li>站点主题：<a href="https://github.com/xaoxuu/hexo-theme-stellar">hexo-theme-stellar</a></li><li>主题配置文档：<a href="https://xaoxuu.com/wiki/stellar/#start">Stellar开启您全新的博客之旅</a></li></ul><h2 id="主题介绍"><a href="#主题介绍" class="headerlink" title="主题介绍"></a>主题介绍</h2><p>Stellar 是一个极为强大的综合型 Hexo 主题，包含博客系统、知识库系统、专栏系统、笔记系统，内置海量的标签和动态数据组件。</p><h2 id="迁移流程"><a href="#迁移流程" class="headerlink" title="迁移流程"></a>迁移流程</h2><p>由于迁移前后站点的框架都是hexo,这个我的迁移工作降低了不少难度和时间。</p><p>主要迁移流程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 初始化新站点</span></span><br><span class="line">hexo init blogsite</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.安装Stellar主题</span></span><br><span class="line">npm i hexo-theme-stellar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在_config.yml中，修改配置</span></span><br><span class="line">theme: stellar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.创建主题配置文件（在根目录新建 `_config.stellar.yml`，所有主题相关配置在此编辑。）</span></span><br><span class="line"><span class="built_in">touch</span> _config.stellar.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，将原博客<code>source</code>目录下的所有内容全部拷贝到新站点对应目录中，基本实现无缝切换（主要还是因为我使文档中使用的语法都是通用语法，基本没有使用主题定制语法）。</p><h2 id="发布流程"><a href="#发布流程" class="headerlink" title="发布流程"></a>发布流程</h2><p>我采用Github + CI 的自动化发布方式：</p><ul><li>私有仓库 blogsite：存放 Hexo 源码，并设置 GitHub Actions 工作流</li><li>公开仓库 sswfive.github.io：存放生成的静态页面，用于 GitHub Pages 展示<br>撰写新文章后，推送至私有仓库触发 CI 流程（如 GitHub Actions），自动构建并发布到公开仓库，即可通过 <a href="https://sswfive.github.io/">https://sswfive.github.io</a> 访问。</li></ul><h3 id="核心配置步骤"><a href="#核心配置步骤" class="headerlink" title="核心配置步骤"></a>核心配置步骤</h3><ol><li>生成部署密钥对</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span> -f github-actions-deploy</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>将生成的 <code>github-actions-deploy.pub</code> 内容添加到公开仓库的 <strong>Deploy Keys</strong>（勾选允许写入）</li><li>将 <code>github-actions-deploy</code> 私钥内容添加到私有仓库的 <strong>Secrets</strong>，命名为 <code>DEPLOY_PRIVATE_KEY</code></li></ul><ol start="2"><li>创建 GitHub Actions 工作流文件</li></ol><ul><li>在私有仓库创建 <code>.github/workflows/deploy.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [<span class="string">main</span>]</span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">hexo-deployment:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">1</span><span class="string">.</span> <span class="string">checkout</span> <span class="string">分支</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">fetch-depth:</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">2</span><span class="string">.</span> <span class="string">Node</span> <span class="string">环境安装</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">&#x27;20&#x27;</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">3</span><span class="string">.</span> <span class="string">安装依赖和主题</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm ci --no-audit --no-fund</span></span><br><span class="line"><span class="string">        npm i hexo-theme-stellar</span></span><br><span class="line"><span class="string">        echo &quot;✅ 依赖安装完成&quot;</span></span><br><span class="line"><span class="string"></span>    </span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="number">4</span><span class="string">.</span> <span class="string">恢复文章修改时间</span></span><br><span class="line">  <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">git</span> <span class="string">ls-files</span> <span class="string">&#x27;source/_posts/**/*.md&#x27;</span> <span class="string">-z</span> <span class="string">|</span> <span class="string">while</span> <span class="string">IFS=</span> <span class="string">read</span> <span class="string">-r</span> <span class="string">-d</span> <span class="string">&#x27;&#x27;</span> <span class="string">file;</span> <span class="string">do</span> <span class="string">ts=$(git</span> <span class="string">log</span> <span class="number">-1</span> <span class="string">--format=%ct</span> <span class="string">--</span> <span class="string">&quot;$file&quot;</span> <span class="string">||</span> <span class="literal">true</span><span class="string">)</span> <span class="string">if</span> [ <span class="string">-n</span> <span class="string">&quot;$ts&quot;</span> ]<span class="string">;</span> <span class="string">then</span> <span class="string">touch</span> <span class="string">-d</span> <span class="string">&quot;@$ts&quot;</span> <span class="string">&quot;$file&quot;</span><span class="string">;</span> <span class="string">fi</span></span><br><span class="line">    <span class="string">done</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">files</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span>  <span class="comment"># 或 hexo generate</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">external_repository:</span> <span class="string">sswfive/sswfive.github.io</span>  <span class="comment"># 你的公开仓库</span></span><br><span class="line">        <span class="attr">publish_branch:</span> <span class="string">main</span>  <span class="comment"># 公开仓库的分支</span></span><br><span class="line">        <span class="attr">publish_dir:</span> <span class="string">./public</span>  <span class="comment"># Hexo 生成目录</span></span><br><span class="line">        <span class="attr">commit_message:</span> <span class="string">&#x27;🚀 Deploy from private blogsite repo&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="主要插件与配置"><a href="#主要插件与配置" class="headerlink" title="主要插件与配置"></a>主要插件与配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近，无意中看到一个博客主题：&lt;a href=&quot;https://github.com/xaoxuu/hexo-theme-stellar&quot;&gt;hexo-theme-stellar&lt;/a&gt; ，第一眼就被它优雅的设计所吸引。随后我仔细阅读了它的使用文档和一些实际案例，越发觉得它强</summary>
      
    
    
    
    <category term="博客建站" scheme="http://sswfive.xyz/categories/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
    
    <category term="博客建站" scheme="http://sswfive.xyz/tags/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>我在Mac上使用的字体搭配方案</title>
    <link href="http://sswfive.xyz/2025/09/22/tools/250922-mac-font-install/"/>
    <id>http://sswfive.xyz/2025/09/22/tools/250922-mac-font-install/</id>
    <published>2025-09-22T14:38:30.000Z</published>
    <updated>2025-10-09T16:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、字体选择"><a href="#一、字体选择" class="headerlink" title="一、字体选择"></a>一、字体选择</h2><h3 id="JetBrains-Mono"><a href="#JetBrains-Mono" class="headerlink" title="JetBrains Mono"></a>JetBrains Mono</h3><ul><li>来源：JetBrains官方出品，专为开发者设计</li><li>优点：对编程连字符支持好，字符形态清晰，能有效减少视觉疲劳。</li></ul><h3 id="霞鹜文楷屏幕阅读版"><a href="#霞鹜文楷屏幕阅读版" class="headerlink" title="霞鹜文楷屏幕阅读版"></a>霞鹜文楷屏幕阅读版</h3><ul><li>来源：基于开源字体「文楷」优化，专为屏幕显示打造。</li><li>优点：中文显示清晰锐利，字形现代，阅读体验舒适，并提供等宽版本，完美适配代码编辑器。</li></ul><p>在 GitHub releases页面上，可以根据下面字体特点和需求进行选择：</p><table><thead><tr><th>文件名</th><th>特点</th><th>推荐给</th></tr></thead><tbody><tr><td><strong><code>LXGWWenKaiGBScreen.ttf</code></strong></td><td><strong>大陆标准</strong>，非等宽</td><td>主要进行文档阅读的大陆用户</td></tr><tr><td><strong><code>LXGWWenKaiMonoGBScreen.ttf</code></strong></td><td><strong>大陆标准</strong> + <strong>等宽</strong></td><td><strong>中国大陆的程序员（强烈推荐）</strong></td></tr><tr><td><code>LXGWWenKaiScreen.ttf</code></td><td>通用版，非等宽</td><td>普通用户</td></tr><tr><td><code>LXGWWenKaiMonoScreen.ttf</code></td><td>通用版 + 等宽</td><td>需要等宽字体的用户</td></tr></tbody></table><h2 id="二、安装方法"><a href="#二、安装方法" class="headerlink" title="二、安装方法"></a>二、安装方法</h2><h3 id="方法1：手动安装"><a href="#方法1：手动安装" class="headerlink" title="方法1：手动安装"></a>方法1：手动安装</h3><ul><li>下载字体：<ul><li>JetBrains Mono：访问 <a href="https://www.jetbrains.com/lp/mono/">官网</a> 下载</li><li>霞鹜文楷屏幕阅读版：访问<a href="https://github.com/lxgw/LxgwWenKai-Screen/releases"> GitHub Releases 页面</a>，从 Assets 区选择所需文件</li></ul></li><li>安装：<ul><li>双击下载的 .ttf 文件，用「字体册」应用打开并点击“安装字体”。</li></ul></li></ul><h3 id="方法-2：使用-Homebrew"><a href="#方法-2：使用-Homebrew" class="headerlink" title="方法 2：使用 Homebrew"></a>方法 2：使用 Homebrew</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JetBrains Mono</span></span><br><span class="line">brew install --cask font-jetbrains-mono</span><br><span class="line"></span><br><span class="line"><span class="comment"># 霞鹜文楷目前还是建议使用手动安装</span></span><br></pre></td></tr></table></figure><h2 id="三、在-VS-Code-中启用字体"><a href="#三、在-VS-Code-中启用字体" class="headerlink" title="三、在 VS Code 中启用字体"></a>三、在 VS Code 中启用字体</h2><p>安装后，需在编辑器中设置才能生效。以 VS Code 为例：</p><ol><li>打开设置 (Cmd + ,)。</li><li>搜索 font family。</li><li>在设置中添加你的字体，确保将中文字体放在首位：</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;editor.fontFamily&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#x27;LXGW WenKai Mono GB Screen&#x27;, &#x27;JetBrains Mono&#x27;, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span></span><br></pre></td></tr></table></figure><p>配置逻辑：系统会优先使用「霞鹜文楷」渲染所有字符（包括英文），fallback 到「JetBrains Mono」确保特殊符号正常显示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、字体选择&quot;&gt;&lt;a href=&quot;#一、字体选择&quot; class=&quot;headerlink&quot; title=&quot;一、字体选择&quot;&gt;&lt;/a&gt;一、字体选择&lt;/h2&gt;&lt;h3 id=&quot;JetBrains-Mono&quot;&gt;&lt;a href=&quot;#JetBrains-Mono&quot; class=&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://sswfive.xyz/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Mac" scheme="http://sswfive.xyz/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>算法之【递归】</title>
    <link href="http://sswfive.xyz/2025/09/20/dsa/algo_recursion/"/>
    <id>http://sswfive.xyz/2025/09/20/dsa/algo_recursion/</id>
    <published>2025-09-20T15:29:16.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归（Recursion）概述"><a href="#递归（Recursion）概述" class="headerlink" title="递归（Recursion）概述"></a>递归（Recursion）概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>递归是一种算法，也是一种编程技巧，应用非常广泛。</li><li>递归求解问题的分解过程：去的过程叫“递”，回来的过程叫“归”</li><li>应用：DFS深度优先搜索、前中后序二叉树遍历</li></ul><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul><li>优点：<ul><li>递归代码表达能力强，写起来简洁</li></ul></li><li>缺点：<ul><li>空间复杂度高</li><li>有堆栈溢出的风险</li><li>存在重复计算</li><li>过多的函数调用会耗时较多</li></ul></li></ul><h3 id="递归公式Demo"><a href="#递归公式Demo" class="headerlink" title="递归公式Demo"></a>递归公式Demo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n)=f(n-1)+1 其中，f(1)=1</span><br><span class="line"></span><br><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 2;</span><br><span class="line">f(n) = f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><h2 id="什么场景的问题适合用递归解决"><a href="#什么场景的问题适合用递归解决" class="headerlink" title="什么场景的问题适合用递归解决"></a>什么场景的问题适合用递归解决</h2><blockquote><p>需要满足以下三个条件</p></blockquote><ul><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件<ul><li>不能出现无限循环</li></ul></li></ul><h2 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h2><ul><li>核心思想：写出递推公式，找到终止条件，然后将递推公式转化为代码</li><li>方法：<ul><li>找到如何将大问题分解为小问题的规律，并且写出递推公式</li><li>推敲终止条件</li><li>将递归公式和终止条件翻译成代码</li></ul></li><li>注意：<ul><li>只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要视图用人脑去分解递归的每个步骤（重复的步骤交给计算机完成）</li></ul></li></ul><h2 id="递归常见问题"><a href="#递归常见问题" class="headerlink" title="递归常见问题"></a>递归常见问题</h2><ul><li>递归代码要警惕堆栈溢出<ul><li>可以声明一个全局变量来控制递归深度，可以一定程度避免堆栈溢出</li></ul></li><li>递归代码要警惕重复计算<ul><li>通过某种数据结构来保存已经求解过的值，从而避免重复计算</li></ul></li><li>过多的函数调用会耗时较多，空间复杂度高</li></ul><h2 id="递归代码改非递归代码"><a href="#递归代码改非递归代码" class="headerlink" title="递归代码改非递归代码"></a>递归代码改非递归代码</h2><ul><li>递归代码都可以改为迭代循环的非递归写法</li><li>本质上是：将自动递归改为手动递归，本质问题没有解决</li><li>实现：<ol><li>抽象递推公式</li><li>初始值和边界条件</li><li>用迭代循环实现</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归（Recursion）概述&quot;&gt;&lt;a href=&quot;#递归（Recursion）概述&quot; class=&quot;headerlink&quot; title=&quot;递归（Recursion）概述&quot;&gt;&lt;/a&gt;递归（Recursion）概述&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>工具应用：终端的选择从iTerm2到Alacritty</title>
    <link href="http://sswfive.xyz/2025/09/19/tools/250919-terminal-alacritty/"/>
    <id>http://sswfive.xyz/2025/09/19/tools/250919-terminal-alacritty/</id>
    <published>2025-09-19T08:14:20.000Z</published>
    <updated>2025-10-17T03:27:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近把用了五年的 <a href="https://github.com/gnachman/iTerm2">iTerm2</a> 换成了 <a href="https://github.com/alacritty/alacritty">Alacritty</a>——一个基于 Rust 编写、使用 OpenGL 加速的跨平台终端，大小仅 6M，号称“全球最快的终端仿真器”。实际体验下来，响应速度确实非常流畅。</p><h2 id="安装-Alacritty"><a href="#安装-Alacritty" class="headerlink" title="安装 Alacritty"></a>安装 Alacritty</h2><p>你可以从 <a href="https://github.com/alacritty/alacritty/releases">GitHub Releases</a> 下载对应平台的安装包，也可以通过 Homebrew 快速安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install --cask alacritty</span><br></pre></td></tr></table></figure><h2 id="替换应用图标"><a href="#替换应用图标" class="headerlink" title="替换应用图标"></a>替换应用图标</h2><p>默认的 Alacritty 图标比较朴素，我选择从 <a href="https://www.freepik.com/search?format=search&iconType=standard&last_filter=query&last_value=terminal&query=terminal&type=icon">Freepik</a> 下载了一个更符合审美的 <code>.icns</code> 图标。替换方法也很简单：</p><ol><li>在「应用程序」中找到 <code>Alacritty.app</code></li><li>按下 <code>Command + i</code> 打开简介窗口</li><li>将下载的 <code>.icns</code> 文件拖到左上角的图标上</li><li>重启 Alacritty，新图标就会生效</li></ol><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><p>我个人偏好沉浸式头部和 JetBrains Mono 字体，以下是配置方法：</p><h3 id="安装-JetBrains-Mono-字体"><a href="#安装-JetBrains-Mono-字体" class="headerlink" title="安装 JetBrains Mono 字体"></a>安装 JetBrains Mono 字体</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-jetbrains-mono</span><br></pre></td></tr></table></figure><p>也可手动安装：</p><ol><li>访问 <a href="https://www.jetbrains.com/lp/mono/">JetBrains Mono 官网</a>下载字体文件</li><li>解压后双击 <code>.ttf</code> 或 <code>.otf</code> 文件安装</li></ol><p>验证是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc-list | grep <span class="string">&quot;JetBrains Mono&quot;</span></span><br></pre></td></tr></table></figure><h3 id="导入配置文件"><a href="#导入配置文件" class="headerlink" title="导入配置文件"></a>导入配置文件</h3><blockquote><p>参考一个大佬的配置：<a href="https://gw.alipayobjects.com/os/k/s0/alacritty.yml">点击下载</a></p></blockquote><p>我将常用配置整合在 <code>alacritty.yml</code> 中，执行以下命令一键导入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.config/alacritty &amp;&amp; \</span><br><span class="line">curl -fLo ~/.config/alacritty/alacritty.yml \</span><br><span class="line">     https://gw.alipayobjects.com/os/k/j2/alacritty.yml</span><br></pre></td></tr></table></figure><blockquote><p>如果配置与当前版本不兼容，可运行 <code>alacritty migrate</code> 进行迁移。</p></blockquote><h3 id="创建命令行快捷方式"><a href="#创建命令行快捷方式" class="headerlink" title="创建命令行快捷方式"></a>创建命令行快捷方式</h3><p>建议将 Alacritty 链接到 PATH，方便随时调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -sf /Applications/Alacritty.app/Contents/MacOS/alacritty /usr/local/bin/alacritty</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alacritty --version</span><br></pre></td></tr></table></figure><h2 id="常用快捷键配置"><a href="#常用快捷键配置" class="headerlink" title="常用快捷键配置"></a>常用快捷键配置</h2><p>在配置中定制了几个高频快捷键：</p><ul><li><code>Command + r</code>：清屏</li><li><code>Command + w</code>：隐藏窗口（原为退出）</li><li><code>Command + t</code>：新建窗口</li><li><code>Command + Shift + w</code>：关闭当前窗口</li><li><code>Command + Delete</code>：删除整行</li><li><code>Command + f</code>：搜索关键字</li><li><code>Command + ←/→</code>：跳至行首&#x2F;行尾</li></ul><h2 id="搭配-Tmux-使用"><a href="#搭配-Tmux-使用" class="headerlink" title="搭配 Tmux 使用"></a>搭配 Tmux 使用</h2><p>还整合了 Tmux 配置，实现更强大的终端管理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Tmux</span></span><br><span class="line">brew install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Tmux 配置</span></span><br><span class="line">curl -fLo ~/.tmux.conf https://gw.alipayobjects.com/os/k/8b/.tmux.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新 Alacritty 配置以适配 Tmux</span></span><br><span class="line">curl -fLo ~/.config/alacritty/alacritty.yml https://gw.alipayobjects.com/os/k/l9/alacritty.yml</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://tw93.fun/2023-02-06/alacritty.html">https://tw93.fun/2023-02-06/alacritty.html</a></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近把用了五年的 &lt;a href=&quot;https://github.com/gnachman/iTerm2&quot;&gt;iTerm2&lt;/a&gt; 换成了 &lt;a href=&quot;https://github.com/alacritty/alacritty&quot;&gt;Alacritty&lt;/a&gt;——一个基于</summary>
      
    
    
    
    <category term="ToolBox" scheme="http://sswfive.xyz/categories/ToolBox/"/>
    
    
    <category term="终端" scheme="http://sswfive.xyz/tags/%E7%BB%88%E7%AB%AF/"/>
    
    <category term="Alacritty" scheme="http://sswfive.xyz/tags/Alacritty/"/>
    
  </entry>
  
  <entry>
    <title>算法之【哈希】</title>
    <link href="http://sswfive.xyz/2025/09/18/dsa/algo_hash/"/>
    <id>http://sswfive.xyz/2025/09/18/dsa/algo_hash/</id>
    <published>2025-09-18T13:36:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念分析"><a href="#概念分析" class="headerlink" title="概念分析:"></a>概念分析:</h2><p><strong>Hash</strong>：通常翻译为“散列”，或“哈希”；就是把任意长度的二进制数据，通过散列算法，变换成固定长度的输出，即该输出就是散列值。</p><p><strong>哈希冲突（碰撞</strong>）: 指不同的数据，得到了同样的散列值，即为发生冲突（碰撞）。</p><h2 id="Hash中的算法"><a href="#Hash中的算法" class="headerlink" title="Hash中的算法"></a>Hash中的算法</h2><blockquote><p>也称消息摘要算法<br>消息摘要（Message Digest）又称数字摘要（Digital Digest）,该摘要是一个唯一对应一个消息或文本的固定长度的值，，它由一个单向Hash加密函数对消息进行作用而生成，本质就是：散列表或者哈希值。</p></blockquote><h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>SHA（Secure Hash Algorithm）算法称为安全散列算法,能计算出一个数字消息对应到的长度固定的字符串（又称消息摘要）的算法。<br>该算法又细分为：SHA-1、SHA-224、SHA-256、SHA-384、SHA-512这五种算法，其中后四种并称为SHA-2算法。</p><blockquote><p>SHA-1在许多安全协定中广为使用，包括TLS和SSL、PGP、SSH、S&#x2F;MIME和IPsec，曾被视为是MD5的后继者<br>但SHA-1的安全性如今被密码学家严重质疑；虽然至今尚未出现对SHA-2有效的攻击，它的算法跟SHA-1基本上仍然相似</p></blockquote><ul><li>特点：<ul><li>由讯息摘要反推原输入讯息，从计算理论上来说是很困难的。 不可逆</li><li>想要找到两组不同的讯息对应到相同的讯息摘要，从计算理论上来说也是很困难的。</li><li>任何对输入讯息的变动，都有很高的机率导致其产生的讯息摘要迥异。无冲突</li></ul></li></ul><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><p>MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。</p><ul><li>特点：<ul><li>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>2、容易计算：从原数据计算出MD5值很容易。</li><li>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念分析&quot;&gt;&lt;a href=&quot;#概念分析&quot; class=&quot;headerlink&quot; title=&quot;概念分析:&quot;&gt;&lt;/a&gt;概念分析:&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Hash&lt;/strong&gt;：通常翻译为“散列”，或“哈希”；就是把任意长度的二进制数据，通过散列算法，变</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DS&amp;A" scheme="http://sswfive.xyz/tags/DS-A/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【栈】</title>
    <link href="http://sswfive.xyz/2025/09/17/dsa/250917-stack/"/>
    <id>http://sswfive.xyz/2025/09/17/dsa/250917-stack/</id>
    <published>2025-09-17T13:36:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导"><a href="#问题向导" class="headerlink" title="问题向导"></a>问题向导</h2><ul><li>问题1：如何实现浏览器的前进和后退功能？<ul><li>问题描述：浏览器的前进、后退功能，我想你肯定很熟悉吧？当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</li></ul></li><li>思路：<ul><li>使用两个栈来实现</li></ul></li><li>实现：<ul><li>使用两个栈，X和Y,把首次浏览的页面依次压入栈X, 当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈Y。当点击前进按钮时，依次从栈Y中取出数据，放入栈X中。当栈X中没有数据时，那就说明没有页面可以继续后退浏览了。当栈Y中没有数据，那就说明没有页面可以点击前进按钮浏览了。</li></ul></li></ul><h2 id="栈的概述："><a href="#栈的概述：" class="headerlink" title="栈的概述："></a>栈的概述：</h2><ul><li>定义：<ul><li>后进者先出，先进者后出的数据结构称为“栈”</li></ul></li><li>理解：<ul><li>一摞叠在一起的盘子，放盘子的时候都是从下往上一个一个放，取的时候都是从上往下一个一个的取，不能从中间任意取</li></ul></li><li>操作特性：<ul><li>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据</li></ul></li><li>类别：<ul><li>从功能上，数据或链表都能替代栈，但特定的数据结构是对特定场景的抽象，另一方面，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时比较不可控，就会容易出错</li></ul></li><li>使用场景：<ul><li>当某个数据集合只涉及到在一端插入和删除数据，并且满足后进先出，先进后出的特性，就可以使用栈</li></ul></li><li>栈的复杂度：<ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(1)</li></ul></li><li>实现：<ul><li>数组实现-&gt;顺序栈</li><li>链表实现-&gt;链式栈</li></ul></li></ul><h3 id="动态扩容的顺序栈实现："><a href="#动态扩容的顺序栈实现：" class="headerlink" title="动态扩容的顺序栈实现："></a>动态扩容的顺序栈实现：</h3><ul><li>实现：<ul><li>只需要底层依赖一个支持动态扩容的数组就可以 了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。</li></ul></li><li>复杂度<ul><li>出栈：O(1)<ul><li>不会涉及到内存的重新分配和数据的搬迁</li></ul></li><li>入栈：最坏：O(n), 最好：O(1)</li><li>分析方法：摊还分析法，</li></ul></li></ul><blockquote><p>摊还分析法细节：<br>为了分析的方便，我们需要事先做一些假设和定义：</p><ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li><li>为了简化分析，假设只有入栈操作没有出栈操作；</li><li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)。</li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。为了让你更加直观地理解这个过程，我画了一张图。<br>你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。<br>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p></blockquote><h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul><li><p>入栈push()</p></li><li><p>出栈pop()</p></li></ul><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><h3 id="一、在函数中的应用"><a href="#一、在函数中的应用" class="headerlink" title="一、在函数中的应用"></a>一、在函数中的应用</h3><blockquote><p>函数调用栈</p></blockquote><ul><li><p>操作系统给每个线程分配了一个独立的内存空间，这块内存被组织成为“栈”这种结构，用来存储函数调用时的临时变量，每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p></li><li><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相 加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作。</p></li></ul><h3 id="二、在表达式求值中的应用"><a href="#二、在表达式求值中的应用" class="headerlink" title="二、在表达式求值中的应用"></a>二、在表达式求值中的应用</h3><ul><li>eg: 34+13*9+44-12&#x2F;3</li><li>实现思路：<ul><li>编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。从左向右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</li><li>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li></ul></li></ul><h3 id="三、在括号匹配中的应用"><a href="#三、在括号匹配中的应用" class="headerlink" title="三、在括号匹配中的应用"></a>三、在括号匹配中的应用</h3><blockquote><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，<code>&#123;[] ()[&#123;&#125;]&#125;或[&#123;()&#125;([])]</code>等都为合法格式，而<code>&#123;[&#125;()]</code>或<code>[(&#123;)]</code>为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p></blockquote><ul><li>使用栈来检查表达式中的括号是否匹配：<code>&#123;[] ()[&#123;&#125;]&#125;或[&#123;()&#125;([])]</code></li><li>实现思路<ul><li>用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如<code>“(”跟“)”</code>匹配，<code>“[”跟“]”匹配，“&#123;”跟“&#125;”</code>匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，</li><li>如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导&quot;&gt;&lt;a href=&quot;#问题向导&quot; class=&quot;headerlink&quot; title=&quot;问题向导&quot;&gt;&lt;/a&gt;问题向导&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：如何实现浏览器的前进和后退功能？&lt;ul&gt;
&lt;li&gt;问题描述：浏览器的前进、后退功能，我想你肯定很熟悉吧？</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【队列】</title>
    <link href="http://sswfive.xyz/2025/09/15/dsa/250915-equeue/"/>
    <id>http://sswfive.xyz/2025/09/15/dsa/250915-equeue/</id>
    <published>2025-09-15T15:36:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导"><a href="#问题向导" class="headerlink" title="问题向导"></a>问题向导</h2><ul><li>问题1：线程池没有空闲线程时，新的任务请求 线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</li><li>思路：<ul><li>处理策略一：非阻塞的处理方式，直接拒绝任务请求</li><li>处理策略二：阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</li></ul></li><li>实现：<ul><li>对于处理策略二,引入队列来解决存储排队请求。</li><li>对于此队列的实现，有两种方式，基于链表实现和基于数组实现，这两种方式实现思路如下：<ul><li>链式队列（基于链表实现）：实现一个支持无限排队的无界队列，但随着请求数的增加，请求排队和处理的响应时间也会随之增加，这对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li><li>有界队列（基于数组实现）：队列的大小有限，故线程池中排队的请求超过队列大小时，后续请求将会被拒绝，此种方式对相应时间比较敏感的系统来说，就比较合适，但存在另外一个问题，如何设置队列的大小，就很考验开发者的经验和能力（队列太大导致请求太多，队列太小会导致无法充分利用系统资源，发挥最大性能）。</li></ul></li></ul></li></ul><h2 id="队列概述"><a href="#队列概述" class="headerlink" title="队列概述"></a>队列概述</h2><ul><li><p>概念：</p><ul><li>先进者先出的数据结构，就是队列<ul><li>类比排队买东西</li></ul></li><li>是一种抽象的数据结构</li><li>是一种操作受限的线性表数据结构（栈也是如此）</li></ul></li><li><p>特点：</p><ul><li>先进先出</li><li>支持在队尾插入元素，在队头删除元素</li></ul></li><li><p>实现</p><ul><li><p>数组实现-&gt;顺序队列</p></li><li><p>链表实现-&gt;链式队列</p></li></ul></li></ul><h2 id="队列的操作"><a href="#队列的操作" class="headerlink" title="队列的操作"></a>队列的操作</h2><ul><li>入队enqueue()<ul><li>放一个数据到队列的尾部</li></ul></li><li>出队dequeue()<ul><li>从队列的头部取一个元素</li></ul></li></ul><h2 id="队列的种类"><a href="#队列的种类" class="headerlink" title="队列的种类"></a>队列的种类</h2><ul><li>顺序队列</li><li>链式队列</li><li>循环队列</li><li>阻塞队列</li><li>并发队列</li></ul><h3 id="队列—顺序队列"><a href="#队列—顺序队列" class="headerlink" title="队列—顺序队列"></a>队列—顺序队列</h3><ul><li>使用数组来实现</li><li>实现思路：<ul><li>引入两个指针：<ul><li>head指针：指向队头</li><li>tail指针：指向队尾</li></ul></li><li>入队操作时：head指针指向下标为0的位置，tail顺次往后移动，当tail移动到最后，表明数组不能继续添加数据了</li><li>出队操作时：tail指针指向队列的尾部，head指针顺次往后移动，当head移动tail的位置，表明数组已没有元素。</li></ul></li><li>注意：当tail指针移动到最后，即使数组里还有空闲空间，队列也无法插入数据，这是一个问题<ul><li>解决方法：对数据进行搬移，在每次进行出队操作时，将出队的元素标记为删除，当队列没有空间时，再集中出发数据搬移操作，</li></ul></li></ul><h3 id="队列—链式队列"><a href="#队列—链式队列" class="headerlink" title="队列—链式队列"></a>队列—链式队列</h3><ul><li>使用链表实现</li><li>实现思路：<ul><li>引入两个指针：<ul><li>head指针：指向链表的第一个结点</li><li>tail指针：指向链表的最后一个节点</li></ul></li><li>入队操作时：<ul><li>tail-&gt;next&#x3D; new_node, tail &#x3D; tail-&gt;next；</li></ul></li><li>出队操作时：<ul><li>head &#x3D; head-&gt;next</li></ul></li></ul></li></ul><h3 id="队列—循环队列"><a href="#队列—循环队列" class="headerlink" title="队列—循环队列"></a>队列—循环队列</h3><ul><li><p>主要是解决顺序队列数据搬移的问题，而是实现的一种队列</p></li><li><p>循环队列：把数组的收尾相连，折成一个环</p></li><li><p>实现思路：</p><ul><li>队列的大小为 8，当前 head&#x3D;4，tail&#x3D;7。当有一个新的元素 a 入队 时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1</li></ul></li><li><p>注意点：需要确定好队空和队满的判定条件。</p><ul><li>对空判定： head &#x3D;&#x3D; tail</li><li>队满判定：(tail+1)%n&#x3D;head。<ul><li>队满时，tail 指向的位置实际上是没有存储数据的。故循环队列 会浪费一个数组的存储空间。</li></ul></li></ul></li></ul><h3 id="队列—阻塞队列"><a href="#队列—阻塞队列" class="headerlink" title="队列—阻塞队列"></a>队列—阻塞队列</h3><ul><li><p>在队列的基础上增加了阻塞操作，</p></li><li><p>若在队列为空时，从队头取数据会被阻塞，若在队列已满时，从队尾插入数据会被阻塞，直到队列中有空闲位置在插入数据，然后再返回。</p></li><li><p>实际应用：</p><ul><li>生产者-消费者模型</li></ul></li></ul><h3 id="队列—并发队列"><a href="#队列—并发队列" class="headerlink" title="队列—并发队列"></a>队列—并发队列</h3><ul><li>线程安全的队列就是并发队列</li><li>基于数组的循环队列，利用CAS原子操作，可以实现高效的并发队列。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导&quot;&gt;&lt;a href=&quot;#问题向导&quot; class=&quot;headerlink&quot; title=&quot;问题向导&quot;&gt;&lt;/a&gt;问题向导&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：线程池没有空闲线程时，新的任务请求 线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？&lt;/li</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python中的数据类型用法剖析：从底层实现到高效应用</title>
    <link href="http://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/"/>
    <id>http://sswfive.xyz/2025/09/14/tech/python/250914-py-data-struct/</id>
    <published>2025-09-14T14:13:01.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Python的世界里，我们每天都在和 <code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code> 打交道。但你有没有想过：</p><ul><li>为什么元组比列表快？</li><li>字典为什么查找那么高效？</li><li>列表扩容背后的策略是什么？</li><li><code>set</code> 真的是“无序”的吗？</li></ul><p>这些看似基础的问题，其实都源于Python对数据类型的底层设计。接下来，我们就来<strong>深入剖析Python中常见数据类型的本质</strong>，从“序列”、“容器”这些抽象概念讲起，到 <code>list</code> 与 <code>tuple</code>、<code>dict</code> 与 <code>set</code> 的对比实践，以及最后的相关的底层实现原理。</p><h2 id="理清概念：这些“类型名词”是什么"><a href="#理清概念：这些“类型名词”是什么" class="headerlink" title="理清概念：这些“类型名词”是什么"></a>理清概念：这些“类型名词”是什么</h2><p>刚开始学Python时，你可能听过这些术语：<code>list</code> 是可变序列”、“<code>str</code> 是扁平序列”、“<code>dict</code> 是容器类型……听起很玄乎，其实他们只是从不同视角对数据结构的分类，我们来一一拆解。</p><h3 id="1-序列类型-Sequence"><a href="#1-序列类型-Sequence" class="headerlink" title="1. 序列类型(Sequence)"></a>1. 序列类型(Sequence)</h3><p>提到 “序列”，你可以先联想日常生活中的 “排队”—— 每个人（数据）按顺序站好，有自己的位置（索引），这就是序列的核心特征。</p><p><strong>什么是序列？</strong><br>广义上，序列是一种<strong>连续存储的数据格式</strong>，就像把书按顺序摆放在书架的同一层，每个数据都有固定的 “位置编号”，通过编号能快速找到对应数据。简单说，序列就是一组按照顺序排列的数据集合。</p><p><strong>什么是Python中的序列类型？</strong></p><p>Python对序列做了一层抽象封装，形成了“序列类型”，只要某个数据类型支持一下操作，就可以归为序列类型：</p><ul><li>支持索引访问：<code>seq[0]</code></li><li>支持切片操作：<code>seq[1:3]</code></li><li>支持连接与重复：<code>seq1 + seq2</code>、<code>seq * 3</code></li><li>支持成员判断：<code>x in seq</code></li></ul><p>Python 中常见的序列类型有：<code>list</code>（列表）、<code>tuple</code>（元组）、<code>str</code>（字符串）、<code>bytes</code>（字节串）、<code>array</code>（数组）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 序列通用操作示例</span></span><br><span class="line">demo_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(demo_list[<span class="number">2</span>])      <span class="comment"># 索引: 3</span></span><br><span class="line"><span class="built_in">print</span>(demo_list[<span class="number">1</span>:<span class="number">4</span>])    <span class="comment"># 切片: [2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span> <span class="keyword">in</span> demo_list)    <span class="comment"># 成员检测: True</span></span><br></pre></td></tr></table></figure><p><strong>序列类型的两种分类方式</strong></p><ul><li><strong>可变序列 vs 不可变序列</strong></li></ul><table><thead><tr><th>类型</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>可变序列(MutableSequence)</td><td>可以动态增删改</td><td><code>list</code>, <code>bytearray</code>, <code>array.array</code></td></tr><tr><td>不可变序列(Sequence)</td><td>一旦创建就不能修改，任何“修改”操作都会返回新对象</td><td><code>tuple</code>, <code>str</code>, <code>bytes</code></td></tr></tbody></table><blockquote><p>Tips：<code>tuple</code>虽然是不可变，但如果它内部包含<code>list</code>，你依然可以修改那个<code>list</code>,因为 <code>tuple</code>只保证“引用不变”，不保证“内容不变”。</p></blockquote><ul><li><strong>容器序列 vs 扁平序列</strong></li></ul><table><thead><tr><th>类型</th><th>存储内容</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>容器序列</td><td>存储对象的<strong>引用</strong></td><td>可以嵌套任意类型</td><td><code>list</code>, <code>tuple</code></td></tr><tr><td>扁平序列</td><td>存储对象的<strong>值本身</strong></td><td>更紧凑，效率更高</td><td><code>str</code>, <code>bytes</code>, <code>array</code></td></tr></tbody></table><blockquote><p>举个例子：<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code> 中每个元素都是对字符串对象的引用；而 <code>&#39;abc&#39;</code> 是连续的字符值存储在内存中，更节省空间。</p></blockquote><h3 id="2-数值类型（Number）"><a href="#2-数值类型（Number）" class="headerlink" title="2. 数值类型（Number）"></a>2. 数值类型（Number）</h3><p>数值类型是Python中最基础的数据类型之一，专门用来表示数字，主要包括三类：</p><ul><li><strong>整数（int）</strong>：比如 <code>10</code>、<code>-5</code>、<code>0</code>，Python 的 int 没有大小限制，能存非常大的数（比如 <code>10**100</code> 这样的 “天文数字”）。</li><li><strong>布尔值（bool）</strong>：特殊的 int 子类，只有 <code>True</code>（等价于 1）和 <code>False</code>（等价于 0）两个值，常用于条件判断。</li><li><strong>浮点数（float）</strong>：带小数点的数字，比如 <code>3.14</code>、<code>-0.5</code>，注意浮点数有精度限制（比如 <code>0.1 + 0.2</code> 不等于 <code>0.3</code>）。</li><li><strong>复数（complex）</strong>：形如 <code>a + bj</code> 的数字（<code>j</code> 是虚数单位），比如 <code>2 + 3j</code>，主要用于科学计算场景。</li></ul><p>需要注意的是，它们不属于“容器”，因为不包含其他对象，是<strong>原子性</strong>的。</p><h3 id="3-容器类型-Container"><a href="#3-容器类型-Container" class="headerlink" title="3. 容器类型(Container)"></a>3. 容器类型(Container)</h3><p>这里的 “容器类型” 和前面提到的 “容器序列” 不一样 —— 它是从 “功能” 角度分类，指所有能 “容纳其他对象” 的数据结构。简单说，只要一个数据类型能把多个对象 “打包” 在一起，就是容器类型。</p><ul><li><p><strong>容器序列</strong>：特指 <code>list</code>、<code>tuple</code> 这类支持索引的序列。</p></li><li><p><strong>容器类型</strong>：泛指能容纳其他对象的数据结构，比如 <code>dict</code>、<code>set</code>、<code>list</code>。</p></li></ul><p>Python 中最常用的容器类型有 4 个：</p><ul><li><strong>list</strong>（列表）：可变、有序，能存任意类型数据</li><li><strong>tuple</strong>（元组）：不可变、有序，能存任意类型数据</li><li><strong>dict</strong>（字典）：可变、键值对结构，3.7 + 后有序</li><li><strong>set</strong>（集合）：可变、无序，元素唯一</li></ul><p>接下来我们就聚焦这 4 个核心容器类型，从语法、原理、性能到场景，做一次全方位对比。</p><h2 id="list-vs-tuple：动态与静态的选择"><a href="#list-vs-tuple：动态与静态的选择" class="headerlink" title="list vs tuple：动态与静态的选择"></a>list vs tuple：动态与静态的选择</h2><h3 id="基本用法对比"><a href="#基本用法对比" class="headerlink" title="基本用法对比"></a>基本用法对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># list: 可变，灵活</span></span><br><span class="line">demo_list = [<span class="string">&#x27;AA&#x27;</span>, <span class="string">&#x27;BB&#x27;</span>, <span class="number">3</span>, <span class="literal">True</span>]</span><br><span class="line">demo_list = []          <span class="comment"># 创建、初始化</span></span><br><span class="line">demo_list = <span class="built_in">list</span>()      <span class="comment"># 创建、初始化</span></span><br><span class="line">demo_list.append(<span class="number">3.14</span>)  <span class="comment"># 添加元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple: 不可变，稳定 </span></span><br><span class="line">demo_tuple = <span class="built_in">tuple</span>()             <span class="comment"># 空元组</span></span><br><span class="line">demo_tuple = (<span class="number">1</span>,)                <span class="comment"># 单元素元组必须有逗号</span></span><br><span class="line">demo_tuple = (<span class="number">1</span>, <span class="string">&#x27;hello&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 多元素元组</span></span><br><span class="line">demo_tuple[<span class="number">0</span>] = <span class="number">2</span>                <span class="comment"># 报错！不支持修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tuple&quot;新增&quot;实际是创建新元组</span></span><br><span class="line">demo_tuple_raw= (<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">demo_tuple_new = demo_tuple_raw + (<span class="literal">True</span>,)  <span class="comment"># 创建新元组 (1, 2.0, &#x27;a&#x27;, True)</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>特性</th><th>list</th><th>tuple</th></tr></thead><tbody><tr><td>是否可变</td><td>是</td><td>否</td></tr><tr><td>是否支持增删改</td><td>是</td><td>否</td></tr><tr><td>是否支持索引&#x2F;负数索引&#x2F;切片</td><td>是</td><td>是</td></tr><tr><td>内存占用</td><td>较大</td><td>较小</td></tr><tr><td>创建速度</td><td>慢</td><td>快</td></tr><tr><td>是否相互转换</td><td>tuple()</td><td>list()</td></tr></tbody></table><h3 id="list的实现机制"><a href="#list的实现机制" class="headerlink" title="list的实现机制"></a>list的实现机制</h3><p>Python的<code>list</code>实际上是一个<strong>动态扩容顺序表</strong>，采用“<strong>分离式结构</strong>”：</p><ul><li>表头（对象元信息）和数据区分开存储。</li><li>初始分配8个元素空间，不够时自动扩容。</li></ul><p>扩容策略：</p><ul><li>小列表（&lt;50000）：扩容为原来的 <strong>4倍</strong></li><li>大列表（≥50000）：扩容为原来的 <strong>2倍</strong></li></ul><p>这种“过度分配”（over-allocation）策略保证了 <code>append()</code> 操作的<strong>均摊时间复杂度为 O(1)</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">demo_list = []</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 40 字节（空列表）</span></span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 72 → 分配了4个元素的空间 (72-40)/8 = 4</span></span><br><span class="line"></span><br><span class="line">demo_list.extend(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 加满4个</span></span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 72</span></span><br><span class="line"></span><br><span class="line">demo_list.append(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(demo_list.__sizeof__())  <span class="comment"># 104 → 扩容！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_memory_usage</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;查看列表动态扩容过程&quot;&quot;&quot;</span></span><br><span class="line">    lst = []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;空列表大小: <span class="subst">&#123;lst.__sizeof__()&#125;</span> bytes&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        lst.append(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;添加<span class="subst">&#123;i&#125;</span>后: <span class="subst">&#123;lst.__sizeof__()&#125;</span> bytes, 元素数: <span class="subst">&#123;<span class="built_in">len</span>(lst)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">check_memory_usage()</span><br></pre></td></tr></table></figure><h3 id="tuple的实现机制"><a href="#tuple的实现机制" class="headerlink" title="tuple的实现机制"></a>tuple的实现机制</h3><p><code>tuple</code> 使用“<strong>一体式结构</strong>”的顺序表，创建后大小固定，不能扩容。</p><p>正因为不可变，Python 可以对<strong>小元组进行缓存</strong>。比如 <code>(1,2,3)</code> 第一次创建后会被缓存，下次再创建相同的元组，直接复用内存，<strong>极大提升性能</strong>。</p><h3 id="list-与-tuple-性能对比"><a href="#list-与-tuple-性能对比" class="headerlink" title="list 与 tuple 性能对比"></a>list 与 tuple 性能对比</h3><p>使用<code>timeit</code>模块进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 速度对比</span></span><br><span class="line">python3 -m timeit <span class="string">&#x27;x=(1,2,3,4,5,6)&#x27;</span></span><br><span class="line"><span class="comment"># 20000000 loops, best of 5: 9.97 nsec per loop</span></span><br><span class="line"></span><br><span class="line">python3 -m timeit <span class="string">&#x27;x=[1,2,3,4,5,6]&#x27;</span></span><br><span class="line"><span class="comment"># 5000000 loops, best of 5: 50.1 nsec per loop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 速度对比</span></span><br><span class="line">python3 -m timeit -s <span class="string">&#x27;x=[1,2,3,4,5,6]&#x27;</span> <span class="string">&#x27;y=x[3]&#x27;</span></span><br><span class="line"><span class="comment"># 10000000 loops, best of 5: 22.2 nsec per loop</span></span><br><span class="line"></span><br><span class="line">python3 -m timeit -s <span class="string">&#x27;x=(1,2,3,4,5,6)&#x27;</span> <span class="string">&#x27;y=x[3]&#x27;</span></span><br><span class="line"><span class="comment"># 10000000 loops, best of 5: 21.9 nsec per loop</span></span><br></pre></td></tr></table></figure><p>结论：tuple的创建速度更优，访问速度略快。其原因在于：</p><ul><li>静态结构，无需维护扩容信息</li><li>Python缓存常用tuple，减少内存的分配开销</li><li>更少的功能意味着更小的开销</li></ul><h3 id="应用场景选择"><a href="#应用场景选择" class="headerlink" title="应用场景选择"></a>应用场景选择</h3><table><thead><tr><th>场景</th><th>推荐类型</th></tr></thead><tbody><tr><td>存储固定数据（如坐标、配置）</td><td><code>tuple</code></td></tr><tr><td>函数返回多个值</td><td><code>tuple</code>（<code>return x, y</code>）</td></tr><tr><td>需要频繁增删改的数据</td><td><code>list</code></td></tr><tr><td>用作字典的键</td><td><code>tuple</code>（不可变）</td></tr><tr><td>作为集合元素</td><td><code>tuple</code></td></tr></tbody></table><ul><li>使用元组的场景</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 返回经纬度坐标</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_location</span>():</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (longitude, latitude)  <span class="comment"># 使用元组保证数据不可变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 函数返回多个值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_info</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="comment"># 返回用户姓名、年龄、邮箱</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&quot;BluesSen&quot;</span>, <span class="number">32</span>, <span class="string">&quot;bluessen@email.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 配置信息存储</span></span><br><span class="line">DATABASE_CONFIG = (<span class="string">&quot;localhost&quot;</span>, <span class="number">3306</span>, <span class="string">&quot;my_db&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>使用列表的场景</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 记录用户一周内看过的帖子ID</span></span><br><span class="line">viewer_owner_id_list = []</span><br><span class="line">records = queryDB(viewer_id)  <span class="comment"># 查询数据库</span></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> records:</span><br><span class="line">    viewer_owner_id_list.append(record.<span class="built_in">id</span>)  <span class="comment"># 动态添加元素</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 2. 动态数据收集</span></span><br><span class="line">user_actions = []  <span class="comment"># 收集用户操作日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_action</span>(<span class="params">action</span>):</span><br><span class="line">    user_actions.append(action)  <span class="comment"># 动态添加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 需要修改的数据</span></span><br><span class="line">shopping_cart = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;milk&quot;</span>]</span><br><span class="line">shopping_cart.remove(<span class="string">&quot;banana&quot;</span>)  <span class="comment"># 修改购物车</span></span><br><span class="line">shopping_cart.sort()           <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><h3 id="常用操作汇总"><a href="#常用操作汇总" class="headerlink" title="常用操作汇总"></a>常用操作汇总</h3><p><strong>list操作：</strong></p><ul><li><code>index()</code>：返回指定元素下标</li><li><code>count()</code>：统计元素出现次数</li><li><code>len()</code>：获取列表长度</li><li><code>append()</code>：末尾追加元素</li><li><code>extend()</code>：扩展列表（添加序列中的所有元素）</li><li><code>insert()</code>：指定位置插入元素</li><li><code>pop()</code>：删除并返回指定位置元素（默认最后）</li><li><code>remove()</code>：移除第一个匹配项</li><li><code>clear()</code>：清空列表</li><li><code>reverse()</code>和<code>sort()</code>：原地反转和排序</li></ul><p><strong>tuple操作：</strong></p><ul><li><code>index()</code>：查找元素位置</li><li><code>count()</code>：统计元素出现次数</li><li><code>len()</code>：获取元组长度</li></ul><p><strong>通用函数：</strong></p><ul><li><code>reversed()</code>：返回反转后的迭代器</li><li><code>sorted()</code>：返回排序后的新列表</li></ul><p><strong>注意</strong>：如果想给元组排序 &#x2F; 反转，可以用全局函数 <code>sorted()</code> 和 <code>reversed()</code>，它们会返回新列表 &#x2F; 迭代器，不修改原元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">sorted_t = <span class="built_in">sorted</span>(t)  <span class="comment"># 输出 [1,2,3]（列表）</span></span><br><span class="line">reversed_t = <span class="built_in">list</span>(<span class="built_in">reversed</span>(t))  <span class="comment"># 输出 [2,1,3]（转成列表）</span></span><br></pre></td></tr></table></figure><h2 id="dict-vs-set：键值对与去重利器"><a href="#dict-vs-set：键值对与去重利器" class="headerlink" title="dict vs set：键值对与去重利器"></a>dict vs set：键值对与去重利器</h2><h3 id="基本用法对比-1"><a href="#基本用法对比-1" class="headerlink" title="基本用法对比"></a>基本用法对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典：键值对</span></span><br><span class="line">demo_dict = &#123;&#125;  <span class="comment"># 空字典</span></span><br><span class="line">demo_dict = <span class="built_in">dict</span>()  <span class="comment"># 空字典</span></span><br><span class="line">user = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合：唯一元素</span></span><br><span class="line">demo_set = <span class="built_in">set</span>()  <span class="comment"># 空集合只能用set()</span></span><br><span class="line">demo_set = &#123;<span class="number">10</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">20.0</span>, <span class="literal">False</span>, <span class="number">50</span>&#125;</span><br><span class="line">tags = &#123;<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;backend&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员检测效率对比</span></span><br><span class="line">large_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1000000</span>))</span><br><span class="line">large_set = <span class="built_in">set</span>(large_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表检测: O(n)时间复杂度</span></span><br><span class="line"><span class="comment"># 集合检测: O(1)时间复杂度</span></span><br></pre></td></tr></table></figure><ul><li><strong>关键区别</strong>：空字典用 <code>&#123;&#125;</code> 或 <code>dict()</code>，空集合只能用 <code>set()</code>—— 因为 <code>&#123;&#125;</code> 优先被解析为字典。</li></ul><h3 id="核心特性对比"><a href="#核心特性对比" class="headerlink" title="核心特性对比"></a>核心特性对比</h3><table><thead><tr><th>特性</th><th>Dict（字典）</th><th>Set（集合）</th></tr></thead><tbody><tr><td>存储结构</td><td>键值对（key: value）</td><td>单个元素（无键值）</td></tr><tr><td>元素唯一性</td><td>key 唯一，value 可重复</td><td>所有元素唯一（自动去重）</td></tr><tr><td>有序性</td><td>3.7+ 有序（插入顺序）</td><td>无序（无法通过索引访问）</td></tr><tr><td>索引访问</td><td>通过 key 访问，如 <code>d[&#39;key&#39;]</code></td><td>无序，无索引</td></tr><tr><td>核心用途</td><td>高效查询（通过 key 找 value）</td><td>去重、集合运</td></tr><tr><td>时间复杂度（查&#x2F;增&#x2F;删）</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h3 id="哈希表结构演变"><a href="#哈希表结构演变" class="headerlink" title="哈希表结构演变"></a>哈希表结构演变</h3><p><strong>老版本结构（紧凑但低效）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">| <span class="built_in">hash</span> | key  | value           |</span><br><span class="line">+-------------------------------+</span><br><span class="line">| 123  | <span class="string">&#x27;a&#x27;</span>  | 10              |</span><br><span class="line">| 456  | <span class="string">&#x27;b&#x27;</span>  | 20              |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><p><strong>新版本结构（稀疏索引 + 紧凑存储）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Indices: [None, 0, None, None, 1, ...]</span><br><span class="line"></span><br><span class="line">Entries:</span><br><span class="line">+------------------+</span><br><span class="line">| <span class="built_in">hash</span> | key | val |</span><br><span class="line">+------------------+</span><br><span class="line">| 123  | <span class="string">&#x27;a&#x27;</span> | 10  |</span><br><span class="line">| 456  | <span class="string">&#x27;b&#x27;</span> | 20  |</span><br><span class="line">+------------------+</span><br></pre></td></tr></table></figure><p>优势：节省内存、提升遍历速度、支持有序迭代。</p><h3 id="dict和set-的实现机制"><a href="#dict和set-的实现机制" class="headerlink" title="dict和set 的实现机制"></a>dict和set 的实现机制</h3><p><code>dict</code> 和 <code>set</code> 的核心都是<strong>哈希表（Hash Table）</strong>，通过哈希函数将键映射到数组索引，实现近乎常数时间的查找。Python采用优化后的哈希表结构，提高了内存利用率和访问效率。</p><ul><li><code>dict</code> 的哈希表结构：存储“哈希值（hash）、键（key）、值（value）”三个元素，支持快速键值查找</li></ul><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 索引区（记录元素在数据区的位置）</span><br><span class="line">Indices: [None, 0, None, 2, None, 1, ...]</span><br><span class="line"># 数据区（存储实际的键值对和哈希值）</span><br><span class="line">Entries:</span><br><span class="line">[hash0, key0, value0]  # 位置0</span><br><span class="line">[hash1, key1, value1]  # 位置1</span><br><span class="line">[hash2, key2, value2]  # 位置2</span><br></pre></td></tr></table></figure><ul><li><code>set</code> 只存储 “哈希值（hash）、元素（element）”，因为没有 value，结构更简单, 专注于快速成员检测</li></ul><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entries:</span><br><span class="line">[hash0, element0]  # 位置0</span><br><span class="line">[hash1, element1]  # 位置1</span><br><span class="line">[hash2, element2]  # 位置2</span><br></pre></td></tr></table></figure><p><strong>操作分析：</strong></p><ol><li><strong>插入操作</strong>：<ul><li>计算键的哈希值并与mask做与操作得到位置index</li><li>如果位置空，直接插入</li><li>如果位置被占用，比较哈希值和键</li><li>都相等：更新值（字典）或忽略（集合）</li><li>不相等（哈希冲突）：继续寻找空位</li></ul></li><li><strong>查找操作</strong>：<ul><li>类似插入过程，找到对应位置后比较哈希值和键</li></ul></li><li><strong>删除操作</strong>：<ul><li>标记删除位置，等待哈希表调整时真正删除</li></ul></li></ol><h3 id="哈希冲突与扩容机制"><a href="#哈希冲突与扩容机制" class="headerlink" title="哈希冲突与扩容机制"></a>哈希冲突与扩容机制</h3><p>什么是哈希冲突？</p><ul><li><p>两个不同的键，计算出相同的哈希值（或索引），就会发生冲突。</p></li><li><p>Python采用<strong>开放寻址法</strong>解决冲突：如果位置被占，就找下一个空位。这可能会降低操作效率。为了保证高效性，哈希表始终保持至少1&#x2F;3的剩余空间，当空间不足时自动扩容。</p></li></ul><p> 如何实现扩容机制</p><ul><li><p>当哈希表使用率 &gt; 2&#x2F;3 时，触发扩容。</p></li><li><p>扩容为原来的 2~4 倍，并重新哈希所有元素。</p></li></ul><blockquote><p> 这也是为什么 <code>dict</code> 插入操作虽然是 O(1)，但偶尔会“卡一下”——那是它在扩容。</p></blockquote><h3 id="应用实践与技巧"><a href="#应用实践与技巧" class="headerlink" title="应用实践与技巧"></a>应用实践与技巧</h3><ul><li>dict的用法实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 字典推导式</span></span><br><span class="line">squares = &#123;x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)&#125;</span><br><span class="line"><span class="comment"># &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合并字典</span></span><br><span class="line">dict1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&quot;b&quot;</span>: <span class="number">3</span>, <span class="string">&quot;c&quot;</span>: <span class="number">4</span>&#125;</span><br><span class="line">merged = &#123;**dict1, **dict2&#125;  <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 3, &#x27;c&#x27;: 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置默认值</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">word_count = defaultdict(<span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    word_count[word] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 4. 字典排序示例</span></span><br><span class="line">d = &#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 按key排序</span></span><br><span class="line">d_sorted_by_key = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># [(&#x27;a&#x27;, 2), (&#x27;b&#x27;, 1), (&#x27;c&#x27;, 10)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 按value排序</span></span><br><span class="line">d_sorted_by_value = <span class="built_in">sorted</span>(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># [(&#x27;b&#x27;, 1), (&#x27;a&#x27;, 2), (&#x27;c&#x27;, 10)]</span></span><br></pre></td></tr></table></figure><ul><li>dict的场景实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 配置管理</span></span><br><span class="line">app_config = &#123;</span><br><span class="line">    <span class="string">&quot;debug&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">    <span class="string">&quot;database&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">5432</span>,</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;myapp&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;api_keys&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;google&quot;</span>: <span class="string">&quot;abc123&quot;</span>,</span><br><span class="line">        <span class="string">&quot;aws&quot;</span>: <span class="string">&quot;def456&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据聚合</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_words</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统计词频&quot;&quot;&quot;</span></span><br><span class="line">    word_count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split():</span><br><span class="line">        word_count[word] = word_count.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> word_count</span><br></pre></td></tr></table></figure><ul><li>set的用法实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 集合运算</span></span><br><span class="line">A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">B = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A | B)  <span class="comment"># 并集: &#123;1, 2, 3, 4, 5, 6&#125;</span></span><br><span class="line"><span class="built_in">print</span>(A &amp; B)  <span class="comment"># 交集: &#123;3, 4&#125;</span></span><br><span class="line"><span class="built_in">print</span>(A - B)  <span class="comment"># 差集: &#123;1, 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 快速去重</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">unique = <span class="built_in">list</span>(<span class="built_in">set</span>(numbers))  <span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li>set 的场景实践</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 权限管理</span></span><br><span class="line">user_roles = &#123;<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;editor&quot;</span>, <span class="string">&quot;viewer&quot;</span>&#125;</span><br><span class="line">current_user_roles = &#123;<span class="string">&quot;editor&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line"><span class="keyword">if</span> current_user_roles &amp; user_roles:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有访问权限&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据清洗</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_duplicates</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;快速去重并保持顺序&quot;&quot;&quot;</span></span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> data <span class="keyword">if</span> <span class="keyword">not</span> (x <span class="keyword">in</span> seen <span class="keyword">or</span> seen.add(x))]</span><br></pre></td></tr></table></figure><h3 id="常用操作汇总-1"><a href="#常用操作汇总-1" class="headerlink" title="常用操作汇总"></a>常用操作汇总</h3><p><strong>dict 操作：</strong></p><ul><li><code>keys()</code>：返回所有键</li><li><code>values()</code>：返回所有值</li><li><code>items()</code>：返回所有键值对</li><li><code>del</code>：删除键值对</li><li><code>clear()</code>：清空字典</li><li>遍历：<code>for key in dict</code>或<code>for key, value in dict.items()</code></li></ul><p><strong>set 操作：</strong></p><ul><li><code>add()</code>：添加元素</li><li><code>update()</code>：添加多个元素（传入序列）</li><li><code>remove()</code>：删除指定元素（不存在则报错）</li><li><code>discard()</code>：删除指定元素（不存在不报错）</li><li><code>pop()</code>：随机删除并返回一个元素（因集合无序需谨慎使用）</li></ul><h2 id="如何选择合适的数据类型？"><a href="#如何选择合适的数据类型？" class="headerlink" title="如何选择合适的数据类型？"></a>如何选择合适的数据类型？</h2><h3 id="场景1：频繁查找"><a href="#场景1：频繁查找" class="headerlink" title="场景1：频繁查找"></a>场景1：频繁查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误做法：使用列表查找</span></span><br><span class="line">names_list = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>] * <span class="number">1000</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;David&quot;</span> <span class="keyword">in</span> names_list:  <span class="comment"># O(n)时间复杂度</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确做法：使用集合查找  </span></span><br><span class="line">names_set = <span class="built_in">set</span>(names_list)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;David&quot;</span> <span class="keyword">in</span> names_set:  <span class="comment"># O(1)时间复杂度</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="场景2：数据记录"><a href="#场景2：数据记录" class="headerlink" title="场景2：数据记录"></a>场景2：数据记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要修改数据：用列表</span></span><br><span class="line">student_scores = [<span class="number">85</span>, <span class="number">92</span>, <span class="number">78</span>]  <span class="comment"># 可能变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不需要修改数据：用元组</span></span><br><span class="line">student_info = (<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;2021001&quot;</span>, <span class="string">&quot;计算机系&quot;</span>)  <span class="comment"># 固定信息</span></span><br></pre></td></tr></table></figure><h3 id="场景3：内存使用优化"><a href="#场景3：内存使用优化" class="headerlink" title="场景3：内存使用优化"></a>场景3：内存使用优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用__sizeof__()分析内存占用</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">data_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">data_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;列表占用: <span class="subst">&#123;sys.getsizeof(data_list)&#125;</span> bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;元组占用: <span class="subst">&#123;sys.getsizeof(data_tuple)&#125;</span> bytes&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><table><thead><tr><th align="left">场景</th><th align="left">推荐数据结构</th><th align="left">原因</th></tr></thead><tbody><tr><td align="left">动态数据集合</td><td align="left">列表(list)</td><td align="left">支持频繁增删改</td></tr><tr><td align="left">固定数据集合</td><td align="left">元组(tuple)</td><td align="left">更快的创建和访问速度</td></tr><tr><td align="left">键值映射</td><td align="left">字典(dict)</td><td align="left">快速的键值查找</td></tr><tr><td align="left">唯一值集合</td><td align="left">集合(set)</td><td align="left">快速成员检测和去重</td></tr><tr><td align="left">配置信息</td><td align="left">元组&#x2F;字典</td><td align="left">根据是否需要修改选择</td></tr><tr><td align="left">数据缓存</td><td align="left">字典</td><td align="left">快速的键值访问</td></tr></tbody></table><p><strong>记住这几个原则：</strong></p><ol><li><strong>需要修改</strong> → 选择列表</li><li><strong>不需要修改</strong> → 选择元组</li><li><strong>需要快速查找</strong> → 选择字典或集合</li><li><strong>需要去重</strong> → 选择集合</li><li><strong>需要保持顺序</strong> → 选择列表或元组</li></ol><p>理解了这些数据结构的底层原理和特性，能够帮助我们在实际开发中做出更合理的选择，编写出更高效、更优雅的Python代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Python的世界里，我们每天都在和 &lt;code&gt;list&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt; 打交道。但你有没有想过：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么元组比列表快？&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python工程实践" scheme="http://sswfive.xyz/tags/python%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="Python核心知识" scheme="http://sswfive.xyz/tags/Python%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【链表】</title>
    <link href="http://sswfive.xyz/2025/09/12/dsa/250912-linkedlist/"/>
    <id>http://sswfive.xyz/2025/09/12/dsa/250912-linkedlist/</id>
    <published>2025-09-12T12:50:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题向导："><a href="#问题向导：" class="headerlink" title="问题向导："></a>问题向导：</h2><ul><li>问题1：如何实现LRU缓存淘汰算法？</li><li>思路：<ul><li>维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的，当有一个新的数据被访问时，从链表头开始顺序遍历链表。</li></ul></li><li>实现：</li></ul><ol><li>如果在此数据之前已经被缓存在链表中了，遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果此数据没有在缓存链表中，可以分两种情况考虑：<ol><li>如果此时缓存未满，则将该结点直接插入到链表的头部。</li><li>如果此时缓存已满，则删除链表的尾结点，将新的数据结点插入到链表的头部。</li></ol></li></ol><ul><li>优化实现：<ul><li>引入散列表（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到O(1).</li></ul></li><li>其他实现：<ul><li>使用数组实现LRU缓存淘汰策略<blockquote><p>扩展1：</p><ul><li>缓存利用的是空间换时间的设计思想<ul><li>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化。</li><li>对于消耗过多内存的程序，可以通过消耗更多时间（时间换空间）来降低内存的消耗。<br>扩展2：</li></ul></li><li>常见缓存淘汰策略<ul><li>FIFO(First In, First Out):先进先出策略</li><li>LFU(Least Frequently Used): 最少使用策略</li><li>LRU(Least Recently Used): 最少使用策略</li></ul></li></ul></blockquote></li></ul></li></ul><hr><h2 id="链表概述："><a href="#链表概述：" class="headerlink" title="链表概述："></a>链表概述：</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>链表是通过指针将一组零散的内存快串联在一起的一种数据结构。<ul><li>内存块通常被称为链表的结点，每个链表的结点除了存储数据之外，还需要记录下一个节点的地址的指针（通常称为后继指针next）</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比:"></a>对比:</h3><ul><li>数组：需要一块连续的内存空间来存储，对内存要求比较高</li><li>链表：不需要一块连续的内存空间，它通过指针将一组零散的内存块串联使用。</li></ul><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>支持数据的查找、插入、删除操作</li><li>相对与数组，链表更适合插入和删除操作、查找的效率则没有数组高。</li><li>插入删除<ul><li>数组O(n)</li><li>链表O(1)</li></ul></li><li>随机访问<ul><li>数组O(1)</li><li>链表O(n)</li></ul></li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><p><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.jgzcedshfdc.webp" alt="image"></p><ul><li>单链表</li><li>循环链表</li><li>双向链表</li><li>双向循环链表</li></ul><h2 id="链表详解："><a href="#链表详解：" class="headerlink" title="链表详解："></a>链表详解：</h2><h3 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h3><ul><li>特点：<ul><li>只有一个方向</li><li>结点只有一个后继指针next指向后的结点</li><li>头结点记录链表的基地址</li><li>尾结点指针指向一个空地址NULL</li></ul></li><li>常用操作的时间复杂度：<ul><li>查找:  O(n)</li><li>插入 : O(1)</li><li>删除:  O(1)</li></ul></li></ul><h3 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h3><ul><li>特点：<ul><li>是一种特殊的单链表</li><li>和单链表唯一的区别在我尾结点，尾结点指针指向连链表的头结点</li><li>和单链表相比，优点是从链尾到链头比较方便，当要处理的数据具有环形结构特点时，就适合采用循环链表（单链表实现相对比较繁琐）。比如：约<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">瑟夫问题。</a></li></ul></li></ul><h3 id="双向链表："><a href="#双向链表：" class="headerlink" title="双向链表："></a>双向链表：</h3><ul><li>特点<ul><li>支持两个方向</li><li>每个结点不止有一个后继指针next指向后面的结点，还有前驱指针pre指向前面的结点</li><li>相较于单链表，会占用更多的内存。</li><li>支持双向遍历，这样也带来了 双向链表操作的灵活性。提高的数据插入和删除的效率。</li></ul></li><li>操作<ul><li>删除的情况分析：<ol><li>删除结点中“值等于某个给定值”的结点；<ul><li>需要从链表头部依次遍历，知道找到值等于给定值的结点，O(n)，然后执行删除操作O(1)，所以时间复杂度为O(n)</li></ul></li><li>删除给定指针指向的结点；<ul><li>此情况需要知道该结点的前驱结点，而单链表不支持获取前驱结点，故需要从头开始遍历O(n)，直到到 p-&gt;next&#x3D;q，说明 p 是 q 的前驱结点。与之对比，使用双向链表操作比较高效，时间复杂度为O(1)。</li></ul></li></ol></li></ul></li></ul><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><ul><li>整合了循环链表和双向链表的特点形成了一种链表</li><li>首节点的前驱指针指向尾结点，尾结点的后驱指针指向首节点。</li></ul><hr><h2 id="链表代码编写技巧指南"><a href="#链表代码编写技巧指南" class="headerlink" title="链表代码编写技巧指南"></a>链表代码编写技巧指南</h2><h3 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h3><ul><li>指针的理解：<ul><li>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li></ul></li><li>eg:<ul><li>p-&gt;next&#x3D;q。这行代码是说，p结点中的next指针存储了q结点的内存地址。</li><li>p-&gt;next&#x3D;p-&gt;next-&gt;next。这行代码表示，p结点的next指针存储了p结点的下下一个结点的内存地址。</li></ul></li></ul><h3 id="技巧二：警惕指针丢失和内存泄露"><a href="#技巧二：警惕指针丢失和内存泄露" class="headerlink" title="技巧二：警惕指针丢失和内存泄露"></a>技巧二：警惕指针丢失和内存泄露</h3><ul><li>eg: 单链表的插入操作</li><li><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.3j2r3fc4yfw0.webp" alt="image"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x; // 将 p 的 next 指针指向 x 结点；</span><br><span class="line">x-&gt;next = p-&gt;next; // 将 x 的结点的 next 指针指向 b 结点；</span><br></pre></td></tr></table></figure><ul><li>分析：<ul><li>p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而 是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就 断成了两半，从结点 b 往后的所有结点都无法访问到了</li></ul></li><li>正确做法：<ul><li>先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</li></ul></li><li>总结：<ul><li>插入结点时，一定要注意操作的顺序。</li><li>删除链表结点时，也一定要记得手动释放内存空间。</li></ul></li></ul><h3 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h3><blockquote><p>哨兵：解决的是国家之间的边界问题，同理，在数据结构所说的哨兵也是解决“边界问题”的，不直接参与业务逻辑。</p></blockquote><p>eg1: 向空链表中插入第一个结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (head == null) &#123;</span><br><span class="line">head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg2:单链表结点删除操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 删除结点 p 的后继结点</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line"># 删除链表中的最后一个结点</span><br><span class="line">if (head-&gt;next == null) &#123;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>普通实现的方法总结：<ul><li>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</li></ul></li></ul><p>哨兵方式实现：</p><p><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.e3p38wfw9ds.webp" alt="image"></p><ul><li>引入哨兵结点，在任何时候，不管链表是否为空，head指针都会一直指向这个哨兵结点，也称这个哨兵结点的链表交带头链表。</li><li>哨兵结点是不存储数据的</li><li>插入排序、归并排序、动态规划都使用了哨兵的方式实现。</li></ul><h3 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h3><p>检查链表代码是否正确的边界条件有如下几个：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码能否正常工作？</li><li>如果链表只包含两个结点时，代码能否正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><h3 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h3><p>举例法和画图法：</p><ul><li>可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感 觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一 个例子，画出插入前和插入后的链表变化，如图所示：</li><li><img src="https://cdn.staticaly.com/gh/sswfive/blog-pic@main/20230331/image.4q4rtsz93d60.webp" alt="image"></li></ul><h3 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h3><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题向导：&quot;&gt;&lt;a href=&quot;#问题向导：&quot; class=&quot;headerlink&quot; title=&quot;问题向导：&quot;&gt;&lt;/a&gt;问题向导：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题1：如何实现LRU缓存淘汰算法？&lt;/li&gt;
&lt;li&gt;思路：&lt;ul&gt;
&lt;li&gt;维护一个有序的单链表，越</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>用了pathlib后，我再也不想碰os.path了！</title>
    <link href="http://sswfive.xyz/2025/09/11/tech/python/250308-pylib-pathlib/"/>
    <id>http://sswfive.xyz/2025/09/11/tech/python/250308-pylib-pathlib/</id>
    <published>2025-09-11T02:17:00.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在日常Python开发中，文件路径操作是绕不开的话题。你是否还在使用<code>os.path.join()</code>拼接路径？是否还在为Windows和Linux的路径分隔符头疼？是否期待一种更Pythonic的方式来处理路径？</p><p>先来看一个直观的对比，即使你现在还不熟悉pathlib，也能一眼看出来区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传统方式：繁琐且易出错</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">base_path = os.path.dirname(os.path.dirname(os.getcwd()))</span><br><span class="line">file_path = os.path.join(base_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;users&#x27;</span>, <span class="string">&#x27;profile.json&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># pathlib方式：简洁优雅</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">file_path = Path.cwd().parent.parent / <span class="string">&#x27;data&#x27;</span> / <span class="string">&#x27;users&#x27;</span> / <span class="string">&#x27;profile.json&#x27;</span></span><br><span class="line"><span class="keyword">if</span> file_path.exists():</span><br><span class="line">    content = file_path.read_text()</span><br></pre></td></tr></table></figure><p>看出差异了吗？今天要介绍的，正是这个让文件路径操作变得优雅如诗的Python标准库——<strong>pathlib</strong>。</p><h2 id="pathlib是什么？"><a href="#pathlib是什么？" class="headerlink" title="pathlib是什么？"></a>pathlib是什么？</h2><p>pathlib是Python 3.4中新增的标准库模块，提供了面向对象的文件系统路径操作方式。官网地址：<a href="https://docs.python.org/3/library/pathlib.html">点击前往</a></p><p>它的核心优势包括：</p><ul><li><strong>面向对象API</strong>：路径不再是字符串，而是Path对象，方法可以链式调用 </li><li><strong>跨平台统一</strong>：无缝兼容Windows和Unix系统，自动处理不同操作系统的路径差异</li><li><strong>直观易懂</strong>：代码即文档，一看就懂 </li><li><strong>功能强大</strong>：覆盖了绝大部分文件路径操作需求，包括文件操作、路径查询、模式匹配等功能</li></ul><p>日常开发中，我们最常用的是<strong>Path</strong>类，它可以完全替代os.path的功能。</p><h2 id="为什么需要pathlib？"><a href="#为什么需要pathlib？" class="headerlink" title="为什么需要pathlib？"></a>为什么需要pathlib？</h2><blockquote><p><strong>传统os.path的三大痛点</strong></p></blockquote><p><strong>1. 函数式编程，缺乏连贯性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># os.path: 需要不断传递路径字符串</span></span><br><span class="line">path = <span class="string">&#x27;/Users/astonwang/projects&#x27;</span></span><br><span class="line">parent = os.path.dirname(path)</span><br><span class="line">grandparent = os.path.dirname(parent)</span><br></pre></td></tr></table></figure><p><strong>2. 跨平台兼容性问题</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Windows: C:\Users\Name\Documents</span></span><br><span class="line"><span class="comment"># Linux: /home/name/documents</span></span><br><span class="line"><span class="comment"># 需要手动处理路径分隔符差异</span></span><br></pre></td></tr></table></figure><p><strong>3. 代码可读性差</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这行代码在做什么？一眼看不出来</span></span><br><span class="line">full_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;config.json&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="pathlib的核心设计"><a href="#pathlib的核心设计" class="headerlink" title="pathlib的核心设计"></a>pathlib的核心设计</h2><p>pathlib提供了丰富的类来处理不同场景下的路径操作：</p><h3 id="两大分支：纯路径-vs-具体路径"><a href="#两大分支：纯路径-vs-具体路径" class="headerlink" title="两大分支：纯路径 vs 具体路径"></a>两大分支：纯路径 vs 具体路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 纯路径：只做路径运算，不访问文件系统</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> PurePath, PurePosixPath, PureWindowsPath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体路径：可以访问文件系统，进行I/O操作  </span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PosixPath, WindowsPath</span><br></pre></td></tr></table></figure><p><strong>纯路径家族</strong>（Pure Path）- 理论派</p><ul><li>只负责路径的逻辑运算</li><li>不会访问真实的文件系统</li><li>适合路径字符串的处理和转换</li></ul><p><strong>具体路径家族</strong>（Concrete Path）- 实践派</p><ul><li>可以创建、读取、写入文件</li><li>能够检查文件是否存在</li><li>支持所有文件系统操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 纯路径操作（无I/O）</span></span><br><span class="line">PurePath</span><br><span class="line">├── PurePosixPath  <span class="comment"># Unix风格</span></span><br><span class="line">└── PureWindowsPath <span class="comment"># Windows风格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 具体路径操作（带I/O）</span></span><br><span class="line">Path</span><br><span class="line">├── PosixPath      <span class="comment"># Unix系统</span></span><br><span class="line">└── WindowsPath    <span class="comment"># Windows系统</span></span><br></pre></td></tr></table></figure><h3 id="日常开发首选：Path类"><a href="#日常开发首选：Path类" class="headerlink" title="日常开发首选：Path类"></a>日常开发首选：Path类</h3><p>在99%的场景中，你只需要使用<strong>Path类</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path会自动选择合适的子类</span></span><br><span class="line"><span class="comment"># 在Linux/Mac上 -&gt; PosixPath  </span></span><br><span class="line"><span class="comment"># 在Windows上 -&gt; WindowsPath</span></span><br><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(current_dir))  <span class="comment"># 自动适配当前系统</span></span><br></pre></td></tr></table></figure><p><strong>记住这个原则</strong>：除非有特殊需求，否则直接用<code>Path</code>就够了！</p><h2 id="pathlib-VS-os-path-的API对比"><a href="#pathlib-VS-os-path-的API对比" class="headerlink" title="pathlib VS os.path 的API对比"></a>pathlib VS os.path 的API对比</h2><p>想知道pathlib到底比os.path强在哪里？来看看这个对比表：</p><table><thead><tr><th>功能</th><th>pathlib优雅写法</th><th>os.path传统写法</th></tr></thead><tbody><tr><td><strong>获取当前目录</strong></td><td><code>Path.cwd()</code></td><td><code>os.getcwd()</code></td></tr><tr><td><strong>获取主目录</strong></td><td><code>Path.home()</code></td><td><code>os.path.expanduser(&#39;~&#39;)</code></td></tr><tr><td><strong>路径拼接</strong></td><td><code>Path(&#39;a&#39;) / &#39;b&#39; / &#39;c&#39;</code></td><td><code>os.path.join(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></td></tr><tr><td><strong>获取绝对路径</strong></td><td><code>path.absolute()</code></td><td><code>os.path.abspath(path)</code></td></tr><tr><td><strong>获取父目录</strong></td><td><code>path.parent</code></td><td><code>os.path.dirname(path)</code></td></tr><tr><td><strong>获取文件名</strong></td><td><code>path.name</code></td><td><code>os.path.basename(path)</code></td></tr><tr><td><strong>判断是否存在</strong></td><td><code>path.exists()</code></td><td><code>os.path.exists(path)</code></td></tr><tr><td><strong>判断是否文件</strong></td><td><code>path.is_file()</code></td><td><code>os.path.isfile(path)</code></td></tr><tr><td><strong>创建目录</strong></td><td><code>path.mkdir(parents=True)</code></td><td><code>os.makedirs(path)</code></td></tr><tr><td><strong>读取文件</strong></td><td><code>path.read_text()</code></td><td><code>open(path).read()</code></td></tr><tr><td><strong>写入文件</strong></td><td><code>path.write_text(data)</code></td><td><code>open(path, &#39;w&#39;).write(data)</code></td></tr></tbody></table><p><strong>一句话总结</strong>：pathlib让你的代码从”写给计算机看”变成”写给人类看”！</p><h2 id="Pathlib基础实践指南—Path类"><a href="#Pathlib基础实践指南—Path类" class="headerlink" title="Pathlib基础实践指南—Path类"></a>Pathlib基础实践指南—Path类</h2><p>pathlib的强大之处在于它丰富的方法库，让我们按使用场景来分类介绍：</p><h3 id="路径探索操作"><a href="#路径探索操作" class="headerlink" title="路径探索操作"></a>路径探索操作</h3><h4 id="获取特殊目录"><a href="#获取特殊目录" class="headerlink" title="获取特殊目录"></a>获取特殊目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前工作目录 - 相当于 os.getcwd()</span></span><br><span class="line">current_dir = Path.cwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前目录: <span class="subst">&#123;current_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户主目录 - 相当于 os.path.expanduser(&#x27;~&#x27;)  </span></span><br><span class="line">home_dir = Path.home()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;主目录: <span class="subst">&#123;home_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路径是否存在 - 相当于 os.path.exists()</span></span><br><span class="line">config_file = Path(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> config_file.exists():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;配置文件存在&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p>pathlib的<code>glob</code>功能堪比终端的find命令，让文件搜索变得简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录所有Python文件</span></span><br><span class="line">python_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).glob(<span class="string">&quot;*.py&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;找到 <span class="subst">&#123;<span class="built_in">len</span>(python_files)&#125;</span> 个Python文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归搜索所有Python文件 - 相当于 find . -name &quot;*.py&quot;</span></span><br><span class="line">all_python_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;*.py&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找特定模式的文件</span></span><br><span class="line">test_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;test_*.py&quot;</span>))</span><br><span class="line">config_files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).rglob(<span class="string">&quot;**/config/*.json&quot;</span>))</span><br></pre></td></tr></table></figure><h4 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出目录内容 - 相当于 os.listdir()</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).iterdir():</span><br><span class="line">    <span class="keyword">if</span> item.is_file():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;文件: <span class="subst">&#123;item.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> item.is_dir():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;目录: <span class="subst">&#123;item.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归遍历目录树 - 相当于 os.walk()</span></span><br><span class="line"><span class="keyword">for</span> dirpath, dirnames, filenames <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).walk():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前目录: <span class="subst">&#123;dirpath&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;子目录: <span class="subst">&#123;dirnames&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件: <span class="subst">&#123;filenames[:<span class="number">3</span>]&#125;</span>...&quot;</span>)  <span class="comment"># 只显示前3个文件</span></span><br></pre></td></tr></table></figure><h4 id="路径转换"><a href="#路径转换" class="headerlink" title="路径转换"></a>路径转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取绝对路径 - 相当于 os.path.abspath()</span></span><br><span class="line">relative_path = Path(<span class="string">&quot;../data/file.txt&quot;</span>)</span><br><span class="line">absolute_path = relative_path.absolute()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析软链接 - 相当于 os.path.realpath()</span></span><br><span class="line">resolved_path = relative_path.resolve()</span><br></pre></td></tr></table></figure><h3 id="路径类型判断"><a href="#路径类型判断" class="headerlink" title="路径类型判断"></a>路径类型判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断路径类型 - 比 os.path.isfile/isdir 更直观</span></span><br><span class="line">data_path = Path(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">config_dir = Path(<span class="string">&quot;config/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础判断</span></span><br><span class="line"><span class="keyword">if</span> data_path.is_file():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个文件&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> config_dir.is_dir():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一个目录&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个路径是否指向同一个文件 - 相当于 os.path.samefile()</span></span><br><span class="line"><span class="keyword">if</span> Path(<span class="string">&quot;file1.txt&quot;</span>).samefile(Path(<span class="string">&quot;file2.txt&quot;</span>)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;两个路径指向同一个文件&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h3><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建目录 - 比 os.makedirs 更简洁</span></span><br><span class="line">new_dir = Path(<span class="string">&quot;project/src/utils&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归创建目录（相当于 mkdir -p）</span></span><br><span class="line">new_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空目录 - 相当于 os.rmdir()</span></span><br><span class="line">empty_dir = Path(<span class="string">&quot;temp&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> empty_dir.exists() <span class="keyword">and</span> empty_dir.is_dir():</span><br><span class="line">    empty_dir.rmdir()</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>pathlib最让人惊喜的地方就是内置的文件读写方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空文件（相当于 touch 命令）</span></span><br><span class="line">log_file = Path(<span class="string">&quot;app.log&quot;</span>)</span><br><span class="line">log_file.touch(exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码读取文件 - 告别繁琐的open/close</span></span><br><span class="line">config_text = Path(<span class="string">&quot;config.txt&quot;</span>).read_text(encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">binary_data = Path(<span class="string">&quot;image.png&quot;</span>).read_bytes()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一行代码写入文件</span></span><br><span class="line">Path(<span class="string">&quot;output.txt&quot;</span>).write_text(<span class="string">&quot;Hello, pathlib!&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">Path(<span class="string">&quot;data.bin&quot;</span>).write_bytes(<span class="string">b&quot;binary data&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件重命名 - 相当于 os.rename()</span></span><br><span class="line">old_file = Path(<span class="string">&quot;old_name.txt&quot;</span>)</span><br><span class="line">new_file = old_file.rename(<span class="string">&quot;new_name.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="文件信息查询"><a href="#文件信息查询" class="headerlink" title="文件信息查询"></a>文件信息查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取文件详细信息 - 相当于 os.stat()</span></span><br><span class="line">file_path = Path(<span class="string">&quot;document.pdf&quot;</span>)</span><br><span class="line">stat_info = file_path.stat()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;文件大小: <span class="subst">&#123;stat_info.st_size&#125;</span> 字节&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;修改时间: <span class="subst">&#123;stat_info.st_mtime&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;创建时间: <span class="subst">&#123;stat_info.st_ctime&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件权限 - 相当于 chmod</span></span><br><span class="line">script_file = Path(<span class="string">&quot;deploy.sh&quot;</span>)</span><br><span class="line">script_file.chmod(<span class="number">0o755</span>)  <span class="comment"># 给脚本添加执行权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件所有者信息（Unix/Linux系统）</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    owner = script_file.owner()</span><br><span class="line">    group = script_file.group()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有者: <span class="subst">&#123;owner&#125;</span>, 组: <span class="subst">&#123;group&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法获取所有者信息&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="pathlib工程实践技巧"><a href="#pathlib工程实践技巧" class="headerlink" title="pathlib工程实践技巧"></a>pathlib工程实践技巧</h2><h3 id="实践技巧一：链式调用的艺术"><a href="#实践技巧一：链式调用的艺术" class="headerlink" title="实践技巧一：链式调用的艺术"></a>实践技巧一：链式调用的艺术</h3><p>pathlib最大的魅力在于可以进行优雅的链式调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行代码完成复杂操作</span></span><br><span class="line">result = (Path.cwd()</span><br><span class="line">          .parent                    <span class="comment"># 获取父目录</span></span><br><span class="line">          .parent                    <span class="comment"># 再获取父目录</span></span><br><span class="line">          / <span class="string">&quot;data&quot;</span>                   <span class="comment"># 进入data文件夹</span></span><br><span class="line">          / <span class="string">&quot;config.json&quot;</span>)           <span class="comment"># 指向配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式判断和操作</span></span><br><span class="line"><span class="keyword">if</span> (Path.home() / <span class="string">&quot;.ssh&quot;</span> / <span class="string">&quot;id_rsa&quot;</span>).exists():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;SSH密钥存在&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式文件处理</span></span><br><span class="line">(Path(<span class="string">&quot;temp&quot;</span>) </span><br><span class="line"> .mkdir(exist_ok=<span class="literal">True</span>)             <span class="comment"># 创建临时目录</span></span><br><span class="line"> .joinpath(<span class="string">&quot;output.txt&quot;</span>)           <span class="comment"># 创建文件路径</span></span><br><span class="line"> .write_text(<span class="string">&quot;Hello, World!&quot;</span>))     <span class="comment"># 写入内容</span></span><br></pre></td></tr></table></figure><h3 id="实践技巧二：优雅的错误处理"><a href="#实践技巧二：优雅的错误处理" class="headerlink" title="实践技巧二：优雅的错误处理"></a>实践技巧二：优雅的错误处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">safe_read_config</span>(<span class="params">config_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;安全读取配置文件&quot;&quot;&quot;</span></span><br><span class="line">    path = Path(config_path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path.exists():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;配置文件不存在: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查是否为文件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> path.is_file():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;路径不是文件: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安全读取</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content = path.read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> json.loads(content)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;读取配置失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="实践建议一：使用-Path-替代字符串拼接"><a href="#实践建议一：使用-Path-替代字符串拼接" class="headerlink" title="实践建议一：使用 Path 替代字符串拼接"></a>实践建议一：使用 Path 替代字符串拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不推荐：字符串拼接</span></span><br><span class="line">config_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&quot;.config&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;settings.json&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐：pathlib方式</span></span><br><span class="line">config_path = Path.home() / <span class="string">&quot;.config&quot;</span> / <span class="string">&quot;app&quot;</span> / <span class="string">&quot;settings.json&quot;</span></span><br></pre></td></tr></table></figure><h3 id="实践建议二：利用-操作符进行路径拼接"><a href="#实践建议二：利用-操作符进行路径拼接" class="headerlink" title="实践建议二：利用 &#x2F; 操作符进行路径拼接"></a>实践建议二：利用 &#x2F; 操作符进行路径拼接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：使用 / 操作符，简洁直观</span></span><br><span class="line">project_root = Path(__file__).parent.parent</span><br><span class="line">data_dir = project_root / <span class="string">&quot;data&quot;</span></span><br><span class="line">output_file = data_dir / <span class="string">&quot;results&quot;</span> / <span class="string">f&quot;output_<span class="subst">&#123;datetime.now().strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)&#125;</span>.csv&quot;</span></span><br></pre></td></tr></table></figure><h3 id="实践建议三：使用上下文管理器"><a href="#实践建议三：使用上下文管理器" class="headerlink" title="实践建议三：使用上下文管理器"></a>实践建议三：使用上下文管理器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：安全的文件操作</span></span><br><span class="line"><span class="keyword">with</span> Path(<span class="string">&quot;data.txt&quot;</span>).<span class="built_in">open</span>(<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;重要数据&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更简洁的方式</span></span><br><span class="line">Path(<span class="string">&quot;data.txt&quot;</span>).write_text(<span class="string">&quot;重要数据&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-充分利用内置方法"><a href="#4-充分利用内置方法" class="headerlink" title="4. 充分利用内置方法"></a>4. 充分利用内置方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐：使用pathlib内置方法</span></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> Path(<span class="string">&quot;.&quot;</span>).iterdir() <span class="keyword">if</span> f.suffix == <span class="string">&quot;.py&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更推荐：使用glob</span></span><br><span class="line">files = <span class="built_in">list</span>(Path(<span class="string">&quot;.&quot;</span>).glob(<span class="string">&quot;*.py&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="pathlib的实践应用场景"><a href="#pathlib的实践应用场景" class="headerlink" title="pathlib的实践应用场景"></a>pathlib的实践应用场景</h2><p>让我们通过几个真实场景，看看pathlib如何让复杂的文件操作变得简单。</p><h3 id="场景一：项目结构分析器"><a href="#场景一：项目结构分析器" class="headerlink" title="场景一：项目结构分析器"></a>场景一：项目结构分析器</h3><p>假设你要分析一个Python项目的结构，统计代码行数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_project</span>(<span class="params">project_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;分析Python项目结构&quot;&quot;&quot;</span></span><br><span class="line">    project = Path(project_path)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计不同类型的文件</span></span><br><span class="line">    py_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.py&quot;</span>))  <span class="comment"># 所有Python文件</span></span><br><span class="line">    test_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;test_*.py&quot;</span>))  <span class="comment"># 测试文件</span></span><br><span class="line">    config_files = <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.json&quot;</span>)) + <span class="built_in">list</span>(project.rglob(<span class="string">&quot;*.yaml&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算总代码行数</span></span><br><span class="line">    total_lines = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> py_file <span class="keyword">in</span> py_files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            lines = <span class="built_in">len</span>(py_file.read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>).splitlines())</span><br><span class="line">            total_lines += lines</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;项目分析报告 - <span class="subst">&#123;project.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Python文件: <span class="subst">&#123;<span class="built_in">len</span>(py_files)&#125;</span> 个&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;测试文件: <span class="subst">&#123;<span class="built_in">len</span>(test_files)&#125;</span> 个&quot;</span>) </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;配置文件: <span class="subst">&#123;<span class="built_in">len</span>(config_files)&#125;</span> 个&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总代码行数: <span class="subst">&#123;total_lines:,&#125;</span> 行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">analyze_project(<span class="string">&quot;/path/to/your/project&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景二：智能文件整理器"><a href="#场景二：智能文件整理器" class="headerlink" title="场景二：智能文件整理器"></a>场景二：智能文件整理器</h3><p>整理下载文件夹，按文件类型自动分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">organize_downloads</span>(<span class="params">downloads_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;智能整理下载文件夹&quot;&quot;&quot;</span></span><br><span class="line">    downloads = Path(downloads_dir)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义文件类型映射</span></span><br><span class="line">    type_mapping = &#123;</span><br><span class="line">        <span class="string">&#x27;images&#x27;</span>: [<span class="string">&#x27;.jpg&#x27;</span>, <span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;.gif&#x27;</span>, <span class="string">&#x27;.jpeg&#x27;</span>, <span class="string">&#x27;.svg&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;documents&#x27;</span>: [<span class="string">&#x27;.pdf&#x27;</span>, <span class="string">&#x27;.doc&#x27;</span>, <span class="string">&#x27;.docx&#x27;</span>, <span class="string">&#x27;.txt&#x27;</span>, <span class="string">&#x27;.md&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;videos&#x27;</span>: [<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>, <span class="string">&#x27;.mkv&#x27;</span>, <span class="string">&#x27;.mov&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;music&#x27;</span>: [<span class="string">&#x27;.mp3&#x27;</span>, <span class="string">&#x27;.wav&#x27;</span>, <span class="string">&#x27;.flac&#x27;</span>, <span class="string">&#x27;.m4a&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;archives&#x27;</span>: [<span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;.rar&#x27;</span>, <span class="string">&#x27;.7z&#x27;</span>, <span class="string">&#x27;.tar.gz&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建分类文件夹</span></span><br><span class="line">    <span class="keyword">for</span> folder_name <span class="keyword">in</span> type_mapping.keys():</span><br><span class="line">        (downloads / folder_name).mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始整理文件</span></span><br><span class="line">    moved_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> downloads.iterdir():</span><br><span class="line">        <span class="keyword">if</span> file_path.is_file():</span><br><span class="line">            file_ext = file_path.suffix.lower()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 找到对应的分类</span></span><br><span class="line">            <span class="keyword">for</span> folder_name, extensions <span class="keyword">in</span> type_mapping.items():</span><br><span class="line">                <span class="keyword">if</span> file_ext <span class="keyword">in</span> extensions:</span><br><span class="line">                    new_path = downloads / folder_name / file_path.name</span><br><span class="line">                    file_path.rename(new_path)</span><br><span class="line">                    moved_count += <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot; <span class="subst">&#123;file_path.name&#125;</span> → <span class="subst">&#123;folder_name&#125;</span>/&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;整理完成！共移动了 <span class="subst">&#123;moved_count&#125;</span> 个文件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例  </span></span><br><span class="line">organize_downloads(Path.home() / <span class="string">&quot;Downloads&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景三：路径解析"><a href="#场景三：路径解析" class="headerlink" title="场景三：路径解析"></a>场景三：路径解析</h3><p>解析文件路径的各个组成部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_file_path</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;详细分析文件路径组成&quot;&quot;&quot;</span></span><br><span class="line">    path = Path(file_path)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;路径分析：<span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所在目录: <span class="subst">&#123;path.parent&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;完整文件名: <span class="subst">&#123;path.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;主文件名: <span class="subst">&#123;path.stem&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;文件扩展名: <span class="subst">&#123;path.suffix&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;是否绝对路径: <span class="subst">&#123;path.is_absolute()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 显示目录层级</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;目录层级:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, parent <span class="keyword">in</span> <span class="built_in">enumerate</span>(path.parents):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  级别 <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>: <span class="subst">&#123;parent&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">analyze_file_path(<span class="string">&quot;/xxx/utils/helper.py&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="场景四：配置文件管理器"><a href="#场景四：配置文件管理器" class="headerlink" title="场景四：配置文件管理器"></a>场景四：配置文件管理器</h3><p>优雅地处理应用配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigManager</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;配置文件管理器&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app_name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.app_name = app_name</span><br><span class="line">        <span class="comment"># 创建配置目录</span></span><br><span class="line">        <span class="variable language_">self</span>.config_dir = Path.home() / <span class="string">f&quot;.<span class="subst">&#123;app_name&#125;</span>&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.config_dir.mkdir(exist_ok=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义配置文件路径</span></span><br><span class="line">        <span class="variable language_">self</span>.config_file = <span class="variable language_">self</span>.config_dir / <span class="string">&quot;config.json&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.log_file = <span class="variable language_">self</span>.config_dir / <span class="string">&quot;app.log&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_config</span>(<span class="params">self, config_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;保存配置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> json</span><br><span class="line">        <span class="variable language_">self</span>.config_file.write_text(</span><br><span class="line">            json.dumps(config_data, indent=<span class="number">2</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;配置已保存到: <span class="subst">&#123;self.config_file&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_config</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;加载配置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.config_file.exists():</span><br><span class="line">            <span class="keyword">import</span> json</span><br><span class="line">            <span class="keyword">return</span> json.loads(<span class="variable language_">self</span>.config_file.read_text())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">log_message</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;写入日志&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">        timestamp = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        log_entry = <span class="string">f&quot;[<span class="subst">&#123;timestamp&#125;</span>] <span class="subst">&#123;message&#125;</span>\n&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 追加写入日志</span></span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>.log_file.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(log_entry)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">config_mgr = ConfigManager(<span class="string">&quot;myapp&quot;</span>)</span><br><span class="line">config_mgr.save_config(&#123;<span class="string">&quot;theme&quot;</span>: <span class="string">&quot;dark&quot;</span>, <span class="string">&quot;language&quot;</span>: <span class="string">&quot;zh-CN&quot;</span>&#125;)</span><br><span class="line">config_mgr.log_message(<span class="string">&quot;应用启动&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>从os.path到pathlib，这不仅仅是一个库的替换，更是Python在”优雅”和”可读性”道路上的又一次进化。</p><p>下次当你需要处理文件路径时，不妨试试pathlib。相信我，一旦习惯了这种优雅的写法，你就再也回不去os.path的繁琐世界了。</p><hr><p><strong>参考资料</strong>：</p><ul><li><a href="https://docs.python.org/3/library/pathlib.html">官方文档</a>  </li><li><a href="https://peps.python.org/pep-0428/">PEP 428: The pathlib module</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在日常Python开发中，文件路径操作是绕不开的话题。你是否还在使用&lt;code&gt;os.path.join()&lt;/code&gt;拼接路径？是否还在为Windows和Linux的路径分隔符头疼？是否期待一种更Pythonic的方式来处理路径？&lt;/p&gt;
&lt;p&gt;先来看一个直观的对比，即</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python库" scheme="http://sswfive.xyz/tags/python%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之【数组】</title>
    <link href="http://sswfive.xyz/2025/09/10/dsa/250910-array/"/>
    <id>http://sswfive.xyz/2025/09/10/dsa/250910-array/</id>
    <published>2025-09-10T13:06:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念与原理"><a href="#概念与原理" class="headerlink" title="概念与原理"></a>概念与原理</h2><p>数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组可以分为静态数组和动态数组两大类。</p><ul><li>静态数组：是一块连续的内存空间，我们可以通过索引来访问这块内存空间中的元素，这也是数组的原始形态。</li><li>动态数组：是编程语言为了方便开发者使用，在静态数组的基础上添加了一些常用的API，如<code>push, insert, remove</code> 等方法,这些API可以让我们更方便的操作数组元素，不用自己写代码去实现。<br><img src="http://cdn.sswfive.xyz/2025-10/251023010055678_1761152455685.png" alt="251023010055678.png"></li></ul><h2 id="数组的常用操作（增删改查）"><a href="#数组的常用操作（增删改查）" class="headerlink" title="数组的常用操作（增删改查）"></a>数组的常用操作（增删改查）</h2><blockquote><p>数据结构的职责就是增删改查，再无其他。</p></blockquote><p><img src="http://cdn.sswfive.xyz/2025-10/251023013110619_1761154270626.png" alt="251023013110619.png"></p><h2 id="数组的特性"><a href="#数组的特性" class="headerlink" title="数组的特性"></a>数组的特性</h2><p><strong>适合查询多修改少的操作，在使用时需要警惕数据访问越界的问题。</strong>。</p><ul><li>查询效率快，因为数组的结构特点是，根据偏移量（下标）访问速度快，所以随机访问性好。</li><li>插入、删除效率低，由于其是连续的线性结构，在删除和插入时通常都会伴随着数据的搬迁。</li></ul><h2 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h2><p>在考虑性能时，通常需要去分析不同API的复杂度；另外，数组和链表通常起到了互补的作用，来应对不同的数据处理场景。数组适合查询，链表适合插入和删除。以下列出了常规情况下不同的API的时间复杂度，但具体问题还需要具体分析。</p><ul><li>查询(Access)：<ul><li><strong>根据下标随机访问的时间复杂度：O(1)</strong></li></ul></li><li>插入(Insert)：<ul><li>最好情况（末尾插入）时间复杂度：O(1)</li><li>最坏情况（头部插入）时间复杂度：O(n)</li><li><strong>平均情况时间复杂度：(1+2+…n)&#x2F;n &#x3D; O(n)</strong></li></ul></li><li>删除(Delete)：<ul><li>最好情况（末尾删除）时间复杂度：O(1)</li><li>最坏情况（开头删除）时间复杂度：O(n)</li><li><strong>平均情况时间复杂度：O(n)</strong></li></ul></li><li>修改(Update)：<ul><li>给定指定索引，修改索引对应的元素的值，时间复杂度O(1)。</li></ul></li></ul><h2 id="数组典型应用"><a href="#数组典型应用" class="headerlink" title="数组典型应用"></a>数组典型应用</h2><ul><li><strong>随机访问</strong>：如果想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li><li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li><li><strong>查找表</strong>：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li><li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li><li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li></ul><h2 id="实践应用"><a href="#实践应用" class="headerlink" title="实践应用"></a>实践应用</h2><h3 id="实践一：插入操作优化"><a href="#实践一：插入操作优化" class="headerlink" title="实践一：插入操作优化"></a>实践一：插入操作优化</h3><p>在数组的k个位置插入一个数据，若不涉及排序操作，只被用来存储数据的集合，比较优选的方案是，将第k个位置的数据移动到数据的末尾，再将需要的数据插入到第k位，这样就避免了其他数据的移动，从而提高了插入效率，且时间复杂度被降到O(1).<br>快排的实现思路就是如此。</p><h3 id="实践二：删除操作优化"><a href="#实践二：删除操作优化" class="headerlink" title="实践二：删除操作优化"></a>实践二：删除操作优化</h3><p>通常情况下，删除第k个位置的数据，为了内存的连续性，k后面的数据都需要向前搬迁。<br>但在不考虑数据的连续性的场景中，则可以将多次删除操作集中在一起操作，从而提升删除效率。具体的做法就是：将需要删除的元素进行标记，并不执行真正的删除操作，当数据没有了更多存储空间时，再触发一次真正的删除操作，这样就能减少因为数据搬迁的次数。<br>JVM的标记清除垃圾回收算法就是此思想。</p><h3 id="实践三：高级编程语言中封装的容器能否替代数组？"><a href="#实践三：高级编程语言中封装的容器能否替代数组？" class="headerlink" title="实践三：高级编程语言中封装的容器能否替代数组？"></a>实践三：高级编程语言中封装的容器能否替代数组？</h3><p>如：python中的List， java中的ArrayList、C++中vector等；<br>通常需要根据实际情况来考虑，通常的关注点是性能方面的，比如说：</p><ul><li>若不是特别关注性能，使用编程语言中封装的对象即可，因为这些容器封装了常用操作，牺牲了性能，但让使用变得简单，可用于日常的业务开发</li><li>若特别关注性能，建议使用原生数组，因为原生性能好，但使用起来相对比较繁琐，一般用于底层框架的开发，如网络库的开发</li></ul><h2 id="相关算法题"><a href="#相关算法题" class="headerlink" title="相关算法题"></a>相关算法题</h2><h3 id="数组题目的解法技巧-双指针技巧"><a href="#数组题目的解法技巧-双指针技巧" class="headerlink" title="数组题目的解法技巧-&gt;双指针技巧"></a>数组题目的解法技巧-&gt;双指针技巧</h3><p>在数组中没有真正意义上的指针，通常把索引当做数组中的指针，</p><ul><li>左右指针：两个指针相向而行或者相背而行；</li><li>快慢指针：两个指针同向而行，一快一慢；</li></ul><h4 id="技巧一、快慢指针"><a href="#技巧一、快慢指针" class="headerlink" title="技巧一、快慢指针"></a>技巧一、快慢指针</h4><p>应用场景：</p><ul><li>应用在【原地修改数组】类型的算法题目上</li><li>应用在【滑动窗口】类型的算法题目上<br>实践思路；</li><li>让慢指针走在后面，快指针走在前面探路，在根据题目中的要求，写出相关判断条件。</li><li>对于滑动窗口的类型而言：慢指针在后，快指针在前，两个指针中间的部分就是【窗口】，算法通过扩大或缩小窗口来解决相关问题。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 框架Demo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    fast, slow = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> fast &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        fast += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h4 id="技巧二、左右指针"><a href="#技巧二、左右指针" class="headerlink" title="技巧二、左右指针"></a>技巧二、左右指针</h4><p>常用算法: 二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 框架Demo</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 一左一右两个指针相向而行</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (right + left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid </span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念与原理&quot;&gt;&lt;a href=&quot;#概念与原理&quot; class=&quot;headerlink&quot; title=&quot;概念与原理&quot;&gt;&lt;/a&gt;概念与原理&lt;/h2&gt;&lt;p&gt;数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。数组可以分为静态数组和</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Python异步编程十年沉浮：且看3.14版本重要更新</title>
    <link href="http://sswfive.xyz/2025/09/08/tech/python/250907-py-async-challenges/"/>
    <id>http://sswfive.xyz/2025/09/08/tech/python/250907-py-async-challenges/</id>
    <published>2025-09-08T00:08:59.000Z</published>
    <updated>2025-09-24T15:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>本周读到了一篇文章《<a href="https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html">Python has had async for 10 years – why isn’t it more popular?</a>》，深有感触，文章提出了一个值得深思的问题：Python 早在 2015 年就引入了 <code>async</code> 和 <code>await</code> 关键字，距今已近十年，为什么异步编程在 Python 社区中的普及仍不及预期？</p><p>这篇文章中指出了三大困境，也让我这个从Python2.7时代走过来的开发者深有共鸣。今天就结合我的实践经历，聊聊Python异步编程的过去、现在和未来。</p><h2 id="异步编程的三座大山"><a href="#异步编程的三座大山" class="headerlink" title="异步编程的三座大山"></a>异步编程的三座大山</h2><h3 id="困境一：适用场景受限"><a href="#困境一：适用场景受限" class="headerlink" title="困境一：适用场景受限"></a><strong>困境一：适用场景受限</strong></h3><p>asyncio 在网络 I&#x2F;O 方面表现出色，但对其他类型的 I&#x2F;O 支持有限。即使是看似异步的文件操作，底层仍然依赖线程池来模拟异步行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看似异步，实际仍使用线程池</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(<span class="string">&#x27;large_file.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    contents = <span class="keyword">await</span> f.read()  <span class="comment"># 底层依然是线程池实现</span></span><br></pre></td></tr></table></figure><p>生产环境中出于安全考虑，往往限制使用 <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a> 等系统级异步机制，进一步缩小了 asyncio 的适用范围。</p><h3 id="困境二：GIL-的根本限制"><a href="#困境二：GIL-的根本限制" class="headerlink" title="困境二：GIL 的根本限制"></a><strong>困境二：GIL 的根本限制</strong></h3><p>无论异步代码执行得多么高效，都无法突破 GIL（全局解释器锁）的天花板。async&#x2F;await 虽能优化 I&#x2F;O 密集型任务，但对 CPU 密集型操作帮助有限。</p><p>更麻烦的是错误处理——忘记 <code>await</code> 可能导致协程静默失败，这种隐形问题调试起来很棘手。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单次调用性能相同</span></span><br><span class="line">sync_result = get_data_sync()        <span class="comment"># 耗时 1 秒</span></span><br><span class="line">async_result = <span class="keyword">await</span> get_data_async() <span class="comment"># 同样耗时 1 秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有在并发场景下异步才显示优势</span></span><br><span class="line">results = <span class="keyword">await</span> asyncio.gather(*[</span><br><span class="line">    get_data_async() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">])  <span class="comment"># 总耗时约 1 秒（而非 10 秒）</span></span><br></pre></td></tr></table></figure><h3 id="困境三：双-API-的维护负担"><a href="#困境三：双-API-的维护负担" class="headerlink" title="困境三：双 API 的维护负担"></a><strong>困境三：双 API 的维护负担</strong></h3><p>为了兼容性，开发者往往需要同时维护同步和异步两套 API，大大增加了开发和维护成本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步版本</span></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_records</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Record]:</span><br><span class="line">    <span class="keyword">return</span> fetch_from_database(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版本 - API 设计不一致</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get_user_records</span>(<span class="params">self</span>) -&gt; <span class="built_in">list</span>[Record]:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> async_fetch_from_database(<span class="variable language_">self</span>.user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用时的心理负担：需要记住哪些方法需要 await</span></span><br><span class="line">user.name                                <span class="comment"># 普通属性</span></span><br><span class="line">records = <span class="keyword">await</span> user.get_user_records()  <span class="comment"># 异步方法</span></span><br></pre></td></tr></table></figure><p>从魔法方法无法异步化，到属性访问方式的不一致，再到代码重复和测试复杂度增加，都让开发者望而却步。</p><h2 id="异步编程的演进之路"><a href="#异步编程的演进之路" class="headerlink" title="异步编程的演进之路"></a>异步编程的演进之路</h2><h3 id="什么是异步编程？"><a href="#什么是异步编程？" class="headerlink" title="什么是异步编程？"></a>什么是异步编程？</h3><p>异步编程是一种非阻塞的编程范式，允许程序在等待某些操作（如I&#x2F;O）完成时继续执行其他任务，而不是干等着。</p><p>同步 VS 异步的直观对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步版本 - 顺序执行</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sync_demo</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name, delay</span>):</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 完成&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    task(<span class="string">&quot;任务1&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    task(<span class="string">&quot;任务2&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    task(<span class="string">&quot;任务3&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;同步总耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步版本 - 并发执行  </span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_demo</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name, delay</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 完成&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        task(<span class="string">&quot;任务1&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        task(<span class="string">&quot;任务2&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        task(<span class="string">&quot;任务3&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异步总耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行对比</span></span><br><span class="line">sync_demo()    <span class="comment"># 输出：总耗时约3秒</span></span><br><span class="line">asyncio.run(async_demo())  <span class="comment"># 输出：总耗时约1秒</span></span><br></pre></td></tr></table></figure><h3 id="三种实现方式的变迁"><a href="#三种实现方式的变迁" class="headerlink" title="三种实现方式的变迁"></a>三种实现方式的变迁</h3><h4 id="方式一：回调函数（Callback）——原始方案"><a href="#方式一：回调函数（Callback）——原始方案" class="headerlink" title="方式一：回调函数（Callback）——原始方案"></a>方式一：回调函数（Callback）——原始方案</h4><p>兼容性好，但代码难以维护（坊间流传一个词：回调地狱）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;回调函数示例 - 早期的异步解决方案&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download_complete</span>(<span class="params">future</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;下载完成时的回调函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = future.result()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;下载完成，状态码: <span class="subst">&#123;result.status_code&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;获取数据长度: <span class="subst">&#123;<span class="built_in">len</span>(result.text)&#125;</span> 字符&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;下载失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始回调函数示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 提交多个任务</span></span><br><span class="line">        futures = []</span><br><span class="line">        urls = [</span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/2&#x27;</span>, </span><br><span class="line">            <span class="string">&#x27;https://httpbin.org/delay/1&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            future = executor.submit(requests.get, url)</span><br><span class="line">            future.add_done_callback(download_complete)</span><br><span class="line">            futures.append(future)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 等待所有任务完成</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            future.result()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;回调函数示例总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">callback_example()</span><br></pre></td></tr></table></figure><h4 id="方式二：生成器（Generator）—过渡方案"><a href="#方式二：生成器（Generator）—过渡方案" class="headerlink" title="方式二：生成器（Generator）—过渡方案"></a>方式二：生成器（Generator）—过渡方案</h4><p>虽然避免了回调地狱，代码变的更清晰了，但需要手动调度，实现变的更复杂了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> coroutine</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generator_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成器实现协程 - Python 3.4时代的解决方案&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @coroutine</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">async_sleep</span>(<span class="params">delay</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟异步sleep&quot;&quot;&quot;</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">while</span> time.time() - start &lt; delay:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;休眠了<span class="subst">&#123;delay&#125;</span>秒&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_coroutines</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行多个协程&quot;&quot;&quot;</span></span><br><span class="line">        tasks = [async_sleep(<span class="number">1</span>), async_sleep(<span class="number">2</span>), async_sleep(<span class="number">1</span>)]</span><br><span class="line">        results = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> tasks:</span><br><span class="line">            current = tasks.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="built_in">next</span>(current)</span><br><span class="line">                tasks.append(current)  <span class="comment"># 如果还没完成，放回队列</span></span><br><span class="line">            <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">                results.append(e.value)  <span class="comment"># 协程完成，获取返回值</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始生成器协程示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    results = run_coroutines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成器协程结果: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成器示例总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">generator_example()</span><br></pre></td></tr></table></figure><h4 id="方式三：Async-Await——现代方案"><a href="#方式三：Async-Await——现代方案" class="headerlink" title="方式三：Async&#x2F;Await——现代方案"></a>方式三：Async&#x2F;Await——现代方案</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">modern_async_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;现代async/await示例&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url, delay</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;模拟异步数据获取&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;开始获取 <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;完成获取 <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;url&#125;</span> 的数据（延迟<span class="subst">&#123;delay&#125;</span>秒）&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始现代async/await示例...&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发执行多个异步任务</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api1.com&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api2.com&quot;</span>, <span class="number">2</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api3.com&quot;</span>, <span class="number">1</span>),</span><br><span class="line">        fetch_data(<span class="string">&quot;https://api4.com&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有任务完成结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  - <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;现代async/await总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行示例</span></span><br><span class="line">asyncio.run(modern_async_example())</span><br></pre></td></tr></table></figure><h2 id="asyncio：现代异步解决方案"><a href="#asyncio：现代异步解决方案" class="headerlink" title="asyncio：现代异步解决方案"></a>asyncio：现代异步解决方案</h2><p>异步编程的核心优势在于：<strong>当一个协程等待 I&#x2F;O 操作时，事件循环可以切换执行其他协程，从而提高整体吞吐量</strong>。</p><h3 id="asyncio的核心概念"><a href="#asyncio的核心概念" class="headerlink" title="asyncio的核心概念"></a>asyncio的核心概念</h3><p><strong>协程（Coroutine）</strong>：异步函数</p><ul><li>是异步编程的基础模块，使用<code>async def</code>定义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的协程</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">say_hello</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始向 <span class="subst">&#123;name&#125;</span> 问好&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你好, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 的问候完成&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行协程的三种方式</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 方式1: 直接await</span></span><br><span class="line">    result1 = <span class="keyword">await</span> say_hello(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方式2: 使用asyncio.create_task</span></span><br><span class="line">    task = asyncio.create_task(say_hello(<span class="string">&quot;Bob&quot;</span>))</span><br><span class="line">    result2 = <span class="keyword">await</span> task</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 方式3: 使用asyncio.gather并发执行</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        say_hello(<span class="string">&quot;Charlie&quot;</span>),</span><br><span class="line">        say_hello(<span class="string">&quot;David&quot;</span>),</span><br><span class="line">        say_hello(<span class="string">&quot;Eve&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行主函数</span></span><br><span class="line">results = asyncio.run(main())</span><br><span class="line"><span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure><p><strong>事件循环（Event Loop）</strong>：</p><ul><li>异步引擎，也是asyncio的核心，负责调度和执行协程</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">demo_event_loop</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;事件循环demo&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前时间: <span class="subst">&#123;loop.time()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安排回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;回调函数被调用: <span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 安排定时回调</span></span><br><span class="line">    loop.call_later(<span class="number">2</span>, callback, <span class="string">&quot;2秒后&quot;</span>)</span><br><span class="line">    loop.call_soon(callback, <span class="string">&quot;立即&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;演示结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(demo_event_loop())</span><br></pre></td></tr></table></figure><p><strong>任务（Task）</strong>：</p><ul><li>协程的包装器，用于并发执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">task_management</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;任务管理演示&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">name, seconds</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 开始工作&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(seconds)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 工作完成&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 工作了<span class="subst">&#123;seconds&#125;</span>秒&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建多个任务</span></span><br><span class="line">    tasks = [</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人1&quot;</span>, <span class="number">2</span>)),</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人2&quot;</span>, <span class="number">1</span>)),</span><br><span class="line">        asyncio.create_task(worker(<span class="string">&quot;工人3&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有任务已创建，开始并发执行...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有任务完成: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 任务状态检查</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;task.get_name()&#125;</span>: 完成=<span class="subst">&#123;task.done()&#125;</span>, 结果=<span class="subst">&#123;task.result()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(task_management())</span><br></pre></td></tr></table></figure><p><strong>Future对象</strong>：</p><ul><li>代表一个尚未完成的计算结果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">future_demo</span>():</span><br><span class="line">    <span class="comment"># 创建Future对象</span></span><br><span class="line">    future = asyncio.Future()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Future状态: <span class="subst">&#123;future.done()&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置结果（通常在别处）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_result</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;设置Future结果&quot;</span>)</span><br><span class="line">        future.set_result(<span class="string">&quot;完成!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2秒后设置结果</span></span><br><span class="line">    asyncio.get_event_loop().call_later(<span class="number">2</span>, set_result)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待Future完成</span></span><br><span class="line">    result = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Future状态: <span class="subst">&#123;future.done()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">asyncio.run(future_demo())</span><br></pre></td></tr></table></figure><h3 id="低级API-vs-高级API对比"><a href="#低级API-vs-高级API对比" class="headerlink" title="低级API vs 高级API对比"></a>低级API vs 高级API对比</h3><p>更全面的低级API的用法请：<a href="https://docs.python.org/zh-cn/3.13/library/asyncio-llapi-index.html">点进前往</a></p><p>更全面的高级API的用法请：<a href="https://docs.python.org/zh-cn/3.13/library/asyncio-api-index.html">点进前往</a></p><table><thead><tr><th align="left">类别</th><th align="left">API名称</th><th align="left">说明</th><th align="left">使用场景</th></tr></thead><tbody><tr><td align="left"><strong>低级API</strong></td><td align="left"><code>loop.create_future()</code></td><td align="left">创建Future对象</td><td align="left">需要精细控制时</td></tr><tr><td align="left"></td><td align="left"><code>loop.call_soon()</code></td><td align="left">立即调度回调</td><td align="left">优先级高的任务</td></tr><tr><td align="left"></td><td align="left"><code>loop.call_later()</code></td><td align="left">延迟调度</td><td align="left">定时任务</td></tr><tr><td align="left"></td><td align="left"><code>loop.run_in_executor()</code></td><td align="left">在线程池中运行</td><td align="left">CPU密集型任务</td></tr><tr><td align="left"><strong>高级API</strong></td><td align="left"><code>asyncio.run()</code></td><td align="left">运行协程</td><td align="left">程序入口点</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.create_task()</code></td><td align="left">创建任务</td><td align="left">并发执行协程</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.gather()</code></td><td align="left">并发运行多个任务</td><td align="left">等待多个任务完成</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.wait()</code></td><td align="left">更灵活的任务等待</td><td align="left">需要超时或优先完成时</td></tr><tr><td align="left"></td><td align="left"><code>asyncio.sleep()</code></td><td align="left">异步等待</td><td align="left">模拟I&#x2F;O操作</td></tr></tbody></table><h3 id="asyncio高级特性"><a href="#asyncio高级特性" class="headerlink" title="asyncio高级特性"></a>asyncio高级特性</h3><ul><li><strong>信号量控制并发数</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_concurrency</span>():</span><br><span class="line">    semaphore = asyncio.Semaphore(<span class="number">3</span>)  <span class="comment"># 最大并发数3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_task</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;i&#125;</span> 开始&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;i&#125;</span> 完成&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建10个任务，但最多同时执行3个</span></span><br><span class="line">    tasks = [limited_task(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;所有任务完成: <span class="subst">&#123;results&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(limited_concurrency())</span><br></pre></td></tr></table></figure><ul><li><strong>超时与取消控制</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">timeout_cancel_demo</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;超时和取消demo&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">long_running_task</span>(<span class="params">name, seconds</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 开始运行&quot;</span>)</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(seconds)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 正常完成&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 成功&quot;</span></span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> 被取消&quot;</span>)</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 超时控制</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(</span><br><span class="line">            long_running_task(<span class="string">&quot;任务A&quot;</span>, <span class="number">5</span>), </span><br><span class="line">            timeout=<span class="number">2.0</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;任务A结果: <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务A超时&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 手动取消</span></span><br><span class="line">    task_b = asyncio.create_task(long_running_task(<span class="string">&quot;任务B&quot;</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    task_b.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task_b</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务B已取消&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(timeout_cancel_demo())</span><br></pre></td></tr></table></figure><ul><li><strong>队列处理</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">queue_example</span>():</span><br><span class="line">    queue = asyncio.Queue(maxsize=<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(random.random())</span><br><span class="line">            <span class="keyword">await</span> queue.put(<span class="string">f&quot;消息 <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;生产: 消息 <span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            item = <span class="keyword">await</span> queue.get()</span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(random.random() * <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;消费: <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">            queue.task_done()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动生产者和消费者</span></span><br><span class="line">    producer_task = asyncio.create_task(producer())</span><br><span class="line">    consumer_task = asyncio.create_task(consumer())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> producer_task</span><br><span class="line">    <span class="keyword">await</span> queue.join()  <span class="comment"># 等待所有任务完成</span></span><br><span class="line">    consumer_task.cancel()</span><br><span class="line"></span><br><span class="line">asyncio.run(queue_example())</span><br></pre></td></tr></table></figure><h3 id="常用场景的代码框架"><a href="#常用场景的代码框架" class="headerlink" title="常用场景的代码框架"></a>常用场景的代码框架</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">advanced_patterns</span>():</span><br><span class="line">    <span class="comment"># 1. 限制并发数</span></span><br><span class="line">    semaphore = asyncio.Semaphore(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">limited_request</span>(<span class="params">url</span>):</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">                <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 超时控制</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(</span><br><span class="line">            limited_request(<span class="string">&#x27;https://httpbin.org/delay/5&#x27;</span>), </span><br><span class="line">            timeout=<span class="number">3.0</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> asyncio.TimeoutError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请求超时&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 任务取消</span></span><br><span class="line">    task = asyncio.create_task(limited_request(<span class="string">&#x27;https://httpbin.org/delay/10&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    task.cancel()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> task</span><br><span class="line">    <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;任务被取消&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="实践中的挑战与解决方案"><a href="#实践中的挑战与解决方案" class="headerlink" title="实践中的挑战与解决方案"></a>实践中的挑战与解决方案</h2><h3 id="识别适合异步的场景"><a href="#识别适合异步的场景" class="headerlink" title="识别适合异步的场景"></a>识别适合异步的场景</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 适合异步：网络 I/O 密集型</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">good_async_example</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_api_data</span>(<span class="params">api_url</span>):</span><br><span class="line">        <span class="comment"># 模拟网络请求</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;数据来自 <span class="subst">&#123;api_url&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 并发执行多个网络请求</span></span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(</span><br><span class="line">        fetch_api_data(<span class="string">&quot;api1&quot;</span>),</span><br><span class="line">        fetch_api_data(<span class="string">&quot;api2&quot;</span>), </span><br><span class="line">        fetch_api_data(<span class="string">&quot;api3&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;异步网络请求耗时: <span class="subst">&#123;time.time() - start:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)  <span class="comment"># 约1秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不适合异步：CPU 密集型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bad_async_example</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>(<span class="params">n</span>):</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            total += i * i</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 即使用异步包装，由于 GIL 限制，性能提升有限</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">async_cpu_task</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> cpu_intensive_task(n)</span><br><span class="line"></span><br><span class="line">asyncio.run(good_async_example())</span><br></pre></td></tr></table></figure><h3 id="混合使用异步与执行器"><a href="#混合使用异步与执行器" class="headerlink" title="混合使用异步与执行器"></a>混合使用异步与执行器</h3><p>针对 GIL 限制，我们可以结合异步和执行器来解决不同类型的任务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hybrid_solution</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cpu_task</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;CPU 密集型任务&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">blocking_io_task</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;阻塞 I/O 任务&quot;&quot;&quot;</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;阻塞任务完成&quot;</span></span><br><span class="line">    </span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># CPU 密集型任务使用进程池</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> process_pool:</span><br><span class="line">        cpu_futures = [</span><br><span class="line">            loop.run_in_executor(process_pool, cpu_task, <span class="number">100000</span>)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 阻塞 I/O 使用线程池  </span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> thread_pool:</span><br><span class="line">        io_futures = [</span><br><span class="line">            loop.run_in_executor(thread_pool, blocking_io_task)</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">        ]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发执行所有任务</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    cpu_results = <span class="keyword">await</span> asyncio.gather(*cpu_futures)</span><br><span class="line">    io_results = <span class="keyword">await</span> asyncio.gather(*io_futures)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;混合方案总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span>秒&quot;</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(hybrid_solution())</span><br></pre></td></tr></table></figure><h3 id="统一API设计模式"><a href="#统一API设计模式" class="headerlink" title="统一API设计模式"></a>统一API设计模式</h3><p>针对双 API 维护问题，这里提供一个实用的解决方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span>, Awaitable, overload</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnifiedDataService</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;统一的数据服务，支持同步和异步调用&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @overload</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="built_in">str</span>: ...</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @overload  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">True</span></span>) -&gt; Awaitable[<span class="built_in">str</span>]: ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self, key: <span class="built_in">str</span>, *, async_mode: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="type">Union</span>[<span class="built_in">str</span>, Awaitable[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;根据 async_mode 参数决定返回同步还是异步结果&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> async_mode:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._async_get_data(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>._sync_get_data(key)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_sync_get_data</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;同步获取: <span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_async_get_data</span>(<span class="params">self, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.1</span>)  <span class="comment"># 模拟异步操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;异步获取: <span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line">service = UnifiedDataService()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步调用</span></span><br><span class="line">sync_result = service.get_data(<span class="string">&quot;key1&quot;</span>, async_mode=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(sync_result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异步调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test_async</span>():</span><br><span class="line">    async_result = <span class="keyword">await</span> service.get_data(<span class="string">&quot;key1&quot;</span>, async_mode=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(async_result)</span><br><span class="line"></span><br><span class="line">asyncio.run(test_async())</span><br></pre></td></tr></table></figure><h2 id="持续关注：Python-3-14-的革命性变化"><a href="#持续关注：Python-3-14-的革命性变化" class="headerlink" title="持续关注：Python 3.14 的革命性变化"></a>持续关注：Python 3.14 的革命性变化</h2><p>正如文章中所预言的，Python 3.14 带来了两个具有历史意义的并发编程突破，有望彻底改变当前的格局。</p><h3 id="PEP-779-Free-Threading-的历史性突破"><a href="#PEP-779-Free-Threading-的历史性突破" class="headerlink" title="PEP 779: Free-Threading 的历史性突破"></a>PEP 779: Free-Threading 的历史性突破</h3><p><strong>核心改变</strong>：移除 GIL 限制，实现真正的多线程并行执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Free-Threading 模式下，这些操作可以真正并行</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_intensive_task</span>(<span class="params">name, n</span>):</span><br><span class="line">    total = <span class="built_in">sum</span>(i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;name&#125;</span> 完成: <span class="subst">&#123;total&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前受 GIL 限制，现在可以真正并行</span></span><br><span class="line">threads = []</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    thread = threading.Thread(</span><br><span class="line">        target=cpu_intensive_task, </span><br><span class="line">        args=[<span class="string">f&quot;Thread-<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="number">1000000</span>]</span><br><span class="line">    )</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总耗时: <span class="subst">&#123;time.time() - start_time:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br><span class="line"><span class="comment"># Free-Threading 模式下，4个线程可以真正并行</span></span><br></pre></td></tr></table></figure><p>重大意义：</p><ul><li>性能革命：CPU 密集型任务可以充分利用多核处理器</li><li>降低复杂性：某些场景下线程可能比协程更简单易用</li><li>向后兼容：现有异步代码仍然有效</li></ul><h3 id="PEP-734-多解释器支持"><a href="#PEP-734-多解释器支持" class="headerlink" title="PEP 734: 多解释器支持"></a>PEP 734: 多解释器支持</h3><p><strong>核心特性</strong>：每个解释器拥有独立的全局状态，提供更安全的并行执行环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码示例（PEP 734 实现）</span></span><br><span class="line"><span class="keyword">import</span> interpreters</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建独立的解释器实例</span></span><br><span class="line">interp1 = interpreters.create()</span><br><span class="line">interp2 = interpreters.create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在不同解释器中执行代码，完全隔离</span></span><br><span class="line">code1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def cpu_task():</span></span><br><span class="line"><span class="string">    return sum(i*i for i in range(1000000))</span></span><br><span class="line"><span class="string">result = cpu_task()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">async def io_task():</span></span><br><span class="line"><span class="string">    await asyncio.sleep(1)</span></span><br><span class="line"><span class="string">    return &quot;IO task completed&quot;</span></span><br><span class="line"><span class="string">result = asyncio.run(io_task())</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行执行，每个解释器独立运行</span></span><br><span class="line">interp1.<span class="built_in">exec</span>(code1)</span><br><span class="line">interp2.<span class="built_in">exec</span>(code2)</span><br></pre></td></tr></table></figure><h3 id="对异步编程的影响"><a href="#对异步编程的影响" class="headerlink" title="对异步编程的影响"></a>对异步编程的影响</h3><p><strong>竞争与互补的新格局</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 场景分析：不同工作负载的最优选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># I/O 密集型 - 异步仍然是最佳选择</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">io_heavy_work</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        tasks = [session.get(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU 密集型 - Free-Threading 提供新选择  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cpu_heavy_work</span>():</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        futures = [executor.submit(compute, data) <span class="keyword">for</span> data <span class="keyword">in</span> datasets]</span><br><span class="line">        <span class="keyword">return</span> [f.result() <span class="keyword">for</span> f <span class="keyword">in</span> futures]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合工作负载 - 多解释器方案</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hybrid_work</span>():</span><br><span class="line">    io_interp = interpreters.create()</span><br><span class="line">    cpu_interp = interpreters.create()</span><br><span class="line">    <span class="comment"># 不同类型的任务在不同解释器中执行</span></span><br></pre></td></tr></table></figure><h2 id="项目选型的一些建议"><a href="#项目选型的一些建议" class="headerlink" title="项目选型的一些建议"></a>项目选型的一些建议</h2><p><strong>立即可行的方案</strong>：</p><ol><li><strong>I&#x2F;O 密集型项目</strong>：继续使用 FastAPI + aiohttp 异步方案</li><li><strong>CPU 密集型项目</strong>：采用多进程方案或等待 Free-Threading 稳定</li><li><strong>混合负载项目</strong>：考虑 asyncio + 执行器的混合方案</li></ol><p><strong>Web 框架推荐</strong>：</p><ul><li>新项目：FastAPI（异步优先）&gt; Django 4.1+（异步支持）</li><li>现有项目：渐进式引入异步，在 I&#x2F;O 边界使用</li></ul><p><strong>HTTP 客户端推荐</strong>：</p><ul><li>异步场景：aiohttp &gt; httpx（异步模式）</li><li>同步场景：httpx（同步模式）&gt; requests</li></ul><h2 id="异步编程的未来可期"><a href="#异步编程的未来可期" class="headerlink" title="异步编程的未来可期"></a>异步编程的未来可期</h2><p>异步编程就是一把双刃剑——用对了场景能大幅提升性能，用错了反而增加复杂度，开篇引入的那边文章就是很好的揭示了这一点。</p><ul><li><strong>当下</strong>：在适合的场景（Web API、爬虫、实时应用）继续使用异步编程</li><li><strong>未来</strong>：关注 Python 3.14+ 的发展，准备拥抱多样化的并发解决方案</li></ul><p>技术选型没有银弹，只有最适合的方案。随着 Python 并发能力的不断增强，我相信，未来的异步编程会更加简单、强大和普及。</p><hr><p><strong>参考资料</strong>：</p><ul><li><a href="https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html">Python has had async for 10 years – why isn’t it more popular?</a> - Anthony Shaw</li><li><a href="https://peps.python.org/pep-0703/">PEP 703: Making the Global Interpreter Lock Optional</a></li><li><a href="https://peps.python.org/pep-0734/">PEP 734: Multiple Interpreters in the Stdlib</a></li><li><a href="https://docs.python.org/3/library/asyncio.html">asyncio 官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周读到了一篇文章《&lt;a href=&quot;https://tonybaloney.github.io/posts/why-isnt-python-async-more-popular.html&quot;&gt;Python has had async for 10 years – why i</summary>
      
    
    
    
    <category term="Python" scheme="http://sswfive.xyz/categories/Python/"/>
    
    
    <category term="python工程实践" scheme="http://sswfive.xyz/tags/python%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    <category term="异步编程" scheme="http://sswfive.xyz/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构的基本知识</title>
    <link href="http://sswfive.xyz/2025/09/02/dsa/250902-data-structure-basic/"/>
    <id>http://sswfive.xyz/2025/09/02/dsa/250902-data-structure-basic/</id>
    <published>2025-09-02T08:36:01.000Z</published>
    <updated>2025-12-12T17:39:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构的分类"><a href="#数据结构的分类" class="headerlink" title="数据结构的分类"></a>数据结构的分类</h2><p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从<strong>逻辑结构</strong>和<strong>物理结构</strong>两个维度进行分类。</p><h3 id="逻辑结构：线性与非线性"><a href="#逻辑结构：线性与非线性" class="headerlink" title="逻辑结构：线性与非线性"></a>逻辑结构：线性与非线性</h3><p>逻辑结构主要描述的是数据元素之间的逻辑关系，它可以分为<strong>线性</strong>和<strong>非线性</strong>两大类。简言之，线性结构指数据在逻辑关系上呈线性排列，非线性结构则呈非线性排列。</p><ul><li>线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li><li>非线性数据结构：树、堆、图、哈希表。<br>非线性结构又可以进一步分为<strong>树形结构</strong>和<strong>网状结构</strong>：</li><li>树形结构：树、堆、哈希表、元素之间一对多的关系</li><li>网状结构：图，元素之间是多对多的关系</li></ul><h3 id="物理结构：连续和分散"><a href="#物理结构：连续和分散" class="headerlink" title="物理结构：连续和分散"></a>物理结构：连续和分散</h3><p>物理结构反映了数据在计算机<strong>内存中的存储方式</strong>。可分为连续空间存储（<strong>数组</strong>）和分散空间存储（<strong>链表</strong>）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p><p>需要注意的是，所有的数据结构都是基于数组、链表或者二者的组合实现的：</p><ul><li>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度&gt; &#x3D;3的数组）等。</li><li>基于链表可实现：栈、队列、哈希表、树、堆、图等。</li></ul><p><img src="http://cdn.sswfive.xyz/2025-10/251022234510355_1761147910368.png" alt="251022234510355.png"></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们日常了解到的文本、图片、视频、语音、3D模型等格式的数据，基本都是由各种基本数据类型组构成。</p><h3 id="什么是基本数据类型"><a href="#什么是基本数据类型" class="headerlink" title="什么是基本数据类型"></a>什么是基本数据类型</h3><p>通常而言，基本数据类型是<strong>CPU可以直接进行运算的类型</strong>，或者在算法中直接被使用的类型，主要包括以下几种：</p><ul><li>整数类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>浮点数类型<code>float</code>、<code>double</code> ，用于表示小数。</li><li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li><li>布尔类型<code>bool</code> ，用于表示“是”与“否”判断。<br>基本数据类型以<strong>二进制的形式存储在计算机中</strong>，一个二进制位即为1bit,在绝大多操作系统中，  1字节（byte）由  8比特（bit）组成。</li></ul><h3 id="基本数据类型与数据结构的关系"><a href="#基本数据类型与数据结构的关系" class="headerlink" title="基本数据类型与数据结构的关系"></a>基本数据类型与数据结构的关系</h3><p>基本数据类型提供了数据的“<strong>内容类型</strong>”，而数据结构提供了数据的“<strong>组织方式</strong>”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用多种基本数据类型来初始化数组</span></span><br><span class="line">numbers: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">0</span>] * <span class="number">5</span></span><br><span class="line">decimals: <span class="built_in">list</span>[<span class="built_in">float</span>] = [<span class="number">0.0</span>] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的字符实际上是长度为 1 的字符串</span></span><br><span class="line">characters: <span class="built_in">list</span>[<span class="built_in">str</span>] = [<span class="string">&#x27;0&#x27;</span>] * <span class="number">5</span></span><br><span class="line">bools: <span class="built_in">list</span>[<span class="built_in">bool</span>] = [<span class="literal">False</span>] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的列表可以自由存储各种基本数据类型和对象引用</span></span><br><span class="line">data = [<span class="number">0</span>, <span class="number">0.0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">False</span>, ListNode(<span class="number">0</span>)]</span><br></pre></td></tr></table></figure><h2 id="数字编码"><a href="#数字编码" class="headerlink" title="数字编码"></a>数字编码</h2><h3 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h3><blockquote><p>数字是以“补码”的形式存储在计算机中。</p></blockquote><ul><li>原码：将数字的二进制表示的最高位视为符号位，其中0表示正数，1表示负数，其余位表示数字的值。</li><li>反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加1。<br><img src="http://cdn.sswfive.xyz/2025-10/251023000940431_1761149380441.png" alt="251023000940431.png"></li></ul><p>需要注意的是：</p><ul><li>引入反码是为了解决负数不能直接用于用算。</li><li>引入补码是为了解决原码和反码都有正负零歧义问题。</li></ul><h3 id="浮点数编码"><a href="#浮点数编码" class="headerlink" title="浮点数编码"></a>浮点数编码</h3><p>为什么<code>int</code>和<code>float</code>长度都是4字节，但<code>float</code>取值范围远大于<code>int</code>?</p><p>因为<code>float</code>采用了不同的表示方式，根据 IEEE 754 标准，32-bit 长度的 <code>float</code> 由以下三个部分构成:</p><ul><li>符号位S：占1位</li><li>指数位E：占8位</li><li>分数位N：占23位<br><img src="http://cdn.sswfive.xyz/2025-10/251023002224549_1761150144555.png" alt="251023002224549.png"></li></ul><p><code>float</code>的表示方式包含指数位，导致其取值范围远大于<code>int</code>,但需要明白的是，尽管浮点数<code>float</code>扩展了取值范围，但其副作用是牺牲了精度。同理，双精度<code>double</code>也采用了类似的表示方法。</p><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>在计算机中，所有的数据都是以二进制的形式存储的，字符<code>char</code>也不例外，为了表示字符，需要建立一套字符集，用于规定每个字符和二进制数之间一一对应关系，有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换了。</p><h3 id="ASCII-字符集"><a href="#ASCII-字符集" class="headerlink" title="ASCII 字符集"></a>ASCII 字符集</h3><p>ASCII码，其全称为American Standard Code for Information Interchange（美国标准信息交换代码）：它使用7位2进制数（一个字节的低7位）表示一个字符，最多能够表示128个不同的字符。<br>最开始，ASCII码仅能表示英文，随着计算机的全球化，诞生了一种能够表示更多语言的 EASCII 字符集。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符。</p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><p>后来，EASCII 仍不够用。为处理数千日常汉字，我国于1980年推出了GB2312，收录6763字。后为兼容生僻字和繁体字，又扩展出GBK，收录21886字，并采用ASCII单字节、汉字双字节的编码方式。</p><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p>Unicode的中文名称为“统一码”，是一种通用字符集，理论上能容纳100多万个字符，本质上是给每个字符分配一个编码，称为“码点”，它没有规定在计算机中如何存储这些字符码点，而是直接将所有的字符存储为等长的编码，由于ASCII已经证明了编码英文只需要1字符，这就使得英文在Unicode下编码非常浪费内存空间，为了解决这个问题，产生了下列的UTF-8编码。</p><h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><p>UTF-8是当前使用最广泛的Unicode编码方法，它是一种可变长度的编码，使用1到4字节来表示一个字符，根据字符的复杂性而变，ASCII 字符只需 1 字节，拉丁字母和希腊字母需要 2 字节，常用的中文字符需要 3 字节，其他的一些生僻字符需要 4 字节。</p><p>UTF-8 的编码规则并不复杂，分为以下两种情况。</p><ul><li>对于长度为 1 字节的字符，将最高位设置为0 ，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，<strong>UTF-8 编码可以向下兼容 ASCII 码</strong>。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。</li><li>对于长度为 n 字节的字符（其中 n &gt; 1），将首个字节的高 n 位都设置为 1 ，第 n+1  位设置为 0 ；从第二个字节开始，将每个字节的高 2 位都设置为 10 ；其余所有位用于填充字符的 Unicode 码点。</li></ul><p>UTF-8 之外，常见的编码还有 UTF-16 和 UTF-32。</p><ul><li><strong>UTF-16</strong>：使用 2 或 4 字节表示字符。多数常用字符为 2 字节，且其编码值与 Unicode 码点相同。</li><li><strong>UTF-32</strong>：每个字符固定 4 字节，空间占用通常更大。</li></ul><p>总结对比：</p><ul><li><strong>存储空间</strong>：UTF-8 对英文高效（1字节）；UTF-16 对部分中文高效（2字节）。</li><li><strong>兼容性</strong>：UTF-8 通用性最佳，是优先支持的标准。</li></ul><h2 id="编程语言的字符编码"><a href="#编程语言的字符编码" class="headerlink" title="编程语言的字符编码"></a>编程语言的字符编码</h2><p>早期编程语言常采用 UTF-16 或 UTF-32 等长编码存储字符串，便于像数组一样处理，具有以下优势：</p><ul><li><strong>随机访问</strong>：UTF-16 可直接访问第 nn 个字符，时间复杂度为 O(1)O(1)；UTF-8 为变长编码，需要 O(n)O(n) 时间。</li><li><strong>字符计数</strong>：UTF-16 获取字符串长度为 O(1)O(1) 操作，UTF-8 需遍历整个字符串。</li><li><strong>字符串操作</strong>：在 UTF-16 上进行分割、连接、插入等操作更简单；UTF-8 需额外计算以避免编码错误。</li></ul><p>现代语言的改进方案</p><ul><li><strong>Python</strong>：str 类型根据最大 Unicode 码点动态选择存储：全 ASCII 用 1 字节，全在基本多语言平面（BMP）用 2 字节，有超出 BMP 的字符则用 4 字节。</li><li><strong>Go</strong>：string 内部使用 UTF-8，并提供 <code>rune</code> 表示单个 Unicode 码点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构的分类&quot;&gt;&lt;a href=&quot;#数据结构的分类&quot; class=&quot;headerlink&quot; title=&quot;数据结构的分类&quot;&gt;&lt;/a&gt;数据结构的分类&lt;/h2&gt;&lt;p&gt;常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从&lt;strong&gt;逻辑结构&lt;/s</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://sswfive.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="DSA" scheme="http://sswfive.xyz/tags/DSA/"/>
    
  </entry>
  
</feed>
